<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>security on Wise</title><link>https://wiseweb-works.github.io/blog/en/tags/security/</link><description>Recent content in security on Wise</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 27 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://wiseweb-works.github.io/blog/en/tags/security/index.xml" rel="self" type="application/rss+xml"/><item><title>OpenVPN In-Depth Review</title><link>https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/</link><pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/</guid><description>Introduction and Summary Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted.</description><content:encoded><![CDATA[<h1 id="introduction-and-summary">Introduction and Summary</h1>
<p>Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted. Therefore, I guess our article will consist of 3 parts and a question-answer section if necessary. Now let&rsquo;s buckle up and take a trip to the deep and gloomy world of the internet.</p>
<h2 id="what-is-openvpn-and-what-is-it-used-for">What is OpenVPN and what is it used for?</h2>
<p>Today, there is almost no business that cannot be done online. Even our work, which is not normally online, has evolved to work from home due to the pandemic and the new normal. However, there were big problems both because it is a working method that we are not used to and because our people are not very good with technology. Before it became clear that people needed to connect from their home computers to their office computers, some companies came up with frivolous ideas such as sending office computers to employees&rsquo; homes. They understood very well how wrong this was from the feedback they received in a short time. In short, it was finally accepted that electronic devices should remain in the office and somehow a secure and sustainable connection should be made remotely. Of course, institutions found themselves in such needs before, but such a large-scale situation was not in question back then. Before the pandemic, it used various protocols such as PPTP, L2TP, IPSec, IKev2, SSTP and finally OpenVPN. These are usually abbreviations for certain long and fancy words and their basic logic is to connect two or more devices and make them act as if they are on the same network. I won&rsquo;t talk much, as protocols prior to OpenVPN brought with them certain weaknesses, slowness, and technical difficulties with its implementation. OpenVPN is the name of the protocol and program that allows at least 2 devices in the role of server and client to connect to each other and do this in a way that meets industry standards. I&rsquo;m using a remote desktop program, I seem to hear you say what is the need for this. Unfortunately, he and all other programs like him basically have to use this protocol. If you press the shield icon or the connection details in TeamViewer, one of the most famous, you can see the OpenVPN protocol.</p>
<h2 id="what-do-we-need-to-establish-an-openvpn-connection">What do we need to establish an OpenVPN connection?</h2>
<p>First of all, OpenVPN must be installed on both the server and client (the device to be connected) side. Then, a settings (config) file should be edited that shows the conditions under which the devices will communicate. The main event is that this config file is generated and used by the client. This config file is divided into server_config used by the server and client_config used by the client.</p>
<h3 id="the-settings-file-maintained-by-the-server-contains-the-following-entries">The settings file maintained by the server contains the following entries</h3>
<ul>
<li><code>port 1194</code> specifies which port it will receive a connection request to make the OpenVPN connection.</li>
<li><code>proto tcp</code> Connection possible over TCP or UDP. Setting entry entered for selection.</li>
<li><code>dev tun</code> TAP or TUN interface can be used. These are virtual interfaces. TAP layer 2 establishes a connection, while TUN layer 3 establishes a connection.</li>
<li><code>user nobody</code> Enables connecting users to an unauthorized user on the server.</li>
<li><code>group $NOGROUP</code> It allows connecting users to be linked to an unauthorized group on the server as a group.</li>
<li><code>persist-key</code> An authorization setting for the creation and restart of the virtual interface</li>
<li><code>persist-tun</code> Also an authorization setting for the creation and restart of the virtual interface</li>
<li><code>keepalive 10 120</code> A setting for how many connections will be kept active and how long the active connection will be terminated if no communication is established.</li>
<li><code>ifconfig-pool-persist ipp.txt</code> A setting to keep the IP addresses given by OpenVPN to clients in the virtual network and give them the same addresses if they reconnect</li>
<li><code>push &quot;dhcp-option DNS 1.1.1.1&quot;</code> A DNS setting for the server to use when exiting the network</li>
<li><code>compress</code> The part where compression options are set</li>
<li><code>dh none</code> A setting for turning Diffie-Hellman on or off</li>
<li><code>ecdh-curve</code> If you are using Elliptic Curve Diffie-Hellman, the setting next to which the curve you need to select is adjusted</li>
<li><code>dh dh.pem</code> setting specifying the location of the PEM file you need to create beforehand if you are using Diffie-Hellman</li>
<li><code>tls-crypt tls-crypt.key</code> Required setting to encrypt TLS layer even before pre-shared master</li>
<li><code>tls-auth tls-auth.key 0</code> setting that allows parties to be authenticated beyond encryption at the pre-handshake stage of the TLS layer</li>
<li><code>crl-verify crl.pem</code> Setting to check whether the generated certificates are revoked or not via the CRL list</li>
<li><code>ca ca.crt</code> A setting that reports the location of the certificate of the certificate authority of the generated certificate</li>
<li><code>cert $SERVER_NAME.crt</code> A setting that tells the location of the server&rsquo;s certificate</li>
<li><code>key $SERVER_NAME.key</code> A setting indicating the location of the required asymmetric secret key next to the server&rsquo;s certificate</li>
<li><code>auth $HMAC_ALG</code> A setting describing which hash algorithm to use for the data channel and, if necessary, <code>tls-auth</code></li>
<li><code>cipher $CIPHER</code> A setting that tells which encryption algorithm to use for the data channel</li>
<li><code>ncp-ciphers $CIPHER</code> A setting declaring which encryption algorithms the server can use</li>
<li><code>tls-server</code> A setting that tells the server to use the TLS channel</li>
<li>A setting <code>tls-version-min 1.2</code> reports the lowest version to be used on the TLS channel</li>
<li><code>tls-cipher $CC_CIPHER</code> Encryption is also used at TLS layer, except for data channel, which is the setting declaring control channel encryption</li>
<li><code>client-config-dir /etc/openvpn/ccd</code> Setting that tells where client settings files are kept</li>
<li><code>status /var/log/openvpn/status.log</code> Setting that tells where status reports are written and where log files are kept</li>
<li><code>verb 3</code> This setting, which is the abbreviation of the word Verbose, is the setting of how detailed the status report is to be given.</li>
</ul>
<h3 id="the-client-side-settings-file-contains-the-following-entries">The client-side settings file contains the following entries</h3>
<ul>
<li><code>client</code> indicates that the device is in the client role</li>
<li><code>proto tcp-client</code> reports to use TCP as protocol</li>
<li><code>remote $IP $PORT</code> The part where the IP address and Port number of the server(s) to be connected are set</li>
<li><code>dev tun</code> sets which of the TUN/TAP interfaces to use</li>
<li><code>resolve-retry infinite</code> We tell you how long to wait if address resolution is delayed due to IP or DNS</li>
<li><code>nobind</code> setting to not connect to any address in the local</li>
<li><code>persist-key</code> Allows key files to be read without additional authorization on reboot</li>
<li><code>persist-tun</code> It also allows the TUN/TAP interface to be woken up without authorization on reboot</li>
<li><code>remote-cert-tls server</code> Verifies the certificate of the connected server at TLS layer</li>
<li><code>verify-x509-name $SERVER_NAME name</code> Command that tells the name in the certificate that the server will return to and what the name of the server should be</li>
<li><code>auth $HMAC_ALG</code> Command that tells which algorithm to use for validation</li>
<li><code>auth-nocache</code> Does not cache the password required for login</li>
<li><code>cipher $CIPHER</code> Command to select the algorithm to be used for encryption</li>
<li><code>tls-client</code> enables TLS during TLS communication and assumes the client role</li>
<li><code>tls-version-min 1.2</code> Sets the lowest TLS version</li>
<li><code>tls-cipher $CC_CIPHER</code> selects the encryption algorithm to use in the TLS control channel</li>
<li><code>ignore-unknown-option block-outside-dns</code> Prevents unknown DNS addresses from being used</li>
<li><code>setenv opt block-outside-dns</code> blocks DNS leaks for Windows 10</li>
<li><code>verb 3</code> Determines the degree of reporting</li>
<li><code>compress</code> Compression algorithm settings are reported here</li>
<li><code>&quot;&lt;ca&gt;/etc/openvpn/easy-rsa/pki/ca.crt&lt;/ca&gt;&quot;</code> Hard-Coded embedding of expected server certificate authority file</li>
<li><code>&quot;&lt;cert&gt;/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt&lt;/cert&gt;&quot;</code> Hard-Coded embedding of client certificate file</li>
<li><code>&quot;&lt;key&gt;/etc/openvpn/easy-rsa/pki/private/$CLIENT.key&lt;/key&gt;&quot;</code> Hard-Coded embedding of client asymmetric secret key</li>
<li><code>&quot;&lt;tls-crypt&gt;/etc/openvpn/tls-crypt.key&lt;/tls-crypt&gt;&quot;</code> Specifying the key file for TLS crypt</li>
<li><code>&quot;&lt;tls-auth&gt;/etc/openvpn/tls-auth.key&lt;/tls-auth&gt;&quot;</code> Specifying the key file for TLS auth</li>
<li><code>key-direction 1</code> assigns roles to client and server for TLS layer encryption (0 and 1)</li>
</ul>
<p>You can find detailed documentation of these settings and more on the <a href="https://openvpn.net/community-resources/reference-manual-for-openvpn-2-4/">OpenVPN</a> web page.</p>
<h2 id="what-happens-when-establishing-an-openvpn-connection">What happens when establishing an OpenVPN connection?</h2>
<p>Every time I connect with OpenVPN I feel like R2-D2 hijacking their Starfleet plans. People don&rsquo;t always want to find themselves in deep scrutiny and may ask someone to explain to them what and how. In my purpose of writing this article, I actually asked myself this question and I put a lot of effort to get the answer. I don&rsquo;t want you to work so hard, but I can&rsquo;t say that you should upload it immediately, don&rsquo;t think about the rest, it&rsquo;s my job. As I promised at the beginning, I will explain this process to you in depth and leave the decision to you. Here&rsquo;s how the process works in an OpenVPN connection, pros and cons (as I&rsquo;ve been able to figure it out so far). You first establish a TCP/UDP connection. You run a process like any application that uses TCP, and then you switch to the TLS layer. You are doing handshake and some authentication at TLS layer. This layer is also called the control channel. Then a certain communication is fixed and the data channel is passed. The process of encrypting and decrypting the data packets to be sent this time in the data or data channel begins. For this, devices are talking to each other and data is started to be sent under certain common conditions. In short, at the end of the process I have described in this way, the communication we started from 0 ends with the safe and desired data access to us, or requests are sent again, this time in a reverse way, over the connection that is kept open. Thus, a system like nested pipes emerges. If you need to write the only important thing required for the article here:</p>
<ul>
<li>It will be <code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512</code>.
<ul>
<li>Here the <code>TLS</code> input specifies that the control channel will be executed over the TLS layer. Other alternatives are <code>SSL</code> or <code>NULL</code>.</li>
<li>The <code>ECDHE</code> input specifies that the first pre-key will be generated using the Elliptic Diffie-Hellman algorithm. Other alternatives are to use <code>DHE</code>, <code>DH</code> or not.</li>
<li>The <code>ECDSA</code> data indicates that the Elliptic Digital Signature Certificate Algorithm will be used for mutual authentication and asymmetric key. Another available alternative is <code>RSA</code>. No need to count the others.</li>
<li>Specifies the encryption algorithm to be used on the <code>AES_256_GCM</code> data channel. Other alternatives are <code>AES-128-CBC</code>, <code>AES-128-GCM</code> and <code>AES-256-CBC</code></li>
<li><code>SHA384</code> specifies the hash algorithm to use. The other alternative is <code>SHA256</code>.</li>
<li><code>P512</code> allows the elliptic curve to be used to be selected as Prime-512. Other alternatives are <code>P-256</code> and <code>P-384</code>.</li>
</ul>
</li>
</ul>
<h3 id="the-process-of-establishing-the-tcp-connection">The process of establishing the TCP connection</h3>
<p>Now, if you have an approximate picture of the process in your mind, I start with the explanation of the TCP process. Let&rsquo;s say we have a client and a server in our case, and the connection is just these two. The client sends a SYN (m) packet to the server it wants to connect to. In response, the server sends a SYN (n) packet and an ACK (m+1) packet over the same port. The client that receives this also returns as ACK (n+1) in response, and a 3-way TCP handshake or 3-Way TCP handshake takes place. Thus, we have an open channel between client and server over the specified port.</p>
<p><picture>
  
  
  

  
    

    <source srcset="/images/openvpn-full/TCP-Handshake.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/TCP-Handshake.webp" type="image/webp">

  

  <img
    src="/images/openvpn-full/TCP-Handshake.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://blog.shiftasia.com/what-happen-when-access-website (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<hr>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/TCP-Handshake-2.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/TCP-Handshake-2.webp" type="image/webp">

  <img
    src="/images/openvpn-full/TCP-Handshake-2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<p>As can be seen in the photos, if the process runs smoothly, communication can be made in 3 steps. But if you ask why we are doing this in 3 steps, can&rsquo;t it be done in a shorter way? I would say (for now) no, no, for a full-duplex communication, both parties need to send SYN and ACK packets. Maybe I&rsquo;ll tell you different ways in the future, but for now this is how it is. Anyway, the TCP/UDP part is always short and simple.</p>
<h3 id="process-running-in-tls-layer">Process running in TLS layer</h3>
<p>After establishing a communication over TCP, the client is the person who takes the conversation to another level. Clients always request something from the server or request an answer. In general, servers are not seen to respond to a request that did not come to them. The process proceeds according to the principle of demand first, then supply. Yes, the parties are at the TLS layer now. The client first says hello to the server. Not a joke, it&rsquo;s real. The first packet sent by the client is called the <code>Client-Hello</code> packet. Next to this package (in order to speed up the process), the <code>Supported-Chipers</code> package that specifies the encryption algorithms it supports, a randomly generated number by the client, an <code>SNI</code> server name indicator if more than one service is running on the same IP address, and the session ID if necessary. . The server&rsquo;s response to this is, first of all, a polite hello. Because the first packet that the server sends in response is called the <code>Server-Hello</code> packet. Next to this package, the <code>Selected-Chiper</code> package, which specifies the server certificate, the encryption algorithms it supports, and the algorithm it chooses, sends a random number it generates, the Session ID if necessary, and an SNI-like ID if more than one client is connecting over the same IP. . The client first verifies with the server certificate whether it is really the person it is waiting for by starting the communication. In addition, in some cases, the server verifies with a certificate whether the client is one of the clients it expects. If this mutual-authentication process is positive, the next stage is passed. The key generation and exchange process is triggered. At this stage, the client again steps in and says that he wants to change the key with the algorithm they have determined during this communication, which is considered insecure. Parties begin to generate a prekey with Diffie-Hellman or ECDHE. For this, pre-secrets are shared by the client and server. The answers found by performing a number of mathematical operations are sent to the top and the same result is reached by performing mathematical operations again. The result is the first fore-key they&rsquo;ve securely created between them. After that, with the encryption algorithm they determined,
A data channel other than the control channel is created to communicate and the process continues from there.</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/TLS-Handshake.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/TLS-Handshake.webp" type="image/webp">

  <img
    src="/images/openvpn-full/TLS-Handshake.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<hr>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/TLS-Handshake-2.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/TLS-Handshake-2.webp" type="image/webp">

  <img
    src="/images/openvpn-full/TLS-Handshake-2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small></small></b></center></caption>
</picture></p>
<p>As can be seen in the photos, the process is almost the same as when connecting to a web page. Only certain stages are added, removed or changed according to needs. For example, in accordance with PFS, which stands for Advanced Privacy, the parties do not transmit the front-key with the server&rsquo;s asymmetric key. Because in this case, since the same key will be used for each session, the data will be stored and then the data will be readable retrospectively by waiting for a day when the key is revealed. That&rsquo;s why this change was made. Again, in accordance with the zero trust threat model, I want each layer and process to advance the process without trusting the other to do their job correctly. That&rsquo;s why we want the packets to be encrypted according to the <code>tls-auth</code> feature and to verify the integrity of the incoming and outgoing data, even at that first communication moment in the TLS layer. From the first moment you say hello, third parties will not be able to understand what you are talking about and at what stage you are. For this, the first communication is started with a predetermined key(s) and if necessary, these keys are renewed at regular intervals. Thus, even until the first pre-key is created in the TLS layer, confidentiality is not compromised and unauthorized parties are not created in vain.</p>
<h3 id="process-running-in-the-data-layer">Process running in the data layer</h3>
<p>If this whole process has been completed successfully and the data channel has been passed, you have now come to the best part of the job. Data will be encrypted with AES encryption method. During encryption, the tables will be shuffled according to the CBC-GCM counter mode according to your selection, and a 128 or 256-bit encryption key will be used in this process according to your selection. Of course, whatever you choose, the encryption block length will be 128 bits. Only the encryption key length changes. AES-256-GCM that I have chosen for this explanation is an AEAD encryption type. It summarizes the data it sends independently from other channels and processes at a certain stage and sends it together with the summary. Thus, authentication and encryption functions are fulfilled in AEAD, which stands for &lsquo;Authentication Encryption with associated data&rsquo;. There is a problem that requires a distinction to be made here. At what stage and in which order will we use the encryption and hashing algorithms?</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/EtM.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/EtM.webp" type="image/webp">

  <img
    src="/images/openvpn-full/EtM.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>Encrypt-then-MAC (EtM) https://en.wikipedia.org/wiki/Authenticated_encryption (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<hr>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/EaM.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/EaM.webp" type="image/webp">

  <img
    src="/images/openvpn-full/EaM.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>Encrypt-and-MAC (E-and-M) https://en.wikipedia.org/wiki/Authenticated_encryption (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<hr>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/MtE.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/MtE.webp" type="image/webp">

  <img
    src="/images/openvpn-full/MtE.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>MAC-then-Encrypt (MtE) https://en.wikipedia.org/wiki/Authenticated_encryption (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<ul>
<li>
<p>According to EtM, which is the first approach, the data is first encrypted, then encrypted with another key as a result of the digest, and the resulting result is sent together in blocks. If we look at real-world solutions that use it, the IPSec protocol will come to mind first. This is the only method that can achieve the highest security definition in AE, but this can only be achieved if the MAC algorithm used is free of corruption or has not yet been cracked. Various EtM cipher suites are also available for SSHv2. Note, however, that key separation is mandatory for data and digest (different keys must be used for encryption and key hashing), otherwise you may end up with a potentially insecure result depending on the particular encryption method and hash function used.</p>
</li>
<li>
<p>According to the second approach, E&amp;M, plain text data is encrypted and a summary of the encryption state of the plain text data is added next to it. Although only one key is used here, the fact that there are two different results (encryption result and digest result) for the same data clearly shows that the security is not good enough. As a real-world solution using this system, we can cite the first versions of SSH as an example. In order to improve this, methods such as encrypting the sent summary file with the same key were tried.</p>
</li>
<li>
<p>According to MtE, which is the third and last approach that I know of, a summary file is generated based on plain text. Then the plaintext and digest file together are encrypted with the key. The ciphertext and ciphertext file are sent together. If we look at real world solutions that use it, first and foremost are SSL/TLS implementations. We all know how reliable and sustainable SSL/TLS applications are in themselves. Beyond that, improvements such as <code>MAC-then-pad-then-encrypt</code> have been made over the years to increase security. According to this improvement, first the plain text is digested, then filled up to the block size, and then the encryption is done. This results in an even more reliable encryption result. But there are cases where the padding mechanism causes attacks like Padding Oracle if it makes certain mistakes.</p>
</li>
</ul>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/openvpn-full/TAP-TUN.avif" type="image/avif">

    
    

    <source srcset="/images/openvpn-full/TAP-TUN.webp" type="image/webp">

  <img
    src="/images/openvpn-full/TAP-TUN.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<p>After selecting the AEAD approach to be used, the path shown in the graphic above is followed according to the use of TAP or TUN. According to this path, the action done/desired to be done in the user area goes to TAP/TUN adapters at the kernel level. Because these adapters are at the kernel level, they operate very quickly. Then the virtual adapters do the necessary encryption with the relevant library, add the digest if necessary, and set the packet size. Then the server sends packets sequentially to the client&rsquo;s Ethernet interface over the Ethernet interface. The client that receives it reconfigures the packages, organizes them, combines them if necessary, and decrypts them with the necessary libraries. After decrypting it, it transmits the client to the end user via the virtual adapter. Thus, as a result of all these mathematical operations and efforts, after a few cycles, the user reached the desired content. It is quite long to explain, but very easy to use, dear readers. You just have to visit the relevant <a href="https://github.com/wiseweb-works/openvpn-most-secure-install/">script page</a> on my GitHub page. The related script makes all these adjustments interactively for you. All you have to do is sit back and enjoy.</p>
<h1 id="faq-and-end">FAQ and End</h1>
<p>Received me via <a href="mailto:wisewebworks@outlook.com">mail</a>, <a href="https://fosstodon.org/@wise">Fosstodon</a>, or <a href="https://github.com/wiseweb-works">GitHub</a> I will try to add questions here from time to time. Thus, historically, you will be able to reach the result directly without thinking about what kind of questions have arisen on which date or whether there is a solution. Apart from this, if there are questions that require extra explanation without changing the technical document, I think to include them in this section.</p>
]]></content:encoded></item><item><title>Generating ECC SSL Certificate on Linux Server</title><link>https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikasi/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikasi/</guid><description>Introduction and Summary Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate.</description><content:encoded><![CDATA[<h1 id="introduction-and-summary">Introduction and Summary</h1>
<p>Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate. Normally, if you are familiar with Let&rsquo;s Encrypt&rsquo;s ACME protocol (as of the date of writing), it is possible to generate a 1024-4098 (if you try too hard, maybe 8196) bit certificate with RSA asymmetric key structure and use it for 90 days relatively. However, generating such a large key, using it during TLS handshake after generating it, and being compatible with the devices used by the visitors causes problems in most scenarios. For example, when 4096 bits are used instead of 2048 bits, I am faced with 0.4-0.8 seconds longer handshake times in some of my attempts. As if it&rsquo;s okay for the handshake to take that long, it puts an extra load on the server. But when you generate a 384-bit ECC certificate instead of 4096-bit RSA, you get a much faster certificate and at the same time security equal to 7680-bit RSA (if it were that size).</p>
<p>Well, you explained it well, but where is the point of this work, I seem to hear you say. I will upset you, but there is no point in this business. The reason why it doesn&rsquo;t is hidden in the background math. Briefly, I will talk about the minor differences in the production and use of both certificates, explain how and why they cause big differences, and in the last part, I will talk about something that is not written in the title as a bonus. (For the bonus you&rsquo;ll have to read till the end :D)</p>
<p><picture>
  
  
  

  
    

    <source srcset="/images/ecc-ssl/key-size-comparison.avif" type="image/avif">

    
    

    <source srcset="/images/ecc-ssl/key-size-comparison.webp" type="image/webp">

  

  <img
    src="/images/ecc-ssl/key-size-comparison.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://www.globalsign.com/en/blog/elliptic-curve-cryptography (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<h2 id="production-process-of-ecc-certificate">Production process of ECC Certificate</h2>
<p>First of all (as always), we need to install the latest updates via the console with the package manager of the Linux version we are in.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>After the updates are installed, we start configuring the nginx service (which is the service that allows you to receive external HTTP/HTTPS connections) on your server (Ubuntu in my case). First of all, it should be noted that because of the confusion, apache, nginx and litespeed services are different services that do the same job. I chose NGINX because it is easier to manage and has more community support.</p>
<h2 id="lets-generate-the-private-key">Let&rsquo;s generate the private key</h2>
<p>First, we generate the private key with OpenSSL. The OpenSSL command we will use is &rsquo;ecparam&rsquo; (EC parameter manipulation) and to pass the configuration parameters to this command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</span></span></code></pre></div><ul>
<li>The <code>-genkey</code> option tells OpenSSL to generate an EC key.</li>
<li>The <code>-name</code> parameter tells OpenSSL which curve to use.</li>
<li>The <code>-out</code> parameter tells OpenSSL to write the output to a file.</li>
</ul>
<p>Note that OpenSSL writes its output in PEM format by default. We can check that OpenSSL is doing the right thing with the <code>ec</code> command that handles EC keys:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ec -in privkey.pem -noout -text
</span></span></code></pre></div><ul>
<li><code>-in</code> is input file</li>
<li>The <code>-noout</code> tells OpenSSL not to extract the key, meaninglessly printing privkey.pem to stdout.</li>
<li><code>-text</code> tells OpenSSL to write information about the key in plain text format</li>
</ul>
<p>If all goes well and the key is generated correctly, OpenSSL will show something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>read EC key
</span></span><span style="display:flex;"><span>Private-Key: (384 bit)
</span></span><span style="display:flex;"><span>priv:
</span></span><span style="display:flex;"><span>    [secret]
</span></span><span style="display:flex;"><span>pub:
</span></span><span style="display:flex;"><span>    [secret]
</span></span><span style="display:flex;"><span>ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>NIST CURVE: P-384
</span></span></code></pre></div><p>This verifies that the key was created with the P-384 curve. If you ask why we don&rsquo;t use P-512 instead of P-384, Let&rsquo;s Encrypt doesn&rsquo;t sign if the ecliptic curves are higher than 384 bits, and modern browsers like Google Chrome mark websites using 512-bit ecliptic curves as invalid. That&rsquo;s the short answer.</p>
<h2 id="lets-create-openssl-configuration-for-the-certificate">Let&rsquo;s create OpenSSL configuration for the certificate</h2>
<p>Now we need to create an OpenSSL configuration file containing the domain-specific parameters for which we want to get the TLS certificate. In this example, we will enter the following configuration in an <code>openssl.cnf</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>[ req ]
</span></span><span style="display:flex;"><span>prompt = no
</span></span><span style="display:flex;"><span>encrypt_key = no
</span></span><span style="display:flex;"><span>default_md = sha512
</span></span><span style="display:flex;"><span>distinguished_name = dname
</span></span><span style="display:flex;"><span>req_extensions = reqext
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ dname ]
</span></span><span style="display:flex;"><span>CN = example.com
</span></span><span style="display:flex;"><span>emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ reqext ]
</span></span><span style="display:flex;"><span>subjectAltName = DNS:example.com, DNS:www.example.com
</span></span></code></pre></div><p>Here is a brief description of these configuration options:</p>
<p>In the required <code>[ req ]</code> section:</p>
<ul>
<li><code>prompt=no</code> tells OpenSSL to get as much configuration as possible from the config file</li>
<li><code>encrypt_key = no</code> tells OpenSSL not to encrypt the private key with a password. (Encrypted private keys are supported by Nginx, but I don&rsquo;t use them.)</li>
<li><code>default_md=sha512</code> tells OpenSSL to sign the CSR with SHA512. (As far as I know, Let&rsquo;s Encrypt only supports RSA with SHA256 for its signatures, but that doesn&rsquo;t mean we can&rsquo;t use stronger encryption in CSR.)</li>
<li><code>distinguished_name=dname</code> tells OpenSSL to look for a <code>[ dname ]</code> section for Distinguished Name configuration options.</li>
<li><code>req_extensions=reqext</code> tells OpenSSL to look for a <code>[ reqext ]</code> section in the configuration options for Subject Alternative Names (SANs) extensions that it wants to configure.</li>
</ul>
<p>In the Distinguished Name <code>[ dname ]</code> section:</p>
<ul>
<li><code>CN = example.com</code> indicates the Common Name of the certificate.</li>
<li>Your <code>emailAddress = admin@example.com</code> email address must be prominent.
Desired Extensions In the <code>[ reqext ]</code> section, subjectAltName provides the list of SANs for the certificate. (Chrome as of v58 requires that the Common Name be included in the list of SANs).</li>
</ul>
<p>Let&rsquo;s Encrypt v2 supports wildcard domains, so in this example you can use a single-level wildcard for non-apex hosts (*.example.com).</p>
<h2 id="lets-create-certificate-signing-request">Let&rsquo;s Create Certificate Signing Request</h2>
<p>The final step on the client side is to generate the Certificate Signing Request using OpenSSL, then we will forward it to Let&rsquo;s Encrypt for signing and retrieve the signed certificate.</p>
<p>The OpenSSL command required to generate a CSR is <code>req</code> .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</span></span></code></pre></div><ul>
<li><code>-new</code> tells OpenSSL that we have created a CSR (and we do not examine an existing CSR)</li>
<li><code>-config</code> openssl.cnf specifies the config file we created above</li>
<li><code>-key privkey.pem</code> indicates the private key we created above</li>
<li><code>-out csr.pem</code> tells OpenSSL to write the CSR to an output file (instead of stdout)</li>
</ul>
<p>We can verify that we have generated the CSR correctly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -in csr.pem -noout -text -verify
</span></span></code></pre></div><ul>
<li><code>-verify</code> asks OpenSSL to verify the signature in the CSR</li>
</ul>
<p>This should produce the following expected results in the output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>verify OK
</span></span><span style="display:flex;"><span>Certificate Request:
</span></span><span style="display:flex;"><span>    Data:
</span></span><span style="display:flex;"><span>        Version: 1 (0x0)
</span></span><span style="display:flex;"><span>        Subject: CN = example.com, emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>        Subject Public Key Info:
</span></span><span style="display:flex;"><span>            Public Key Algorithm: id-ecPublicKey
</span></span><span style="display:flex;"><span>                Public-Key: (384 bit)
</span></span><span style="display:flex;"><span>                pub:
</span></span><span style="display:flex;"><span>                    [gizli]
</span></span><span style="display:flex;"><span>                ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>                NIST CURVE: P-384
</span></span><span style="display:flex;"><span>        Attributes:
</span></span><span style="display:flex;"><span>        Requested Extensions:
</span></span><span style="display:flex;"><span>            X509v3 Subject Alternative Name:
</span></span><span style="display:flex;"><span>                DNS:example.com, DNS:www.example.com
</span></span><span style="display:flex;"><span>    Signature Algorithm: ecdsa-with-SHA512
</span></span><span style="display:flex;"><span>         [gizli]
</span></span></code></pre></div><h2 id="ask-lets-encrypt-to-sign-our-certificate">Ask Let&rsquo;s Encrypt to sign our certificate</h2>
<p>The final step is to send the CSR with an ACME client to Let&rsquo;s Encrypt for signing, <code>certbot</code> is the most common client for this job.</p>
<p>Command line options passed to the <code>Certbot</code> client depend on our setup, the person our domain is registered to, etc. varies depending. Usually we need to use the <code>certonly</code> command and if you used asterisks (*) you need to use one of the certbot DNS plugins.</p>
<p>For example, if the domain <code>example.com</code> is registered with Cloudflare, we can use the corresponding plugin to handle the verification, which is extremely convenient and does not require manual intervention in the process. (Configuring the Cloudflare plugin with secret token information is beyond the scope of this article.)</p>
<p>It&rsquo;s usually recommended to make sure everything is ok with <code>--dry-run</code> first to make sure everything is ok.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --dry-run --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><ul>
<li>Quotation marks are required around characters to avoid erroneous manipulations and are generally a good idea.</li>
<li><code>--csr csr.pem</code> tells certbot that we already have a certificate and we need Let&rsquo;s Encrypt to sign it for us.</li>
</ul>
<p>The Certbot client will check on the command line that the requested list of domains matches the domains listed in the certificate and will use the Certbot NGINX plugin to verify that the domain is ours and let us know if there are any issues.</p>
<p>If nothing is wrong, it will tell you:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>IMPORTANT NOTES:
</span></span><span style="display:flex;"><span> - The dry run was successful.
</span></span></code></pre></div><p>The actual command is just as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><p>After a (long) delay, the client will output:</p>
<ol>
<li>Signed certificate: <code>0000_cert.pem</code></li>
<li>Root and intermediate certificates: <code>0000_chain.pem</code></li>
<li>Certificate + intermediates: <code>0001_chain.pem</code>
At this point, the CSR <code>csr.pem</code> can be deleted.</li>
</ol>
<p>If we are curious, we can inspect the certificates returned by the client with OpenSSL using the <code>x509</code> command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl x509 -in 0001_chain.pem -noout -text
</span></span></code></pre></div><p>Unfortunately, we will discover that as described above, Let&rsquo;s Encrypt signs our certificate with a SHA256 signature. (As well as being more secure, SHA512 outperforms SHA256 on modern 64-bit CPUs.) But our public key should still use ECDSA.</p>
<p>These files are not ordinary, so we must move and edit them in a more informative way.</p>
<p>On Debian Linux I like to create subdirectories for my domains by keeping my private key in <code>/home/USER_NAME/SSL/private/example.com/privkey.pem</code> and certificates:</p>
<ul>
<li><code>/home/USER_NAME/SSL/certs/example.com/cert.pem</code></li>
<li><code>/home/USER_NAME/SSL/certs/example.com/chain.pem</code></li>
<li><code>/home/USER_NAME/SSL/certs/example.com/fullchain.pem</code></li>
</ul>
<h1 id="end">END</h1>
<p>If we&rsquo;ve done everything right, inspecting the certificate with a web browser like Chrome will confirm that it&rsquo;s an EC certificate:</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/ecc-ssl/ecc-sll-key-chrome.avif" type="image/avif">

    
    

    <source srcset="/images/ecc-ssl/ecc-sll-key-chrome.webp" type="image/webp">

  <img
    src="/images/ecc-ssl/ecc-sll-key-chrome.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<p>Mozilla Observatory will also give us an A+ rating!</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/ecc-ssl/ecc-ssl-key-mozilla.avif" type="image/avif">

    
    

    <source srcset="/images/ecc-ssl/ecc-ssl-key-mozilla.webp" type="image/webp">

  <img
    src="/images/ecc-ssl/ecc-ssl-key-mozilla.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Date: 08.04.2023)</small></b></center></caption>
</picture></p>
<p>In addition, we can see that a 384-bit ECC certificate was used as a result of the SSL Labs report.</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="/images/ecc-ssl/ecc-ssl-key-ssllabs.avif" type="image/avif">

    
    

    <source srcset="/images/ecc-ssl/ecc-ssl-key-ssllabs.webp" type="image/webp">

  <img
    src="/images/ecc-ssl/ecc-ssl-key-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>SSL Labs Test Result</small></b></center></caption>
</picture></p>
<p>NOTE: This article has benefited from the article of <a href="https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc">Benjamin Black</a> on the same subject.</p>
]]></content:encoded></item><item><title>Increasing SSL security on Linux Servers</title><link>https://wiseweb-works.github.io/blog/en/post/ssl-konfigurasyonu/</link><pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/en/post/ssl-konfigurasyonu/</guid><description>Increasing SSL security on Linux Servers Today, if you are serving a website and/or App on your current server, I will talk about the SSL connection you need and the openssl library in connection with it. SSL (Secure Socket Layer) and TLS (Transport Layer Security) are a form of connection that allows people who want to connect to your server to communicate securely with your site. There are versions ranging from SSL v1-v3 in the past, and while sites generally use these SSL versions, SSL has now been abandoned by the sites and has been replaced by the more secure TLS.</description><content:encoded><![CDATA[<h1 id="increasing-ssl-security-on-linux-servers">Increasing SSL security on Linux Servers</h1>
<p>Today, if you are serving a website and/or App on your current server, I will talk about the SSL connection you need and the openssl library in connection with it. SSL (Secure Socket Layer) and TLS (Transport Layer Security) are a form of connection that allows people who want to connect to your server to communicate securely with your site. There are versions ranging from SSL v1-v3 in the past, and while sites generally use these SSL versions, SSL has now been abandoned by the sites and has been replaced by the more secure TLS. However, we will still need to use the word &ldquo;ssl&rdquo; in the narrative part and while editing the config files. To tell you this with a little humor, have you ever thought why when you want to download the 64 bit version of an application, why it is called &ldquo;amd_64&rdquo;? Because AMD was the first to switch to 64 bit, this naming remained as amd_64 as a sign of respect and/or habit. Likewise, although we are currently using TLS, the naming and configuration parameters remain &ldquo;SSL&rdquo;.</p>
<p>As in our previous article, I will explain the process again under three different headings as simple, recommended and advanced. Title contents are gradually considered according to personal requirements. Although the titles are linked to each other, leaving them at a desired stage will not pose a problem.</p>
<h2 id="simple-configuration">Simple configuration</h2>
<p>First of all, we need to install the updates via the console with the package manager of the Linux version we are in.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>After the updates are installed, we start configuring the nginx/apache service (which is the service that allows you to receive external web connections) on your server (Ubuntu in my case). The file where the Nginx service settings are kept is generally located at &ldquo;/etc/nginx/nginx.conf&rdquo;. We need to open it with any of the text editors we use, but with a user with sudo (ie administrator) privileges.</p>
<p>If we continue on Ubuntu (Single IP for Single Server Configuration)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/nginx/nginx.config <span style="color:#75715e"># Command to open the settings file</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Titles to be added (changed if any)
</span></span><span style="display:flex;"><span>listen 443 ssl http2; &gt;&gt; It serves to meet the requests coming to port 443 via ipv4 with http2 protocol and establish ssl connection.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listen [::]:443 ssl http2; &gt;&gt; It serves to meet the requests coming to port 443 over ipv6 with http2 protocol and establish ssl connection. (If you don&#39;t have ipv6 support or you don&#39;t want to support it natively, you can remove it)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>server_name YOUR SERVER_NAME; &gt;&gt; If you do not want to set your server name as default, you can specify a Server Name Indicator. This only serves to meet the requests coming to your server name instead of meeting all incoming requests.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_certificate /etc/letsencrypt/live/YOURSERVER_NAME/fullchain.pem; &gt;&gt; If you are using Let&#39;s Encrypt for free ssl, this is the default certificate location. Otherwise, replace it with your own certificate file.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_certificate_key /etc/letsencrypt/live/YOURSERVER_NAME/privkey.pem; &gt;&gt; If you are using Let&#39;s Encrypt for free ssl, this is the default private key location. Otherwise replace it with your own private key file location.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_protocols TLSv1.3 TLSv1.2; &gt;&gt; Required command to accept only the latest and most reliable TLS protocols.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_prefer_server_ciphers on; &gt;&gt; During the conversation between the server and the client, I guess that they were talking about &#34;ok, let&#39;s see what we have&#34;. In short, if it works for you, if it doesn&#39;t work for you, I don&#39;t talk.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_ecdh_curve secp521r1:secp384r1; &gt;&gt;It is the command that tells us which curves we prefer when we need to use ecliptic curves.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_ciphers DH-RSA-AES256-SHA:DH-RSA-AES256-SHA256:DHE-RSA-AES256-GCM-SHA384:DH-RSA-AES256-GCM-SHA384:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_PODSADHESA:25_SHA256 -ECDSA-AES256-SHA:ECDH-RSA-AES256-SHA:AECDH-AES256-SHA:ECDHE-ECDSA-AES256-SHA384:ECDH-ECDSA-AES256-SHA384:ECDH-RSA-AES256-SHA384:ECDHE-ECDSA-AES256 -GCM-SHA384:ECDH-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDH-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-CCM:DHE-RSA-AES256-CCM8 :ECDHE-ECDSA-AES256-CCM:ECDHE-ECDSA-AES256-CCM8:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305; &gt;&gt; The code that tells the server to use only those SSL algorithms that I find the most reliable.
</span></span></code></pre></div><p>All ciphers for those who want to research one by one: &ldquo;<a href="https://testssl.sh/openssl-iana.mapping.html%22">https://testssl.sh/openssl-iana.mapping.html&quot;</a></p>
<p>If you want to check after making the settings: You can use the command &ldquo;sudo nginx -t&rdquo;. If you do not see an error message, you can apply the settings and restart the service with the command &ldquo;sudo systemctl restart nginx&rdquo; or &ldquo;sudo service nginx restart&rdquo;</p>
<h2 id="recommended-settings">Recommended settings</h2>
<p>In addition to the previous settings, we will make some performance improvements, as well as some additional configurations that will enable your site to rank higher in SSL test sites. After that, we will make some improvements to ensure that some headers and resources of your site are not exploited by third party sites, which will be beneficial for your site&rsquo;s user access.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Titles to be added (changed if any)
</span></span><span style="display:flex;"><span>ssl_session_cache shared:TLS:2m; &gt;&gt; Code specifying how TLS connections will be distributed among workers (nginx workers) and for how long the connections will be shared
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_buffer_size 4k; &gt;&gt;The code that indicates how many containers the packets will be divided into when responding to SSL requests and sending packets after handshake. A lower value means more packets are sent but less overhead.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_stapling on; &gt;&gt; Activates the OCSP stapling feature
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_stapling_verify on; Turns on the ability to verify OCSP stapling, including on parent and root servers.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>resolver 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001; &gt;&gt; Enables OCSP stapling verification with Cloudlfare. If you do not use IPV6 or do not want to support it natively, you can delete the IPv6 addresses.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Content-Type-Options &#34;nosniff&#34; always; &gt;&gt; It is the header value that prevents browsers from sniffing to understand MIME contents.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Xss-Protection &#34;1; mode=block&#34; always; &gt;&gt; It is a title that prevents the vulnerability to some extent by allowing users to see a white screen in a possible XSS vulnerability.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Frame-Options &#34;SAMEORIGIN&#34; always; &gt;&gt;It prevents a page of your server from being shown on another page and/or being published one after the other with an i-frame etc. code in any way. Only you can publish a window from your own site within your own site.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Referrer-Policy &#34;no-referrer-when-downgrade&#34; always; &gt;&gt; When you redirect or link to a site with lower security measures, it does not automatically add a referrer header and it is not clear that traffic is coming from your site.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Content-Security-Policy &#34;default-src &#39;self&#39; https: data: &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;&#34; always; &gt;&gt; The title that regulates the conditions under which requests that you and other users can call from outside can be called. By default, I trust some sources that come over https.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Permissions-Policy &#34;camera=(), fullscreen=(self), geolocation=(), microphone=(), payment=()&#34; always; &gt;&gt; It prevents the collection of information on your site with various types of poisoning (cache-poisoning or js-poisoning) by specifying which permissions you will want to the browser or which you will not need at all.
</span></span></code></pre></div><p>If you want to check after making the settings: You can use the command &ldquo;sudo nginx -t&rdquo;. If you do not see an error message, you can apply the settings and restart the service with the command &ldquo;sudo systemctl restart nginx&rdquo; or &ldquo;sudo service nginx restart&rdquo;.</p>
<h2 id="advanced-settings">Advanced Settings</h2>
<p>First, we&rsquo;ll add a header to your site to indicate that it should only be connected via ssl. In this way, those who have entered your site before and those who already have this title in their browser will not be able to access your site non-SSL even if they want it. Then we will staple the SSL certificates that should be used in HTTP sessions, and we will specify in advance which certificates will need to be connected next to the previous method. In this way, even if you are an authorized top certificate manager or root manager, they will not be able to connect to your site with the certificate signed on your behalf. E-Tugra Root Certificate provider residing in Turkey at the time signed a certificate to *.google.com. If you do a little research, you&rsquo;ll find out when it happened and why (how bad it could cause). Now let&rsquo;s start the final configuration part.</p>
<p>First, make sure that your site can be accessed over SSL without causing any problems. Then add one of the following headers to the nginx config file as per your request. But beware, only one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=2592000;&#34; always; &gt;&gt; Header stating that your site can only be accessed over HTTPS for 30 days. (Not including subdomains)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=2592000; includeSubDomains;&#34; always; &gt;&gt; Header stating that your site can only be accessed over HTTPS for 30 days, including subdomains.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains;&#34; always; &gt;&gt; Header stating that your site can only be accessed over HTTPS for 1 year, including subdomains.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains; preload&#34; always; &gt;&gt; The header that instructs that your site can only be accessed over HTTPS for 1 year, including subdomains, and that this header is cached by browsers. In addition, new browsers will be aware of this title even if they have never visited your site before.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=0; includeSubDomains&#34;; &gt;&gt; Title for removing HSTS feature and preload list membership completely.
</span></span></code></pre></div><p>After adding the header mentioned above, now it&rsquo;s time to staple the hash of the ssl certificate you used to the HTTP session. At this stage we need to extract a hash of your current certificate, hash the top signing authority&rsquo;s certificate, and continue this hashing process until we&rsquo;ve completed the entire chain, including the top root certificate authority. For this reason, we run the following commands respectively with a root user or a user with sudo authority. (The lecture was made specifically for Let&rsquo;s Encrypt.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1<span style="color:#f92672">]</span> cat /etc/letsencrypt/live/YOUR SERVER_NAME/cert.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; This command will extract the hash of your site<span style="color:#e6db74">&#39;s certificate. Copy the result value somewhere.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">2] curl -s https://letsencrypt.org/certs/lets-encrypt-x4-cross-signed.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; This command will extract one of the multi-signed certificates of letsencrypt.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">3] curl -s https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; This command will extract one of the multi-signed certificates of letsencrypt.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">4] curl -s https://letsencrypt.org/certs/isrgrootx1.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; This command will extract the root (top) certificate of letsencrypt.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">The following value is added to the Nginx config file
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">5] add_header Public-Key-Pins &#39;</span>pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;FIRST_RESULT&#34;</span>; pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;SECOND_RESULT&#34;</span>; pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;TIP_END&#34;</span>; pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;FINISH_RESULT&#34;</span>; max-age<span style="color:#f92672">=</span>2592000; includeSubDomains<span style="color:#e6db74">&#39; always; &gt;&gt; Allows you to connect to your site for 30 days only with the specified certificate. You can optionally increase the max-age value. Before your certificate validity period is less than 30 days, you must disable the header or obtain a new certificate and add it as the fifth value.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">As a bonus, I&#39;</span>d like to show you another command that will take a long time <span style="color:#66d9ef">for</span> your server to execute, but is very useful.
</span></span><span style="display:flex;"><span>6<span style="color:#f92672">]</span> openssl dhparam -out /etc/nginx/dhparams.pem <span style="color:#ae81ff">4096</span> &gt;&gt; This command can take between <span style="color:#ae81ff">15</span> minutes and <span style="color:#ae81ff">1</span> hour to execute.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>After the process is finished, you need to add the following command to the nginx config file.
</span></span><span style="display:flex;"><span>ssl_dhparam /etc/nginx/dhparam.pem; &gt;&gt; The command to change the values to be used during the Diffie-Hellman key exchange algorithm with the secret values we just created, apart from the default values.
</span></span></code></pre></div><p>After making the settings, apply the settings with the command &ldquo;sudo nginx -t&rdquo; and then, if you do not see an error message, &ldquo;sudo service nginx restart&rdquo; and restart the service. Now the connection will be provided with the configuration and conditions you have specified. If you want to see the before/after scoring difference, you can look at the images below or test your own site at &ldquo;<a href="https://www.ssllabs.com/ssltest/index.html%22">https://www.ssllabs.com/ssltest/index.html&quot;</a>.</p>
<p>BEFORE
<picture>
  
  
  

  

  
    

    <source srcset="/images/ssl-anlatim/ssl-ilk-hali-ssllabs.avif" type="image/avif">

    
    

    <source srcset="/images/ssl-anlatim/ssl-ilk-hali-ssllabs.webp" type="image/webp">

  <img
    src="/images/ssl-anlatim/ssl-ilk-hali-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>SSL Labs test result</small></b></center></caption>
</picture></p>
<p>AFTER
<picture>
  
  
  

  

  
    

    <source srcset="/images/ssl-anlatim/ssl-son-hali-ssllabs.avif" type="image/avif">

    
    

    <source srcset="/images/ssl-anlatim/ssl-son-hali-ssllabs.webp" type="image/webp">

  <img
    src="/images/ssl-anlatim/ssl-son-hali-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>SSL Labs test result</small></b></center></caption>
</picture></p>
<p>If you ask why Cipher Strength is not 100%, it is not possible to make 100% at the moment because of the &ldquo;TLS_AES_128_GCM_SHA256 (0x1301)&rdquo; that comes automatically with TLS 1.3 and is added even if we don&rsquo;t want it. If you think that I will turn off TLS 1.3, then it will not come, then unfortunately your points are gone from somewhere else.</p>
<h1 id="end">End</h1>
<p>This article was previously published at <a href="https://teknolojirehberleri.xyz">https://teknolojirehberleri.xyz</a>. In order to create a personal portfolio, I felt the need to republish it on my personal site.</p>
]]></content:encoded></item><item><title>Increasing SSH security on Linux Servers</title><link>https://wiseweb-works.github.io/blog/en/post/ssh-guvenligi/</link><pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/en/post/ssh-guvenligi/</guid><description>Increasing SSH security on Linux Servers Today, I will talk about how we can keep the SSH service, which allows us to connect securely when you rent a server, more secure and away from malicious requests from outside. Foremost, I will describe the process under three different headings: simple, recommended and advanced. Title contents are gradually considered according to personal requirements. Although the titles are linked to each other, leaving them at a desired stage will not pose a problem.</description><content:encoded><![CDATA[<h1 id="increasing-ssh-security-on-linux-servers">Increasing SSH security on Linux Servers</h1>
<p>Today, I will talk about how we can keep the SSH service, which allows us to connect securely when you rent a server, more secure and away from malicious requests from outside. Foremost, I will describe the process under three different headings: simple, recommended and advanced. Title contents are gradually considered according to personal requirements. Although the titles are linked to each other, leaving them at a desired stage will not pose a problem.</p>
<h2 id="simple-safety-precautions">Simple Safety Precautions</h2>
<p>First, we need to install the updates via the console with the package manager of the Linux version we are in.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>After the updates are installed, we start configuring the SSHD service (which is the service that allows you to receive ssh connections from outside) on your server (Ubuntu in my case). Foremost, due to the confusion, it should be noted that the ssh service and the SSHD service are different services. While the SSH service is the service that connects the server to other computers or servers, the SSHD service is the service that allows other computers to connect to your server, that is, incoming connections.</p>
<p>The file that keeps the settings of the SSHD service is generally located at /etc/ssh/sshd_config. We need to open it with any of the text editors we use, but with a user with sudo (ie administrator) privileges.</p>
<p>If we continue on, Ubuntu</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config <span style="color:#75715e"># Command to open the settings file</span>
</span></span></code></pre></div><p>Titles we will find and replace</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#ClientAliveInterval 0 &gt;&gt; We remove the hashtag at the beginning and change the value from &#34;0&#34; to 300. This command regulates the automatic closing of the connection after how many seconds when the connection is not used (it stays in the idle position).
</span></span><span style="display:flex;"><span>#PermitEmptyPasswords no &gt;&gt;We remove the hashtag at the beginning and do not change the &#34;no&#34; value. This command prevents blank or unencrypted users from connecting. So it doesn&#39;t allow empty passwords.
</span></span><span style="display:flex;"><span>X11Forwarding yes &gt;&gt; If there is a hashtag at the beginning, we remove it, otherwise we change the &#34;yes&#34; value to no. Although this command provides ease of running applications with GUI interface on the server, we close it because it is possible to abuse it.
</span></span><span style="display:flex;"><span>#MaxAuthTries 6 &gt;&gt; We remove the hashtag at the beginning and change the value from &#34;6&#34; to 3. This command regulates how many times they can try your password. The number 6 is an unnecessarily high value and the general acceptance is 3 or 4.
</span></span><span style="display:flex;"><span>#Protocol 2 &gt;&gt; If there is a hashtag at the beginning, we remove it, if there is no such record, we add the value in the form of &#34;Protocol 2&#34; to the first space we find. This command ensures that connections are made only with the latest SSH protocol, protecting you from vulnerabilities of the old protocol.
</span></span></code></pre></div><p>If you want to check after making the settings: You can use the command &ldquo;sudo sshd -t&rdquo;. If you do not see an error message, you can apply the settings and restart the service with the command &ldquo;sudo systemctl restart sshd&rdquo; or &ldquo;sudo service sshd restart&rdquo;</p>
<h2 id="recommended-settings">Recommended settings</h2>
<p>In addition to the previous settings, we will make additional settings such as user-based login, login using only secure key and restrict login with Root user. First you need to generate a secret key for your user on your local computer. For this, if you are using a linux-based operating system</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>After typing ssh-keygen -t rsa -b 4096 #, enter the password you want in response to the questions below
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter passphrase (empty for no passphrase): [Press enter key]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter same passphrase again: [Press enter key]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>or
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssh-keygen -t ecdsa -b 521 # Generates more secure and faster ecliptic key. Enter the password you want in response to the questions below
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter passphrase (empty for no passphrase): [Press enter key]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter same passphrase again: [Press enter key]
</span></span></code></pre></div><p>If you answered other questions by pressing Enter and did not type a specific location for the key, your key pair (.pub= public key) / private key without extension) is saved in the /home/USER_NAME/.ssh folder. You can use the code below to introduce the key you generated to your server.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ssh-copy-id -i ~/.ssh/KEY_NAME.pub After typing USER_NAME@SERVER_IP_ADRESS # on the SERVER, it will ask for your user&#39;s password and if you enter it correctly, you will see a confirmation message.
</span></span></code></pre></div><p>After generating your own key, to access the server only with the key;
Titles we will find and replace</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#PasswordAuthentication no &gt;&gt; We remove the hashtag at the beginning and leave the &#34;no&#34; value as no. This command prevents connecting to the server with a password. Users can only connect with ssh_keys.
</span></span><span style="display:flex;"><span>PubkeyAuthentication yes &gt;&gt;If there is, we remove the hash mark at the beginning and set the value as yes. This command is the command that allows you to log in with the secret key you just created.
</span></span><span style="display:flex;"><span>#PermitRootLogin no &gt;&gt; We remove the hashtag at the beginning and leave the &#34;no&#34; value as no. This command prevents the ROOT user, who is the most authorized user, from accessing the server. However, you can access it with another user and then switch to the ROOT user.
</span></span><span style="display:flex;"><span>AllowUsers YOUR USERNAME &gt;&gt;If it doesn&#39;t exist, we add such a record. It prevents other users from connecting to the server and/or attempting a username.
</span></span><span style="display:flex;"><span>LoginGraceTime 20 &gt;&gt; If not, we add such a record and set the value to 20. Determines the time required to log in, in seconds. We prevent them from keeping the server busy with a long login request.
</span></span><span style="display:flex;"><span>ChallengeResponseAuthentication no &gt;&gt;If there is, we remove the hash mark at the beginning and set the value as no. This command disables other login methods.
</span></span><span style="display:flex;"><span>KerberosAuthentication no &gt;&gt;If there is, we remove the hash mark at the beginning and set the value as no. This command disables other login methods.
</span></span><span style="display:flex;"><span>GSSAPIAuthentication no &gt;&gt;If there is, we remove the hash mark at the beginning and set the value as no. This command disables other login methods.
</span></span></code></pre></div><p>If you want to check after making the settings: You can use the command &ldquo;sudo sshd -t&rdquo;. If you do not see an error message, you can apply the settings and restart the service with the command &ldquo;sudo systemctl restart sshd&rdquo; or &ldquo;sudo service sshd restart&rdquo;</p>
<h2 id="advanced-settings">Advanced Settings</h2>
<p>First of all, we will change the standard SSH connection port, 22, and then make the encryption tools used during SSH connection even stronger. Then we will determine how the logs (registry records) of the server SSH service are kept.</p>
<p>Titles we will find and replace</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#Port 22 &gt;&gt; We find this and remove the hash mark at the beginning and write there a port number that is not used by any other service and is open. For example, it could be 2992.
</span></span><span style="display:flex;"><span>LogLevel INFO &gt;&gt;We find this setting and change it, if not, we add it. It helps us to set the recording level.
</span></span><span style="display:flex;"><span>AllowAgentForwarding no &gt;&gt;We find this setting and change it, if not, we add it. Disables alternative routing methods.
</span></span><span style="display:flex;"><span>AllowTcpForwarding no &gt;&gt;We find this setting and change it, if not, we add it. Disables alternative routing methods.
</span></span><span style="display:flex;"><span>PrintMotd no &gt;&gt;We find this setting and change it, if not, we add it. To prevent them from knowing about the server before the connection is established.
</span></span><span style="display:flex;"><span>PermitUserEnvironment no &gt;&gt;We find this setting and change it, if not, we add it.
</span></span><span style="display:flex;"><span>PermitTunnel no &gt;&gt;We find this setting and change it, if not, we add it.
</span></span></code></pre></div><p>We go further and determine which of the encryption algorithms, authentication algorithms, key exchange algorithms and other algorithms used during the SSH connection should be the default.</p>
<p>We run the following commands respectively with a root user or a user with sudo authority.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1<span style="color:#f92672">]</span> rm /etc/ssh/ssh_host_*
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">]</span> ssh-keygen -t rsa -b <span style="color:#ae81ff">4096</span> -f /etc/ssh/ssh_host_rsa_key -N <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">]</span> ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">]</span> awk <span style="color:#e6db74">&#39;$5 &gt;= 3072&#39;</span> /etc/ssh/moduli &gt; /etc/ssh/moduli.tmp
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">]</span> mv /etc/ssh/moduli.tmp /etc/ssh/moduli
</span></span><span style="display:flex;"><span>6<span style="color:#f92672">]</span> sed -i <span style="color:#e6db74">&#39;s/^\#HostKey \/etc\/ssh\/ssh_host_\(rsa\|ed25519\)_key$/HostKey \/etc\/ssh\/ssh_host_\1_key/g&#39;</span> /etc/ssh/sshd_config
</span></span><span style="display:flex;"><span>7<span style="color:#f92672">]</span> echo -e <span style="color:#e6db74">&#34;KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256\nCiphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\nMACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com\nHostKeyAlgorithms ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,sk-ssh-ed25519@openssh.com,sk-ssh-ed25519-cert-v01@openssh.com,rsa-sha2-256,rsa-sha2-512,rsa-sha2-256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com&#34;</span> &gt; /etc/ssh/sshd_config.d/ssh-hardening.conf
</span></span></code></pre></div><p>After making the settings, apply the settings with the command &ldquo;sudo sshd -t&rdquo; and then, if you do not see an error message, &ldquo;sudo service sshd restart&rdquo; and restart the service. Now you will be able to connect to the server via the port you have just defined and only with your private key. To connect;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>You can use the command ssh -i ~/.ssh/KEY_NAME USER_NAME@SERVER_IP_ADRESS -p PORT_NUMBER #. You can continue by saying Enter to the incoming notifications.
</span></span></code></pre></div><h1 id="end">End</h1>
<p>This article was previously published at <a href="https://teknolojirehberleri.xyz">https://teknolojirehberleri.xyz</a>. In order to create a personal portfolio, I felt the need to republish it on my personal site.</p>
]]></content:encoded></item></channel></rss>