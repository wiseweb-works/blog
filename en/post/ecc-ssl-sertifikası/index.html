<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generating ECC SSL Certificate on Linux Server | Wise</title><meta name=keywords content="linux,ssl,security,ecc,elliptic curve"><meta name=description content="Introduction and Summary Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.46433908013b5fd3e5864f7639a00686dd974af54a97e7597b1d1d09072572ce.css integrity="sha256-RkM5CAE7X9Plhk92OaAGht2XSvVKl+dZex0dCQclcs4=" rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb-works.github.io/blog/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb-works.github.io/blog/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb-works.github.io/blog/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb-works.github.io/blog/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb-works.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=en href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=de href=https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikas%C4%B1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Generating ECC SSL Certificate on Linux Server"><meta property="og:description" content="Introduction and Summary Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-20T00:00:00+00:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generating ECC SSL Certificate on Linux Server"><meta name=twitter:description content="Introduction and Summary Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wiseweb-works.github.io/blog/en/post/"},{"@type":"ListItem","position":2,"name":"Generating ECC SSL Certificate on Linux Server","item":"https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generating ECC SSL Certificate on Linux Server","name":"Generating ECC SSL Certificate on Linux Server","description":"Introduction and Summary Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate.","keywords":["linux","ssl","security","ecc","elliptic curve"],"articleBody":"Introduction and Summary Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate. Normally, if you are familiar with Let’s Encrypt’s ACME protocol (as of the date of writing), it is possible to generate a 1024-4098 (if you try too hard, maybe 8196) bit certificate with RSA asymmetric key structure and use it for 90 days relatively. However, generating such a large key, using it during TLS handshake after generating it, and being compatible with the devices used by the visitors causes problems in most scenarios. For example, when 4096 bits are used instead of 2048 bits, I am faced with 0.4-0.8 seconds longer handshake times in some of my attempts. As if it’s okay for the handshake to take that long, it puts an extra load on the server. But when you generate a 384-bit ECC certificate instead of 4096-bit RSA, you get a much faster certificate and at the same time security equal to 7680-bit RSA (if it were that size).\nWell, you explained it well, but where is the point of this work, I seem to hear you say. I will upset you, but there is no point in this business. The reason why it doesn’t is hidden in the background math. Briefly, I will talk about the minor differences in the production and use of both certificates, explain how and why they cause big differences, and in the last part, I will talk about something that is not written in the title as a bonus. (For the bonus you’ll have to read till the end :D)\nProduction process of ECC Certificate First of all (as always), we need to install the latest updates via the console with the package manager of the Linux version we are in.\nUbuntu: sudo apt update \u0026\u0026 sudo apt upgrade -y\rFedora: sudo yum update -y\rArch Linux: sudo pacman -Syyu After the updates are installed, we start configuring the nginx service (which is the service that allows you to receive external HTTP/HTTPS connections) on your server (Ubuntu in my case). First of all, it should be noted that because of the confusion, apache, nginx and litespeed services are different services that do the same job. I chose NGINX because it is easier to manage and has more community support.\nLet’s generate the private key First, we generate the private key with OpenSSL. The OpenSSL command we will use is ’ecparam’ (EC parameter manipulation) and to pass the configuration parameters to this command:\nopenssl ecparam -genkey -name secp384r1 -out privkey.pem The -genkey option tells OpenSSL to generate an EC key. The -name parameter tells OpenSSL which curve to use. The -out parameter tells OpenSSL to write the output to a file. Note that OpenSSL writes its output in PEM format by default. We can check that OpenSSL is doing the right thing with the ec command that handles EC keys:\nopenssl ec -in privkey.pem -noout -text -in is input file The -noout tells OpenSSL not to extract the key, meaninglessly printing privkey.pem to stdout. -text tells OpenSSL to write information about the key in plain text format If all goes well and the key is generated correctly, OpenSSL will show something like the following:\nread EC key\rPrivate-Key: (384 bit)\rpriv:\r[secret]\rpub:\r[secret]\rASN1 OID: secp384r1\rNIST CURVE: P-384 This verifies that the key was created with the P-384 curve. If you ask why we don’t use P-512 instead of P-384, Let’s Encrypt doesn’t sign if the ecliptic curves are higher than 384 bits, and modern browsers like Google Chrome mark websites using 512-bit ecliptic curves as invalid. That’s the short answer.\nLet’s create OpenSSL configuration for the certificate Now we need to create an OpenSSL configuration file containing the domain-specific parameters for which we want to get the TLS certificate. In this example, we will enter the following configuration in an openssl.cnf file:\n[ req ]\rprompt = no\rencrypt_key = no\rdefault_md = sha512\rdistinguished_name = dname\rreq_extensions = reqext\r[ dname ]\rCN = example.com\remailAddress = admin@example.com\r[ reqext ]\rsubjectAltName = DNS:example.com, DNS:www.example.com Here is a brief description of these configuration options:\nIn the required [ req ] section:\nprompt=no tells OpenSSL to get as much configuration as possible from the config file encrypt_key = no tells OpenSSL not to encrypt the private key with a password. (Encrypted private keys are supported by Nginx, but I don’t use them.) default_md=sha512 tells OpenSSL to sign the CSR with SHA512. (As far as I know, Let’s Encrypt only supports RSA with SHA256 for its signatures, but that doesn’t mean we can’t use stronger encryption in CSR.) distinguished_name=dname tells OpenSSL to look for a [ dname ] section for Distinguished Name configuration options. req_extensions=reqext tells OpenSSL to look for a [ reqext ] section in the configuration options for Subject Alternative Names (SANs) extensions that it wants to configure. In the Distinguished Name [ dname ] section:\nCN = example.com indicates the Common Name of the certificate. Your emailAddress = admin@example.com email address must be prominent. Desired Extensions In the [ reqext ] section, subjectAltName provides the list of SANs for the certificate. (Chrome as of v58 requires that the Common Name be included in the list of SANs). Let’s Encrypt v2 supports wildcard domains, so in this example you can use a single-level wildcard for non-apex hosts (*.example.com).\nLet’s Create Certificate Signing Request The final step on the client side is to generate the Certificate Signing Request using OpenSSL, then we will forward it to Let’s Encrypt for signing and retrieve the signed certificate.\nThe OpenSSL command required to generate a CSR is req .\nopenssl req -new -config openssl.cnf -key privkey.pem -out csr.pem -new tells OpenSSL that we have created a CSR (and we do not examine an existing CSR) -config openssl.cnf specifies the config file we created above -key privkey.pem indicates the private key we created above -out csr.pem tells OpenSSL to write the CSR to an output file (instead of stdout) We can verify that we have generated the CSR correctly:\nopenssl req -in csr.pem -noout -text -verify -verify asks OpenSSL to verify the signature in the CSR This should produce the following expected results in the output:\nverify OK\rCertificate Request:\rData:\rVersion: 1 (0x0)\rSubject: CN = example.com, emailAddress = admin@example.com\rSubject Public Key Info:\rPublic Key Algorithm: id-ecPublicKey\rPublic-Key: (384 bit)\rpub:\r[gizli]\rASN1 OID: secp384r1\rNIST CURVE: P-384\rAttributes:\rRequested Extensions:\rX509v3 Subject Alternative Name:\rDNS:example.com, DNS:www.example.com\rSignature Algorithm: ecdsa-with-SHA512\r[gizli] Ask Let’s Encrypt to sign our certificate The final step is to send the CSR with an ACME client to Let’s Encrypt for signing, certbot is the most common client for this job.\nCommand line options passed to the Certbot client depend on our setup, the person our domain is registered to, etc. varies depending. Usually we need to use the certonly command and if you used asterisks (*) you need to use one of the certbot DNS plugins.\nFor example, if the domain example.com is registered with Cloudflare, we can use the corresponding plugin to handle the verification, which is extremely convenient and does not require manual intervention in the process. (Configuring the Cloudflare plugin with secret token information is beyond the scope of this article.)\nIt’s usually recommended to make sure everything is ok with --dry-run first to make sure everything is ok.\ncertbot nginx certonly --dry-run --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem Quotation marks are required around characters to avoid erroneous manipulations and are generally a good idea. --csr csr.pem tells certbot that we already have a certificate and we need Let’s Encrypt to sign it for us. The Certbot client will check on the command line that the requested list of domains matches the domains listed in the certificate and will use the Certbot NGINX plugin to verify that the domain is ours and let us know if there are any issues.\nIf nothing is wrong, it will tell you:\nIMPORTANT NOTES:\r- The dry run was successful. The actual command is just as follows:\ncertbot nginx certonly --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem After a (long) delay, the client will output:\nSigned certificate: 0000_cert.pem Root and intermediate certificates: 0000_chain.pem Certificate + intermediates: 0001_chain.pem At this point, the CSR csr.pem can be deleted. If we are curious, we can inspect the certificates returned by the client with OpenSSL using the x509 command:\nopenssl x509 -in 0001_chain.pem -noout -text Unfortunately, we will discover that as described above, Let’s Encrypt signs our certificate with a SHA256 signature. (As well as being more secure, SHA512 outperforms SHA256 on modern 64-bit CPUs.) But our public key should still use ECDSA.\nThese files are not ordinary, so we must move and edit them in a more informative way.\nOn Debian Linux I like to create subdirectories for my domains by keeping my private key in /home/USER_NAME/SSL/private/example.com/privkey.pem and certificates:\n/home/USER_NAME/SSL/certs/example.com/cert.pem /home/USER_NAME/SSL/certs/example.com/chain.pem /home/USER_NAME/SSL/certs/example.com/fullchain.pem END If we’ve done everything right, inspecting the certificate with a web browser like Chrome will confirm that it’s an EC certificate:\nMozilla Observatory will also give us an A+ rating!\nIn addition, we can see that a 384-bit ECC certificate was used as a result of the SSL Labs report.\nNOTE: This article has benefited from the article of Benjamin Black on the same subject.\n","wordCount":"1616","inLanguage":"en","datePublished":"2022-03-20T00:00:00Z","dateModified":"2022-03-20T00:00:00Z","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb-works.github.io/blog/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb-works.github.io/blog/en/ accesskey=h title="Wise (Alt + H)">Wise</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb-works.github.io/blog/ title=Turkish aria-label=:tr:>🇹🇷</a></li><li><a href=https://wiseweb-works.github.io/blog/de/ title=Deutsch aria-label=:de:>🇩🇪</a></li></ul></div></div><ul id=menu><li><a href=https://wiseweb-works.github.io/en/blog/ title=Home><span>Home</span></a></li><li><a href=https://wiseweb-works.github.io/en/blog/post/ title=Blog><span>Blog</span></a></li><li><a href=https://wiseweb-works.github.io/en/blog/page/iletisim/ title=Contact><span>Contact</span></a></li><li><a href=https://wiseweb-works.github.io/en/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://wiseweb-works.github.io/en/blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://wiseweb-works.github.io/en/blog/search/ title="Search 🔍 (Alt + /)" accesskey=/><span>Search 🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Generating ECC SSL Certificate on Linux Server</h1><div class=post-meta><span title='2022-03-20 00:00:00 +0000 UTC'>20 March, 2022</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1616 words&nbsp;·&nbsp;Wise&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/>🇹🇷</a></li><li><a href=https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikas%C4%B1/>🇩🇪</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/ecc-ssl-sertifikas%c4%b1.en.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction-and-summary aria-label="Introduction and Summary">Introduction and Summary</a><ul><li><a href=#production-process-of-ecc-certificate aria-label="Production process of ECC Certificate">Production process of ECC Certificate</a></li><li><a href=#lets-generate-the-private-key aria-label="Let&amp;rsquo;s generate the private key">Let&rsquo;s generate the private key</a></li><li><a href=#lets-create-openssl-configuration-for-the-certificate aria-label="Let&amp;rsquo;s create OpenSSL configuration for the certificate">Let&rsquo;s create OpenSSL configuration for the certificate</a></li><li><a href=#lets-create-certificate-signing-request aria-label="Let&amp;rsquo;s Create Certificate Signing Request">Let&rsquo;s Create Certificate Signing Request</a></li><li><a href=#ask-lets-encrypt-to-sign-our-certificate aria-label="Ask Let&amp;rsquo;s Encrypt to sign our certificate">Ask Let&rsquo;s Encrypt to sign our certificate</a></li></ul></li><li><a href=#end aria-label=END>END</a></li></ul></div></details></div><div class=post-content><h1 id=introduction-and-summary>Introduction and Summary<a hidden class=anchor aria-hidden=true href=#introduction-and-summary>#</a></h1><p>Today we will learn how to generate SSL certificates to ensure that the traffic between a website or application server you manage and your visitors is confidential / reliable and verifiable. In my previous articles, I explained how and with what configuration you would deploy the certificate you produced. In this article, I will show you how to set up the equation of less bread, more meatballs, that is, how to produce a faster and more secure SSL certificate. Normally, if you are familiar with Let&rsquo;s Encrypt&rsquo;s ACME protocol (as of the date of writing), it is possible to generate a 1024-4098 (if you try too hard, maybe 8196) bit certificate with RSA asymmetric key structure and use it for 90 days relatively. However, generating such a large key, using it during TLS handshake after generating it, and being compatible with the devices used by the visitors causes problems in most scenarios. For example, when 4096 bits are used instead of 2048 bits, I am faced with 0.4-0.8 seconds longer handshake times in some of my attempts. As if it&rsquo;s okay for the handshake to take that long, it puts an extra load on the server. But when you generate a 384-bit ECC certificate instead of 4096-bit RSA, you get a much faster certificate and at the same time security equal to 7680-bit RSA (if it were that size).</p><p>Well, you explained it well, but where is the point of this work, I seem to hear you say. I will upset you, but there is no point in this business. The reason why it doesn&rsquo;t is hidden in the background math. Briefly, I will talk about the minor differences in the production and use of both certificates, explain how and why they cause big differences, and in the last part, I will talk about something that is not written in the title as a bonus. (For the bonus you&rsquo;ll have to read till the end :D)</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_240x0_resize_q50_h2_box.webp 240w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_300x0_resize_q50_h2_box.webp 300w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_360x0_resize_q50_h2_box.webp 360w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_420x0_resize_q50_h2_box.webp 420w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_480x0_resize_q50_h2_box.webp 480w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_600x0_resize_q50_h2_box.webp 600w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_711x0_resize_q50_h2_box.webp 711w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/key-size-comparison.jpg alt title></div><figcaption></figcaption></figure><h2 id=production-process-of-ecc-certificate>Production process of ECC Certificate<a hidden class=anchor aria-hidden=true href=#production-process-of-ecc-certificate>#</a></h2><p>First of all (as always), we need to install the latest updates via the console with the package manager of the Linux version we are in.</p><pre tabindex=0><code>Ubuntu: sudo apt update &amp;&amp; sudo apt upgrade -y

Fedora: sudo yum update -y

Arch Linux: sudo pacman -Syyu
</code></pre><p>After the updates are installed, we start configuring the nginx service (which is the service that allows you to receive external HTTP/HTTPS connections) on your server (Ubuntu in my case). First of all, it should be noted that because of the confusion, apache, nginx and litespeed services are different services that do the same job. I chose NGINX because it is easier to manage and has more community support.</p><h2 id=lets-generate-the-private-key>Let&rsquo;s generate the private key<a hidden class=anchor aria-hidden=true href=#lets-generate-the-private-key>#</a></h2><p>First, we generate the private key with OpenSSL. The OpenSSL command we will use is &rsquo;ecparam&rsquo; (EC parameter manipulation) and to pass the configuration parameters to this command:</p><pre tabindex=0><code>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</code></pre><ul><li>The <code>-genkey</code> option tells OpenSSL to generate an EC key.</li><li>The <code>-name</code> parameter tells OpenSSL which curve to use.</li><li>The <code>-out</code> parameter tells OpenSSL to write the output to a file.</li></ul><p>Note that OpenSSL writes its output in PEM format by default. We can check that OpenSSL is doing the right thing with the <code>ec</code> command that handles EC keys:</p><pre tabindex=0><code>openssl ec -in privkey.pem -noout -text
</code></pre><ul><li><code>-in</code> is input file</li><li>The <code>-noout</code> tells OpenSSL not to extract the key, meaninglessly printing privkey.pem to stdout.</li><li><code>-text</code> tells OpenSSL to write information about the key in plain text format</li></ul><p>If all goes well and the key is generated correctly, OpenSSL will show something like the following:</p><pre tabindex=0><code>read EC key
Private-Key: (384 bit)
priv:
    [secret]
pub:
    [secret]
ASN1 OID: secp384r1
NIST CURVE: P-384
</code></pre><p>This verifies that the key was created with the P-384 curve. If you ask why we don&rsquo;t use P-512 instead of P-384, Let&rsquo;s Encrypt doesn&rsquo;t sign if the ecliptic curves are higher than 384 bits, and modern browsers like Google Chrome mark websites using 512-bit ecliptic curves as invalid. That&rsquo;s the short answer.</p><h2 id=lets-create-openssl-configuration-for-the-certificate>Let&rsquo;s create OpenSSL configuration for the certificate<a hidden class=anchor aria-hidden=true href=#lets-create-openssl-configuration-for-the-certificate>#</a></h2><p>Now we need to create an OpenSSL configuration file containing the domain-specific parameters for which we want to get the TLS certificate. In this example, we will enter the following configuration in an <code>openssl.cnf</code> file:</p><pre tabindex=0><code>[ req ]
prompt = no
encrypt_key = no
default_md = sha512
distinguished_name = dname
req_extensions = reqext

[ dname ]
CN = example.com
emailAddress = admin@example.com

[ reqext ]
subjectAltName = DNS:example.com, DNS:www.example.com
</code></pre><p>Here is a brief description of these configuration options:</p><p>In the required <code>[ req ]</code> section:</p><ul><li><code>prompt=no</code> tells OpenSSL to get as much configuration as possible from the config file</li><li><code>encrypt_key = no</code> tells OpenSSL not to encrypt the private key with a password. (Encrypted private keys are supported by Nginx, but I don&rsquo;t use them.)</li><li><code>default_md=sha512</code> tells OpenSSL to sign the CSR with SHA512. (As far as I know, Let&rsquo;s Encrypt only supports RSA with SHA256 for its signatures, but that doesn&rsquo;t mean we can&rsquo;t use stronger encryption in CSR.)</li><li><code>distinguished_name=dname</code> tells OpenSSL to look for a <code>[ dname ]</code> section for Distinguished Name configuration options.</li><li><code>req_extensions=reqext</code> tells OpenSSL to look for a <code>[ reqext ]</code> section in the configuration options for Subject Alternative Names (SANs) extensions that it wants to configure.</li></ul><p>In the Distinguished Name <code>[ dname ]</code> section:</p><ul><li><code>CN = example.com</code> indicates the Common Name of the certificate.</li><li>Your <code>emailAddress = admin@example.com</code> email address must be prominent.
Desired Extensions In the <code>[ reqext ]</code> section, subjectAltName provides the list of SANs for the certificate. (Chrome as of v58 requires that the Common Name be included in the list of SANs).</li></ul><p>Let&rsquo;s Encrypt v2 supports wildcard domains, so in this example you can use a single-level wildcard for non-apex hosts (*.example.com).</p><h2 id=lets-create-certificate-signing-request>Let&rsquo;s Create Certificate Signing Request<a hidden class=anchor aria-hidden=true href=#lets-create-certificate-signing-request>#</a></h2><p>The final step on the client side is to generate the Certificate Signing Request using OpenSSL, then we will forward it to Let&rsquo;s Encrypt for signing and retrieve the signed certificate.</p><p>The OpenSSL command required to generate a CSR is <code>req</code> .</p><pre tabindex=0><code>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</code></pre><ul><li><code>-new</code> tells OpenSSL that we have created a CSR (and we do not examine an existing CSR)</li><li><code>-config</code> openssl.cnf specifies the config file we created above</li><li><code>-key privkey.pem</code> indicates the private key we created above</li><li><code>-out csr.pem</code> tells OpenSSL to write the CSR to an output file (instead of stdout)</li></ul><p>We can verify that we have generated the CSR correctly:</p><pre tabindex=0><code>openssl req -in csr.pem -noout -text -verify
</code></pre><ul><li><code>-verify</code> asks OpenSSL to verify the signature in the CSR</li></ul><p>This should produce the following expected results in the output:</p><pre tabindex=0><code>verify OK
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: CN = example.com, emailAddress = admin@example.com
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    [gizli]
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:example.com, DNS:www.example.com
    Signature Algorithm: ecdsa-with-SHA512
         [gizli]
</code></pre><h2 id=ask-lets-encrypt-to-sign-our-certificate>Ask Let&rsquo;s Encrypt to sign our certificate<a hidden class=anchor aria-hidden=true href=#ask-lets-encrypt-to-sign-our-certificate>#</a></h2><p>The final step is to send the CSR with an ACME client to Let&rsquo;s Encrypt for signing, <code>certbot</code> is the most common client for this job.</p><p>Command line options passed to the <code>Certbot</code> client depend on our setup, the person our domain is registered to, etc. varies depending. Usually we need to use the <code>certonly</code> command and if you used asterisks (*) you need to use one of the certbot DNS plugins.</p><p>For example, if the domain <code>example.com</code> is registered with Cloudflare, we can use the corresponding plugin to handle the verification, which is extremely convenient and does not require manual intervention in the process. (Configuring the Cloudflare plugin with secret token information is beyond the scope of this article.)</p><p>It&rsquo;s usually recommended to make sure everything is ok with <code>--dry-run</code> first to make sure everything is ok.</p><pre tabindex=0><code>certbot nginx certonly --dry-run --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><ul><li>Quotation marks are required around characters to avoid erroneous manipulations and are generally a good idea.</li><li><code>--csr csr.pem</code> tells certbot that we already have a certificate and we need Let&rsquo;s Encrypt to sign it for us.</li></ul><p>The Certbot client will check on the command line that the requested list of domains matches the domains listed in the certificate and will use the Certbot NGINX plugin to verify that the domain is ours and let us know if there are any issues.</p><p>If nothing is wrong, it will tell you:</p><pre tabindex=0><code>IMPORTANT NOTES:
 - The dry run was successful.
</code></pre><p>The actual command is just as follows:</p><pre tabindex=0><code>certbot nginx certonly --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><p>After a (long) delay, the client will output:</p><ol><li>Signed certificate: <code>0000_cert.pem</code></li><li>Root and intermediate certificates: <code>0000_chain.pem</code></li><li>Certificate + intermediates: <code>0001_chain.pem</code>
At this point, the CSR <code>csr.pem</code> can be deleted.</li></ol><p>If we are curious, we can inspect the certificates returned by the client with OpenSSL using the <code>x509</code> command:</p><pre tabindex=0><code>openssl x509 -in 0001_chain.pem -noout -text
</code></pre><p>Unfortunately, we will discover that as described above, Let&rsquo;s Encrypt signs our certificate with a SHA256 signature. (As well as being more secure, SHA512 outperforms SHA256 on modern 64-bit CPUs.) But our public key should still use ECDSA.</p><p>These files are not ordinary, so we must move and edit them in a more informative way.</p><p>On Debian Linux I like to create subdirectories for my domains by keeping my private key in <code>/home/USER_NAME/SSL/private/example.com/privkey.pem</code> and certificates:</p><ul><li><code>/home/USER_NAME/SSL/certs/example.com/cert.pem</code></li><li><code>/home/USER_NAME/SSL/certs/example.com/chain.pem</code></li><li><code>/home/USER_NAME/SSL/certs/example.com/fullchain.pem</code></li></ul><h1 id=end>END<a hidden class=anchor aria-hidden=true href=#end>#</a></h1><p>If we&rsquo;ve done everything right, inspecting the certificate with a web browser like Chrome will confirm that it&rsquo;s an EC certificate:</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_240x0_resize_q50_h2_box_3.webp 240w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_300x0_resize_q50_h2_box_3.webp 300w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_360x0_resize_q50_h2_box_3.webp 360w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_420x0_resize_q50_h2_box_3.webp 420w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_480x0_resize_q50_h2_box_3.webp 480w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_600x0_resize_q50_h2_box_3.webp 600w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_768x0_resize_q50_h2_box_3.webp 768w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_800x0_resize_q50_h2_box_3.webp 800w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_854x0_resize_q50_h2_box_3.webp 854w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome.png alt title></div><figcaption></figcaption></figure><p>Mozilla Observatory will also give us an A+ rating!</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_240x0_resize_q50_h2_box_3.webp 240w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_300x0_resize_q50_h2_box_3.webp 300w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_360x0_resize_q50_h2_box_3.webp 360w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_420x0_resize_q50_h2_box_3.webp 420w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_480x0_resize_q50_h2_box_3.webp 480w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_600x0_resize_q50_h2_box_3.webp 600w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_768x0_resize_q50_h2_box_3.webp 768w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_800x0_resize_q50_h2_box_3.webp 800w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_880x0_resize_q50_h2_box_3.webp 880w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla.png alt title></div><figcaption></figcaption></figure><p>In addition, we can see that a 384-bit ECC certificate was used as a result of the SSL Labs report.</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_240x0_resize_q50_h2_box_3.webp 240w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_300x0_resize_q50_h2_box_3.webp 300w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_360x0_resize_q50_h2_box_3.webp 360w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_420x0_resize_q50_h2_box_3.webp 420w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_480x0_resize_q50_h2_box_3.webp 480w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_600x0_resize_q50_h2_box_3.webp 600w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_768x0_resize_q50_h2_box_3.webp 768w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_800x0_resize_q50_h2_box_3.webp 800w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_960x0_resize_q50_h2_box_3.webp 960w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1024x0_resize_q50_h2_box_3.webp 1024w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1080x0_resize_q50_h2_box_3.webp 1080w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1200x0_resize_q50_h2_box_3.webp 1200w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1366x0_resize_q50_h2_box_3.webp 1366w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1440x0_resize_q50_h2_box_3.webp 1440w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1920x0_resize_q50_h2_box_3.webp 1920w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1994x0_resize_q50_h2_box_3.webp 1994w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs.png alt title></div><figcaption></figcaption></figure><p>NOTE: This article has benefited from the article of <a href=https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc>Benjamin Black</a> on the same subject.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb-works.github.io/blog/en/tags/linux/>linux</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/ssl/>ssl</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/security/>security</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/ecc/>ecc</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/elliptic-curve/>elliptic curve</a></li></ul><nav class=paginav><a class=prev href=https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlat%C4%B1m/><span class=title>« Prev</span><br><span>OpenVPN In-Depth Review</span></a>
<a class=next href=https://wiseweb-works.github.io/blog/en/post/ssl-konfigurasyonu/><span class=title>Next »</span><br><span>Increasing SSL security on Linux Servers</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wiseweb-works.github.io/blog/en/>Wise</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>