<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenVPN In-Depth Review | Wise</title>
<meta name=keywords content="linux,ssl,security,ecc,elliptic curve,openvpn,tls,aes"><meta name=description content="Introduction and Summary Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.7e67ba6bc7977aae7e3c146fe69f6dc9e4c17379e582f2ad4eb927fd2f1b3555.css integrity="sha256-fme6a8eXeq5+PBRv5p9tyeTBc3nlgvKtTrkn/S8bNVU=" rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb-works.github.io/blog/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb-works.github.io/blog/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb-works.github.io/blog/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb-works.github.io/blog/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb-works.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/><link rel=alternate hreflang=en href=https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/><link rel=alternate hreflang=de href=https://wiseweb-works.github.io/blog/de/post/openvpn-full-anlatim/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="OpenVPN In-Depth Review"><meta property="og:description" content="Introduction and Summary Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-27T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-11T02:43:18+02:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenVPN In-Depth Review"><meta name=twitter:description content="Introduction and Summary Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wiseweb-works.github.io/blog/en/post/"},{"@type":"ListItem","position":2,"name":"OpenVPN In-Depth Review","item":"https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenVPN In-Depth Review","name":"OpenVPN In-Depth Review","description":"Introduction and Summary Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted.","keywords":["linux","ssl","security","ecc","elliptic curve","openvpn","tls","aes"],"articleBody":"Introduction and Summary Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted. Therefore, I guess our article will consist of 3 parts and a question-answer section if necessary. Now let’s buckle up and take a trip to the deep and gloomy world of the internet.\nWhat is OpenVPN and what is it used for? Today, there is almost no business that cannot be done online. Even our work, which is not normally online, has evolved to work from home due to the pandemic and the new normal. However, there were big problems both because it is a working method that we are not used to and because our people are not very good with technology. Before it became clear that people needed to connect from their home computers to their office computers, some companies came up with frivolous ideas such as sending office computers to employees’ homes. They understood very well how wrong this was from the feedback they received in a short time. In short, it was finally accepted that electronic devices should remain in the office and somehow a secure and sustainable connection should be made remotely. Of course, institutions found themselves in such needs before, but such a large-scale situation was not in question back then. Before the pandemic, it used various protocols such as PPTP, L2TP, IPSec, IKev2, SSTP and finally OpenVPN. These are usually abbreviations for certain long and fancy words and their basic logic is to connect two or more devices and make them act as if they are on the same network. I won’t talk much, as protocols prior to OpenVPN brought with them certain weaknesses, slowness, and technical difficulties with its implementation. OpenVPN is the name of the protocol and program that allows at least 2 devices in the role of server and client to connect to each other and do this in a way that meets industry standards. I’m using a remote desktop program, I seem to hear you say what is the need for this. Unfortunately, he and all other programs like him basically have to use this protocol. If you press the shield icon or the connection details in TeamViewer, one of the most famous, you can see the OpenVPN protocol.\nWhat do we need to establish an OpenVPN connection? First of all, OpenVPN must be installed on both the server and client (the device to be connected) side. Then, a settings (config) file should be edited that shows the conditions under which the devices will communicate. The main event is that this config file is generated and used by the client. This config file is divided into server_config used by the server and client_config used by the client.\nThe settings file maintained by the server contains the following entries port 1194 specifies which port it will receive a connection request to make the OpenVPN connection. proto tcp Connection possible over TCP or UDP. Setting entry entered for selection. dev tun TAP or TUN interface can be used. These are virtual interfaces. TAP layer 2 establishes a connection, while TUN layer 3 establishes a connection. user nobody Enables connecting users to an unauthorized user on the server. group $NOGROUP It allows connecting users to be linked to an unauthorized group on the server as a group. persist-key An authorization setting for the creation and restart of the virtual interface persist-tun Also an authorization setting for the creation and restart of the virtual interface keepalive 10 120 A setting for how many connections will be kept active and how long the active connection will be terminated if no communication is established. ifconfig-pool-persist ipp.txt A setting to keep the IP addresses given by OpenVPN to clients in the virtual network and give them the same addresses if they reconnect push \"dhcp-option DNS 1.1.1.1\" A DNS setting for the server to use when exiting the network compress The part where compression options are set dh none A setting for turning Diffie-Hellman on or off ecdh-curve If you are using Elliptic Curve Diffie-Hellman, the setting next to which the curve you need to select is adjusted dh dh.pem setting specifying the location of the PEM file you need to create beforehand if you are using Diffie-Hellman tls-crypt tls-crypt.key Required setting to encrypt TLS layer even before pre-shared master tls-auth tls-auth.key 0 setting that allows parties to be authenticated beyond encryption at the pre-handshake stage of the TLS layer crl-verify crl.pem Setting to check whether the generated certificates are revoked or not via the CRL list ca ca.crt A setting that reports the location of the certificate of the certificate authority of the generated certificate cert $SERVER_NAME.crt A setting that tells the location of the server’s certificate key $SERVER_NAME.key A setting indicating the location of the required asymmetric secret key next to the server’s certificate auth $HMAC_ALG A setting describing which hash algorithm to use for the data channel and, if necessary, tls-auth cipher $CIPHER A setting that tells which encryption algorithm to use for the data channel ncp-ciphers $CIPHER A setting declaring which encryption algorithms the server can use tls-server A setting that tells the server to use the TLS channel A setting tls-version-min 1.2 reports the lowest version to be used on the TLS channel tls-cipher $CC_CIPHER Encryption is also used at TLS layer, except for data channel, which is the setting declaring control channel encryption client-config-dir /etc/openvpn/ccd Setting that tells where client settings files are kept status /var/log/openvpn/status.log Setting that tells where status reports are written and where log files are kept verb 3 This setting, which is the abbreviation of the word Verbose, is the setting of how detailed the status report is to be given. The client-side settings file contains the following entries client indicates that the device is in the client role proto tcp-client reports to use TCP as protocol remote $IP $PORT The part where the IP address and Port number of the server(s) to be connected are set dev tun sets which of the TUN/TAP interfaces to use resolve-retry infinite We tell you how long to wait if address resolution is delayed due to IP or DNS nobind setting to not connect to any address in the local persist-key Allows key files to be read without additional authorization on reboot persist-tun It also allows the TUN/TAP interface to be woken up without authorization on reboot remote-cert-tls server Verifies the certificate of the connected server at TLS layer verify-x509-name $SERVER_NAME name Command that tells the name in the certificate that the server will return to and what the name of the server should be auth $HMAC_ALG Command that tells which algorithm to use for validation auth-nocache Does not cache the password required for login cipher $CIPHER Command to select the algorithm to be used for encryption tls-client enables TLS during TLS communication and assumes the client role tls-version-min 1.2 Sets the lowest TLS version tls-cipher $CC_CIPHER selects the encryption algorithm to use in the TLS control channel ignore-unknown-option block-outside-dns Prevents unknown DNS addresses from being used setenv opt block-outside-dns blocks DNS leaks for Windows 10 verb 3 Determines the degree of reporting compress Compression algorithm settings are reported here \"/etc/openvpn/easy-rsa/pki/ca.crt\" Hard-Coded embedding of expected server certificate authority file \"/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt\" Hard-Coded embedding of client certificate file \"/etc/openvpn/easy-rsa/pki/private/$CLIENT.key\" Hard-Coded embedding of client asymmetric secret key \"/etc/openvpn/tls-crypt.key\" Specifying the key file for TLS crypt \"/etc/openvpn/tls-auth.key\" Specifying the key file for TLS auth key-direction 1 assigns roles to client and server for TLS layer encryption (0 and 1) You can find detailed documentation of these settings and more on the OpenVPN web page.\nWhat happens when establishing an OpenVPN connection? Every time I connect with OpenVPN I feel like R2-D2 hijacking their Starfleet plans. People don’t always want to find themselves in deep scrutiny and may ask someone to explain to them what and how. In my purpose of writing this article, I actually asked myself this question and I put a lot of effort to get the answer. I don’t want you to work so hard, but I can’t say that you should upload it immediately, don’t think about the rest, it’s my job. As I promised at the beginning, I will explain this process to you in depth and leave the decision to you. Here’s how the process works in an OpenVPN connection, pros and cons (as I’ve been able to figure it out so far). You first establish a TCP/UDP connection. You run a process like any application that uses TCP, and then you switch to the TLS layer. You are doing handshake and some authentication at TLS layer. This layer is also called the control channel. Then a certain communication is fixed and the data channel is passed. The process of encrypting and decrypting the data packets to be sent this time in the data or data channel begins. For this, devices are talking to each other and data is started to be sent under certain common conditions. In short, at the end of the process I have described in this way, the communication we started from 0 ends with the safe and desired data access to us, or requests are sent again, this time in a reverse way, over the connection that is kept open. Thus, a system like nested pipes emerges. If you need to write the only important thing required for the article here:\nIt will be TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512. Here the TLS input specifies that the control channel will be executed over the TLS layer. Other alternatives are SSL or NULL. The ECDHE input specifies that the first pre-key will be generated using the Elliptic Diffie-Hellman algorithm. Other alternatives are to use DHE, DH or not. The ECDSA data indicates that the Elliptic Digital Signature Certificate Algorithm will be used for mutual authentication and asymmetric key. Another available alternative is RSA. No need to count the others. Specifies the encryption algorithm to be used on the AES_256_GCM data channel. Other alternatives are AES-128-CBC, AES-128-GCM and AES-256-CBC SHA384 specifies the hash algorithm to use. The other alternative is SHA256. P512 allows the elliptic curve to be used to be selected as Prime-512. Other alternatives are P-256 and P-384. The process of establishing the TCP connection Now, if you have an approximate picture of the process in your mind, I start with the explanation of the TCP process. Let’s say we have a client and a server in our case, and the connection is just these two. The client sends a SYN (m) packet to the server it wants to connect to. In response, the server sends a SYN (n) packet and an ACK (m+1) packet over the same port. The client that receives this also returns as ACK (n+1) in response, and a 3-way TCP handshake or 3-Way TCP handshake takes place. Thus, we have an open channel between client and server over the specified port.\nhttps://blog.shiftasia.com/what-happen-when-access-website (Date: 08.04.2023) https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Date: 08.04.2023) As can be seen in the photos, if the process runs smoothly, communication can be made in 3 steps. But if you ask why we are doing this in 3 steps, can’t it be done in a shorter way? I would say (for now) no, no, for a full-duplex communication, both parties need to send SYN and ACK packets. Maybe I’ll tell you different ways in the future, but for now this is how it is. Anyway, the TCP/UDP part is always short and simple.\nProcess running in TLS layer After establishing a communication over TCP, the client is the person who takes the conversation to another level. Clients always request something from the server or request an answer. In general, servers are not seen to respond to a request that did not come to them. The process proceeds according to the principle of demand first, then supply. Yes, the parties are at the TLS layer now. The client first says hello to the server. Not a joke, it’s real. The first packet sent by the client is called the Client-Hello packet. Next to this package (in order to speed up the process), the Supported-Chipers package that specifies the encryption algorithms it supports, a randomly generated number by the client, an SNI server name indicator if more than one service is running on the same IP address, and the session ID if necessary. . The server’s response to this is, first of all, a polite hello. Because the first packet that the server sends in response is called the Server-Hello packet. Next to this package, the Selected-Chiper package, which specifies the server certificate, the encryption algorithms it supports, and the algorithm it chooses, sends a random number it generates, the Session ID if necessary, and an SNI-like ID if more than one client is connecting over the same IP. . The client first verifies with the server certificate whether it is really the person it is waiting for by starting the communication. In addition, in some cases, the server verifies with a certificate whether the client is one of the clients it expects. If this mutual-authentication process is positive, the next stage is passed. The key generation and exchange process is triggered. At this stage, the client again steps in and says that he wants to change the key with the algorithm they have determined during this communication, which is considered insecure. Parties begin to generate a prekey with Diffie-Hellman or ECDHE. For this, pre-secrets are shared by the client and server. The answers found by performing a number of mathematical operations are sent to the top and the same result is reached by performing mathematical operations again. The result is the first fore-key they’ve securely created between them. After that, with the encryption algorithm they determined, A data channel other than the control channel is created to communicate and the process continues from there.\nhttps://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Date: 08.04.2023) As can be seen in the photos, the process is almost the same as when connecting to a web page. Only certain stages are added, removed or changed according to needs. For example, in accordance with PFS, which stands for Advanced Privacy, the parties do not transmit the front-key with the server’s asymmetric key. Because in this case, since the same key will be used for each session, the data will be stored and then the data will be readable retrospectively by waiting for a day when the key is revealed. That’s why this change was made. Again, in accordance with the zero trust threat model, I want each layer and process to advance the process without trusting the other to do their job correctly. That’s why we want the packets to be encrypted according to the tls-auth feature and to verify the integrity of the incoming and outgoing data, even at that first communication moment in the TLS layer. From the first moment you say hello, third parties will not be able to understand what you are talking about and at what stage you are. For this, the first communication is started with a predetermined key(s) and if necessary, these keys are renewed at regular intervals. Thus, even until the first pre-key is created in the TLS layer, confidentiality is not compromised and unauthorized parties are not created in vain.\nProcess running in the data layer If this whole process has been completed successfully and the data channel has been passed, you have now come to the best part of the job. Data will be encrypted with AES encryption method. During encryption, the tables will be shuffled according to the CBC-GCM counter mode according to your selection, and a 128 or 256-bit encryption key will be used in this process according to your selection. Of course, whatever you choose, the encryption block length will be 128 bits. Only the encryption key length changes. AES-256-GCM that I have chosen for this explanation is an AEAD encryption type. It summarizes the data it sends independently from other channels and processes at a certain stage and sends it together with the summary. Thus, authentication and encryption functions are fulfilled in AEAD, which stands for ‘Authentication Encryption with associated data’. There is a problem that requires a distinction to be made here. At what stage and in which order will we use the encryption and hashing algorithms?\nEncrypt-then-MAC (EtM) Encrypt-and-MAC (E-and-M) MAC-then-Encrypt (MtE) https://en.wikipedia.org/wiki/Authenticated_encryption (Date: 08.04.2023)\nAccording to EtM, which is the first approach, the data is first encrypted, then encrypted with another key as a result of the digest, and the resulting result is sent together in blocks. If we look at real-world solutions that use it, the IPSec protocol will come to mind first. This is the only method that can achieve the highest security definition in AE, but this can only be achieved if the MAC algorithm used is free of corruption or has not yet been cracked. Various EtM cipher suites are also available for SSHv2. Note, however, that key separation is mandatory for data and digest (different keys must be used for encryption and key hashing), otherwise you may end up with a potentially insecure result depending on the particular encryption method and hash function used.\nAccording to the second approach, E\u0026M, plain text data is encrypted and a summary of the encryption state of the plain text data is added next to it. Although only one key is used here, the fact that there are two different results (encryption result and digest result) for the same data clearly shows that the security is not good enough. As a real-world solution using this system, we can cite the first versions of SSH as an example. In order to improve this, methods such as encrypting the sent summary file with the same key were tried.\nAccording to MtE, which is the third and last approach that I know of, a summary file is generated based on plain text. Then the plaintext and digest file together are encrypted with the key. The ciphertext and ciphertext file are sent together. If we look at real world solutions that use it, first and foremost are SSL/TLS implementations. We all know how reliable and sustainable SSL/TLS applications are in themselves. Beyond that, improvements such as MAC-then-pad-then-encrypt have been made over the years to increase security. According to this improvement, first the plain text is digested, then filled up to the block size, and then the encryption is done. This results in an even more reliable encryption result. But there are cases where the padding mechanism causes attacks like Padding Oracle if it makes certain mistakes.\nhttps://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Date: 08.04.2023) After selecting the AEAD approach to be used, the path shown in the graphic above is followed according to the use of TAP or TUN. According to this path, the action done/desired to be done in the user area goes to TAP/TUN adapters at the kernel level. Because these adapters are at the kernel level, they operate very quickly. Then the virtual adapters do the necessary encryption with the relevant library, add the digest if necessary, and set the packet size. Then the server sends packets sequentially to the client’s Ethernet interface over the Ethernet interface. The client that receives it reconfigures the packages, organizes them, combines them if necessary, and decrypts them with the necessary libraries. After decrypting it, it transmits the client to the end user via the virtual adapter. Thus, as a result of all these mathematical operations and efforts, after a few cycles, the user reached the desired content. It is quite long to explain, but very easy to use, dear readers. You just have to visit the relevant script page on my GitHub page. The related script makes all these adjustments interactively for you. All you have to do is sit back and enjoy.\nFAQ and End Received me via mail, Fosstodon, or GitHub I will try to add questions here from time to time. Thus, historically, you will be able to reach the result directly without thinking about what kind of questions have arisen on which date or whether there is a solution. Apart from this, if there are questions that require extra explanation without changing the technical document, I think to include them in this section.\n","wordCount":"3437","inLanguage":"en","datePublished":"2022-03-27T00:00:00Z","dateModified":"2023-04-11T02:43:18+02:00","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb-works.github.io/blog/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb-works.github.io/blog/en/ accesskey=h title="Wise (Alt + H)">Wise</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb-works.github.io/blog/ title=Turkish aria-label=:tr:>🇹🇷</a></li><li><a href=https://wiseweb-works.github.io/blog/de/ title=Deutsch aria-label=:de:>🇩🇪</a></li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">OpenVPN In-Depth Review</h1><div class=post-meta><span title='2022-03-27 00:00:00 +0000 UTC'>27 March, 2022</span>&nbsp;·&nbsp;<span title='2023-04-11 02:43:18 +0200 +0200'>(Updated 11 April, 2023)</span>&nbsp;·&nbsp;17 min&nbsp;·&nbsp;3437 words&nbsp;·&nbsp;Wise&nbsp;|&nbsp;Translations:<ul class=i18n_list><li><a href=https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/>🇹🇷</a></li><li><a href=https://wiseweb-works.github.io/blog/de/post/openvpn-full-anlatim/>🇩🇪</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/openvpn-full-anlatim.en.md rel="noopener noreferrer" target=_blank>Edit</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction-and-summary aria-label="Introduction and Summary">Introduction and Summary</a><ul><li><a href=#what-is-openvpn-and-what-is-it-used-for aria-label="What is OpenVPN and what is it used for?">What is OpenVPN and what is it used for?</a></li><li><a href=#what-do-we-need-to-establish-an-openvpn-connection aria-label="What do we need to establish an OpenVPN connection?">What do we need to establish an OpenVPN connection?</a><ul><li><a href=#the-settings-file-maintained-by-the-server-contains-the-following-entries aria-label="The settings file maintained by the server contains the following entries">The settings file maintained by the server contains the following entries</a></li><li><a href=#the-client-side-settings-file-contains-the-following-entries aria-label="The client-side settings file contains the following entries">The client-side settings file contains the following entries</a></li></ul></li><li><a href=#what-happens-when-establishing-an-openvpn-connection aria-label="What happens when establishing an OpenVPN connection?">What happens when establishing an OpenVPN connection?</a><ul><li><a href=#the-process-of-establishing-the-tcp-connection aria-label="The process of establishing the TCP connection">The process of establishing the TCP connection</a></li><li><a href=#process-running-in-tls-layer aria-label="Process running in TLS layer">Process running in TLS layer</a></li><li><a href=#process-running-in-the-data-layer aria-label="Process running in the data layer">Process running in the data layer</a></li></ul></li></ul></li><li><a href=#faq-and-end aria-label="FAQ and End">FAQ and End</a></li></ul></div></details></div><div class=post-content><h1 id=introduction-and-summary>Introduction and Summary<a hidden class=anchor aria-hidden=true href=#introduction-and-summary>#</a></h1><p>Today, we will make an in-depth review of OpenVPN, one of the most important software of recent times, in my opinion. In this review, we will first talk about what OpenVPN is used for. Then we will examine what we need to run the program and what needs to be done before the first run. Finally, I will try to explain what goes on in the background from the first moment the connection is started to the last step when the data is decrypted. Therefore, I guess our article will consist of 3 parts and a question-answer section if necessary. Now let&rsquo;s buckle up and take a trip to the deep and gloomy world of the internet.</p><h2 id=what-is-openvpn-and-what-is-it-used-for>What is OpenVPN and what is it used for?<a hidden class=anchor aria-hidden=true href=#what-is-openvpn-and-what-is-it-used-for>#</a></h2><p>Today, there is almost no business that cannot be done online. Even our work, which is not normally online, has evolved to work from home due to the pandemic and the new normal. However, there were big problems both because it is a working method that we are not used to and because our people are not very good with technology. Before it became clear that people needed to connect from their home computers to their office computers, some companies came up with frivolous ideas such as sending office computers to employees&rsquo; homes. They understood very well how wrong this was from the feedback they received in a short time. In short, it was finally accepted that electronic devices should remain in the office and somehow a secure and sustainable connection should be made remotely. Of course, institutions found themselves in such needs before, but such a large-scale situation was not in question back then. Before the pandemic, it used various protocols such as PPTP, L2TP, IPSec, IKev2, SSTP and finally OpenVPN. These are usually abbreviations for certain long and fancy words and their basic logic is to connect two or more devices and make them act as if they are on the same network. I won&rsquo;t talk much, as protocols prior to OpenVPN brought with them certain weaknesses, slowness, and technical difficulties with its implementation. OpenVPN is the name of the protocol and program that allows at least 2 devices in the role of server and client to connect to each other and do this in a way that meets industry standards. I&rsquo;m using a remote desktop program, I seem to hear you say what is the need for this. Unfortunately, he and all other programs like him basically have to use this protocol. If you press the shield icon or the connection details in TeamViewer, one of the most famous, you can see the OpenVPN protocol.</p><h2 id=what-do-we-need-to-establish-an-openvpn-connection>What do we need to establish an OpenVPN connection?<a hidden class=anchor aria-hidden=true href=#what-do-we-need-to-establish-an-openvpn-connection>#</a></h2><p>First of all, OpenVPN must be installed on both the server and client (the device to be connected) side. Then, a settings (config) file should be edited that shows the conditions under which the devices will communicate. The main event is that this config file is generated and used by the client. This config file is divided into server_config used by the server and client_config used by the client.</p><h3 id=the-settings-file-maintained-by-the-server-contains-the-following-entries>The settings file maintained by the server contains the following entries<a hidden class=anchor aria-hidden=true href=#the-settings-file-maintained-by-the-server-contains-the-following-entries>#</a></h3><ul><li><code>port 1194</code> specifies which port it will receive a connection request to make the OpenVPN connection.</li><li><code>proto tcp</code> Connection possible over TCP or UDP. Setting entry entered for selection.</li><li><code>dev tun</code> TAP or TUN interface can be used. These are virtual interfaces. TAP layer 2 establishes a connection, while TUN layer 3 establishes a connection.</li><li><code>user nobody</code> Enables connecting users to an unauthorized user on the server.</li><li><code>group $NOGROUP</code> It allows connecting users to be linked to an unauthorized group on the server as a group.</li><li><code>persist-key</code> An authorization setting for the creation and restart of the virtual interface</li><li><code>persist-tun</code> Also an authorization setting for the creation and restart of the virtual interface</li><li><code>keepalive 10 120</code> A setting for how many connections will be kept active and how long the active connection will be terminated if no communication is established.</li><li><code>ifconfig-pool-persist ipp.txt</code> A setting to keep the IP addresses given by OpenVPN to clients in the virtual network and give them the same addresses if they reconnect</li><li><code>push "dhcp-option DNS 1.1.1.1"</code> A DNS setting for the server to use when exiting the network</li><li><code>compress</code> The part where compression options are set</li><li><code>dh none</code> A setting for turning Diffie-Hellman on or off</li><li><code>ecdh-curve</code> If you are using Elliptic Curve Diffie-Hellman, the setting next to which the curve you need to select is adjusted</li><li><code>dh dh.pem</code> setting specifying the location of the PEM file you need to create beforehand if you are using Diffie-Hellman</li><li><code>tls-crypt tls-crypt.key</code> Required setting to encrypt TLS layer even before pre-shared master</li><li><code>tls-auth tls-auth.key 0</code> setting that allows parties to be authenticated beyond encryption at the pre-handshake stage of the TLS layer</li><li><code>crl-verify crl.pem</code> Setting to check whether the generated certificates are revoked or not via the CRL list</li><li><code>ca ca.crt</code> A setting that reports the location of the certificate of the certificate authority of the generated certificate</li><li><code>cert $SERVER_NAME.crt</code> A setting that tells the location of the server&rsquo;s certificate</li><li><code>key $SERVER_NAME.key</code> A setting indicating the location of the required asymmetric secret key next to the server&rsquo;s certificate</li><li><code>auth $HMAC_ALG</code> A setting describing which hash algorithm to use for the data channel and, if necessary, <code>tls-auth</code></li><li><code>cipher $CIPHER</code> A setting that tells which encryption algorithm to use for the data channel</li><li><code>ncp-ciphers $CIPHER</code> A setting declaring which encryption algorithms the server can use</li><li><code>tls-server</code> A setting that tells the server to use the TLS channel</li><li>A setting <code>tls-version-min 1.2</code> reports the lowest version to be used on the TLS channel</li><li><code>tls-cipher $CC_CIPHER</code> Encryption is also used at TLS layer, except for data channel, which is the setting declaring control channel encryption</li><li><code>client-config-dir /etc/openvpn/ccd</code> Setting that tells where client settings files are kept</li><li><code>status /var/log/openvpn/status.log</code> Setting that tells where status reports are written and where log files are kept</li><li><code>verb 3</code> This setting, which is the abbreviation of the word Verbose, is the setting of how detailed the status report is to be given.</li></ul><h3 id=the-client-side-settings-file-contains-the-following-entries>The client-side settings file contains the following entries<a hidden class=anchor aria-hidden=true href=#the-client-side-settings-file-contains-the-following-entries>#</a></h3><ul><li><code>client</code> indicates that the device is in the client role</li><li><code>proto tcp-client</code> reports to use TCP as protocol</li><li><code>remote $IP $PORT</code> The part where the IP address and Port number of the server(s) to be connected are set</li><li><code>dev tun</code> sets which of the TUN/TAP interfaces to use</li><li><code>resolve-retry infinite</code> We tell you how long to wait if address resolution is delayed due to IP or DNS</li><li><code>nobind</code> setting to not connect to any address in the local</li><li><code>persist-key</code> Allows key files to be read without additional authorization on reboot</li><li><code>persist-tun</code> It also allows the TUN/TAP interface to be woken up without authorization on reboot</li><li><code>remote-cert-tls server</code> Verifies the certificate of the connected server at TLS layer</li><li><code>verify-x509-name $SERVER_NAME name</code> Command that tells the name in the certificate that the server will return to and what the name of the server should be</li><li><code>auth $HMAC_ALG</code> Command that tells which algorithm to use for validation</li><li><code>auth-nocache</code> Does not cache the password required for login</li><li><code>cipher $CIPHER</code> Command to select the algorithm to be used for encryption</li><li><code>tls-client</code> enables TLS during TLS communication and assumes the client role</li><li><code>tls-version-min 1.2</code> Sets the lowest TLS version</li><li><code>tls-cipher $CC_CIPHER</code> selects the encryption algorithm to use in the TLS control channel</li><li><code>ignore-unknown-option block-outside-dns</code> Prevents unknown DNS addresses from being used</li><li><code>setenv opt block-outside-dns</code> blocks DNS leaks for Windows 10</li><li><code>verb 3</code> Determines the degree of reporting</li><li><code>compress</code> Compression algorithm settings are reported here</li><li><code>"&lt;ca>/etc/openvpn/easy-rsa/pki/ca.crt&lt;/ca>"</code> Hard-Coded embedding of expected server certificate authority file</li><li><code>"&lt;cert>/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt&lt;/cert>"</code> Hard-Coded embedding of client certificate file</li><li><code>"&lt;key>/etc/openvpn/easy-rsa/pki/private/$CLIENT.key&lt;/key>"</code> Hard-Coded embedding of client asymmetric secret key</li><li><code>"&lt;tls-crypt>/etc/openvpn/tls-crypt.key&lt;/tls-crypt>"</code> Specifying the key file for TLS crypt</li><li><code>"&lt;tls-auth>/etc/openvpn/tls-auth.key&lt;/tls-auth>"</code> Specifying the key file for TLS auth</li><li><code>key-direction 1</code> assigns roles to client and server for TLS layer encryption (0 and 1)</li></ul><p>You can find detailed documentation of these settings and more on the <a href=https://openvpn.net/community-resources/reference-manual-for-openvpn-2-4/>OpenVPN</a> web page.</p><h2 id=what-happens-when-establishing-an-openvpn-connection>What happens when establishing an OpenVPN connection?<a hidden class=anchor aria-hidden=true href=#what-happens-when-establishing-an-openvpn-connection>#</a></h2><p>Every time I connect with OpenVPN I feel like R2-D2 hijacking their Starfleet plans. People don&rsquo;t always want to find themselves in deep scrutiny and may ask someone to explain to them what and how. In my purpose of writing this article, I actually asked myself this question and I put a lot of effort to get the answer. I don&rsquo;t want you to work so hard, but I can&rsquo;t say that you should upload it immediately, don&rsquo;t think about the rest, it&rsquo;s my job. As I promised at the beginning, I will explain this process to you in depth and leave the decision to you. Here&rsquo;s how the process works in an OpenVPN connection, pros and cons (as I&rsquo;ve been able to figure it out so far). You first establish a TCP/UDP connection. You run a process like any application that uses TCP, and then you switch to the TLS layer. You are doing handshake and some authentication at TLS layer. This layer is also called the control channel. Then a certain communication is fixed and the data channel is passed. The process of encrypting and decrypting the data packets to be sent this time in the data or data channel begins. For this, devices are talking to each other and data is started to be sent under certain common conditions. In short, at the end of the process I have described in this way, the communication we started from 0 ends with the safe and desired data access to us, or requests are sent again, this time in a reverse way, over the connection that is kept open. Thus, a system like nested pipes emerges. If you need to write the only important thing required for the article here:</p><ul><li>It will be <code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512</code>.<ul><li>Here the <code>TLS</code> input specifies that the control channel will be executed over the TLS layer. Other alternatives are <code>SSL</code> or <code>NULL</code>.</li><li>The <code>ECDHE</code> input specifies that the first pre-key will be generated using the Elliptic Diffie-Hellman algorithm. Other alternatives are to use <code>DHE</code>, <code>DH</code> or not.</li><li>The <code>ECDSA</code> data indicates that the Elliptic Digital Signature Certificate Algorithm will be used for mutual authentication and asymmetric key. Another available alternative is <code>RSA</code>. No need to count the others.</li><li>Specifies the encryption algorithm to be used on the <code>AES_256_GCM</code> data channel. Other alternatives are <code>AES-128-CBC</code>, <code>AES-128-GCM</code> and <code>AES-256-CBC</code></li><li><code>SHA384</code> specifies the hash algorithm to use. The other alternative is <code>SHA256</code>.</li><li><code>P512</code> allows the elliptic curve to be used to be selected as Prime-512. Other alternatives are <code>P-256</code> and <code>P-384</code>.</li></ul></li></ul><h3 id=the-process-of-establishing-the-tcp-connection>The process of establishing the TCP connection<a hidden class=anchor aria-hidden=true href=#the-process-of-establishing-the-tcp-connection>#</a></h3><p>Now, if you have an approximate picture of the process in your mind, I start with the explanation of the TCP process. Let&rsquo;s say we have a client and a server in our case, and the connection is just these two. The client sends a SYN (m) packet to the server it wants to connect to. In response, the server sends a SYN (n) packet and an ACK (m+1) packet over the same port. The client that receives this also returns as ACK (n+1) in response, and a 3-way TCP handshake or 3-Way TCP handshake takes place. Thus, we have an open channel between client and server over the specified port.</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.jpg loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://blog.shiftasia.com/what-happen-when-access-website (Date: 08.04.2023)</b></small></center></picture></p><hr><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Date: 08.04.2023)</b></small></center></picture></p><p>As can be seen in the photos, if the process runs smoothly, communication can be made in 3 steps. But if you ask why we are doing this in 3 steps, can&rsquo;t it be done in a shorter way? I would say (for now) no, no, for a full-duplex communication, both parties need to send SYN and ACK packets. Maybe I&rsquo;ll tell you different ways in the future, but for now this is how it is. Anyway, the TCP/UDP part is always short and simple.</p><h3 id=process-running-in-tls-layer>Process running in TLS layer<a hidden class=anchor aria-hidden=true href=#process-running-in-tls-layer>#</a></h3><p>After establishing a communication over TCP, the client is the person who takes the conversation to another level. Clients always request something from the server or request an answer. In general, servers are not seen to respond to a request that did not come to them. The process proceeds according to the principle of demand first, then supply. Yes, the parties are at the TLS layer now. The client first says hello to the server. Not a joke, it&rsquo;s real. The first packet sent by the client is called the <code>Client-Hello</code> packet. Next to this package (in order to speed up the process), the <code>Supported-Chipers</code> package that specifies the encryption algorithms it supports, a randomly generated number by the client, an <code>SNI</code> server name indicator if more than one service is running on the same IP address, and the session ID if necessary. . The server&rsquo;s response to this is, first of all, a polite hello. Because the first packet that the server sends in response is called the <code>Server-Hello</code> packet. Next to this package, the <code>Selected-Chiper</code> package, which specifies the server certificate, the encryption algorithms it supports, and the algorithm it chooses, sends a random number it generates, the Session ID if necessary, and an SNI-like ID if more than one client is connecting over the same IP. . The client first verifies with the server certificate whether it is really the person it is waiting for by starting the communication. In addition, in some cases, the server verifies with a certificate whether the client is one of the clients it expects. If this mutual-authentication process is positive, the next stage is passed. The key generation and exchange process is triggered. At this stage, the client again steps in and says that he wants to change the key with the algorithm they have determined during this communication, which is considered insecure. Parties begin to generate a prekey with Diffie-Hellman or ECDHE. For this, pre-secrets are shared by the client and server. The answers found by performing a number of mathematical operations are sent to the top and the same result is reached by performing mathematical operations again. The result is the first fore-key they&rsquo;ve securely created between them. After that, with the encryption algorithm they determined,
A data channel other than the control channel is created to communicate and the process continues from there.</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Date: 08.04.2023)</b></small></center></picture></p><hr><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b></b></small></center></picture></p><p>As can be seen in the photos, the process is almost the same as when connecting to a web page. Only certain stages are added, removed or changed according to needs. For example, in accordance with PFS, which stands for Advanced Privacy, the parties do not transmit the front-key with the server&rsquo;s asymmetric key. Because in this case, since the same key will be used for each session, the data will be stored and then the data will be readable retrospectively by waiting for a day when the key is revealed. That&rsquo;s why this change was made. Again, in accordance with the zero trust threat model, I want each layer and process to advance the process without trusting the other to do their job correctly. That&rsquo;s why we want the packets to be encrypted according to the <code>tls-auth</code> feature and to verify the integrity of the incoming and outgoing data, even at that first communication moment in the TLS layer. From the first moment you say hello, third parties will not be able to understand what you are talking about and at what stage you are. For this, the first communication is started with a predetermined key(s) and if necessary, these keys are renewed at regular intervals. Thus, even until the first pre-key is created in the TLS layer, confidentiality is not compromised and unauthorized parties are not created in vain.</p><h3 id=process-running-in-the-data-layer>Process running in the data layer<a hidden class=anchor aria-hidden=true href=#process-running-in-the-data-layer>#</a></h3><p>If this whole process has been completed successfully and the data channel has been passed, you have now come to the best part of the job. Data will be encrypted with AES encryption method. During encryption, the tables will be shuffled according to the CBC-GCM counter mode according to your selection, and a 128 or 256-bit encryption key will be used in this process according to your selection. Of course, whatever you choose, the encryption block length will be 128 bits. Only the encryption key length changes. AES-256-GCM that I have chosen for this explanation is an AEAD encryption type. It summarizes the data it sends independently from other channels and processes at a certain stage and sends it together with the summary. Thus, authentication and encryption functions are fulfilled in AEAD, which stands for &lsquo;Authentication Encryption with associated data&rsquo;. There is a problem that requires a distinction to be made here. At what stage and in which order will we use the encryption and hashing algorithms?</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center></th><th></th></tr></thead><tbody><tr><td style=text-align:center><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>Encrypt-then-MAC (EtM)</b></small></center></picture></td><td style=text-align:center><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>Encrypt-and-MAC (E-and-M)</b></small></center></picture></td><td style=text-align:center><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>MAC-then-Encrypt (MtE)</b></small></center></picture></td></tr></tbody></table><blockquote><p><a href=https://en.wikipedia.org/wiki/Authenticated_encryption>https://en.wikipedia.org/wiki/Authenticated_encryption</a> (Date: 08.04.2023)</p></blockquote><ul><li><p>According to EtM, which is the first approach, the data is first encrypted, then encrypted with another key as a result of the digest, and the resulting result is sent together in blocks. If we look at real-world solutions that use it, the IPSec protocol will come to mind first. This is the only method that can achieve the highest security definition in AE, but this can only be achieved if the MAC algorithm used is free of corruption or has not yet been cracked. Various EtM cipher suites are also available for SSHv2. Note, however, that key separation is mandatory for data and digest (different keys must be used for encryption and key hashing), otherwise you may end up with a potentially insecure result depending on the particular encryption method and hash function used.</p></li><li><p>According to the second approach, E&amp;M, plain text data is encrypted and a summary of the encryption state of the plain text data is added next to it. Although only one key is used here, the fact that there are two different results (encryption result and digest result) for the same data clearly shows that the security is not good enough. As a real-world solution using this system, we can cite the first versions of SSH as an example. In order to improve this, methods such as encrypting the sent summary file with the same key were tried.</p></li><li><p>According to MtE, which is the third and last approach that I know of, a summary file is generated based on plain text. Then the plaintext and digest file together are encrypted with the key. The ciphertext and ciphertext file are sent together. If we look at real world solutions that use it, first and foremost are SSL/TLS implementations. We all know how reliable and sustainable SSL/TLS applications are in themselves. Beyond that, improvements such as <code>MAC-then-pad-then-encrypt</code> have been made over the years to increase security. According to this improvement, first the plain text is digested, then filled up to the block size, and then the encryption is done. This results in an even more reliable encryption result. But there are cases where the padding mechanism causes attacks like Padding Oracle if it makes certain mistakes.</p></li></ul><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Date: 08.04.2023)</b></small></center></picture></p><p>After selecting the AEAD approach to be used, the path shown in the graphic above is followed according to the use of TAP or TUN. According to this path, the action done/desired to be done in the user area goes to TAP/TUN adapters at the kernel level. Because these adapters are at the kernel level, they operate very quickly. Then the virtual adapters do the necessary encryption with the relevant library, add the digest if necessary, and set the packet size. Then the server sends packets sequentially to the client&rsquo;s Ethernet interface over the Ethernet interface. The client that receives it reconfigures the packages, organizes them, combines them if necessary, and decrypts them with the necessary libraries. After decrypting it, it transmits the client to the end user via the virtual adapter. Thus, as a result of all these mathematical operations and efforts, after a few cycles, the user reached the desired content. It is quite long to explain, but very easy to use, dear readers. You just have to visit the relevant <a href=https://github.com/wiseweb-works/openvpn-most-secure-install/>script page</a> on my GitHub page. The related script makes all these adjustments interactively for you. All you have to do is sit back and enjoy.</p><h1 id=faq-and-end>FAQ and End<a hidden class=anchor aria-hidden=true href=#faq-and-end>#</a></h1><p>Received me via <a href=mailto:wisewebworks@outlook.com>mail</a>, <a href=https://fosstodon.org/@wise>Fosstodon</a>, or <a href=https://github.com/wiseweb-works>GitHub</a> I will try to add questions here from time to time. Thus, historically, you will be able to reach the result directly without thinking about what kind of questions have arisen on which date or whether there is a solution. Apart from this, if there are questions that require extra explanation without changing the technical document, I think to include them in this section.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb-works.github.io/blog/en/tags/linux/>linux</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/ssl/>ssl</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/security/>security</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/ecc/>ecc</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/elliptic-curve/>elliptic curve</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/openvpn/>openvpn</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/tls/>tls</a></li><li><a href=https://wiseweb-works.github.io/blog/en/tags/aes/>aes</a></li></ul><nav class=paginav><a class=next href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikasi/><span class=title>Next »</span><br><span>Generating ECC SSL Certificate on Linux Server</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wiseweb-works.github.io/blog/en/>Wise</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>