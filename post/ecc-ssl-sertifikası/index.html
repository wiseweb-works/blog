<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux Sunucuda ECC SSL Sertifikası Üretme | Wise</title><meta name=keywords content="linux,ssl,security,ecc,elliptic curve"><meta name=description content="Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.d2177844a571f49d013965b0b32e2898668c816d03a0ac531c4c706a8366ad10.css integrity="sha256-0hd4RKVx9J0BOWWwsy4omGaMgW0DoKxTHExwaoNmrRA=" rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb-works.github.io/blog/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb-works.github.io/blog/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb-works.github.io/blog/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb-works.github.io/blog/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb-works.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=en href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=de href=https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikas%C4%B1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Linux Sunucuda ECC SSL Sertifikası Üretme"><meta property="og:description" content="Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-20T00:00:00+00:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Sunucuda ECC SSL Sertifikası Üretme"><meta name=twitter:description content="Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wiseweb-works.github.io/blog/post/"},{"@type":"ListItem","position":2,"name":"Linux Sunucuda ECC SSL Sertifikası Üretme","item":"https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux Sunucuda ECC SSL Sertifikası Üretme","name":"Linux Sunucuda ECC SSL Sertifikası Üretme","description":"Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let\u0026rsquo;s Encrypt\u0026rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür.","keywords":["linux","ssl","security","ecc","elliptic curve"],"articleBody":"Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let’s Encrypt’in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür. Fakat bu kadar büyük bir anahtarın üretilmesi, ürettikten sonra TLS handshake sırasında kullanılması ve ziyaretçilerin kullandığı cihazlar ile uyumlu olması çoğu senaryoda sorun çıkarmaktadır. Örneğin 2048 bit yerine 4096 bit kullanıldığı zaman bazı denemelerimde 0.4-0.8 sn daha uzun handshake süreleri ile karşı karşıya kalıyorum. Sadece handshake in bu kadar uzaması sorun değilmiş gibi sunucuya da ekstra bir yük bindiriyor. Fakat 4096 bit RSA yerine 384 bit ECC sertifikası ürettiğiniz zaman çok daha hızlı bir sertifikaya sahip olduğunuz gibi aynı zamanda da 7680 bit RSA’ya (öyle bir boyut olsaydı) eşit bir güvenlik elde ediyorsunuz.\nPeki iyi güzel anlattın da bu işin aması nerede dediğinizi duyar gibiyim. Sizi üzeceğim fakat bu işin aması yok. Olmamasının sebebi ise işin arka plandaki matematikte saklı. Kısaca her iki sertifika üretim ve kullanımındaki ufak farklardan bahsedip, bunların nasıl ve neden büyük farklara neden olduğunu açıklayıp son kısımda da bonus olarak başlıkta yazmayan bir şeyden bahsedeceğim. (Sonuna kadar okumanız gerekecek bonus için :D)\nECC Sertifikasının üretim süreci Öncelikle (her zaman olduğu gibi) içinde bulunduğumuz Linux sürümünün paket yöneticisi ile son güncellemeleri konsol üzerinden yüklememiz gerekmektedir.\nUbuntu için: sudo apt update \u0026\u0026 sudo apt upgrade -y\rFedora için: sudo yum update -y\rArch Linux için: sudo pacman -Syyu Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) nginx servisini (ki bu servis dışarıdan HTTP/HTTPS bağlantıları almanıza yarayan servistir) yapılandırmaya başlıyoruz. Öncelikle çok karıştırılması nedeniyle belirtmek gerekir ki apache, nginx ve litespeed servisleri aynı işi yapan farklı servislerdir. Ben yönetimi daha kolay ve topluluk desteği daha çok diye NGINX’i terchi ettim.\nÖzel anahtarı oluşturalım İlk olarak, OpenSSL ile özel anahtarı oluşturuyoruz. Kullanacağımız OpenSSL komutu ecparam (EC parametre manipülasyonu) ve konfigürasyon parametrelerini bu komuta geçirmek için:\nopenssl ecparam -genkey -name secp384r1 -out privkey.pem -genkey seçeneği, OpenSSL’ye bir EC anahtarı oluşturmasını söyler. -name parametresi OpenSSL’ye hangi eğrinin kullanılacağını söyler. -out parametresi OpenSSL’ye çıktıyı bir dosyaya yazmasını söyler. OpenSSL’nin çıktısını varsayılan olarak PEM biçiminde yazdığını unutmayın. EC anahtarlarını işleyen ec komutuyla OpenSSL’nin doğru şeyi yaptığını kontrol edebiliriz:\nopenssl ec -in privkey.pem -noout -text -in girdi dosyasıdır -noout, OpenSSL’ye anahtarı çıkarmamasını söyler, bu da privkey.pem’i stdout’a anlamsızca yazdırır. -text, OpenSSL’ye anahtar hakkındaki bilgileri düz metin biçiminde yazmasını söyler Her şey yolunda giderse ve anahtar doğru şekilde oluşturulduysa, OpenSSL aşağıdakine benzer bir şey gösterecektir:\nread EC key\rPrivate-Key: (384 bit)\rpriv:\r[gizli]\rpub:\r[gizli]\rASN1 OID: secp384r1\rNIST CURVE: P-384 Bu, anahtarın P-384 eğrisi ile oluşturulduğunu doğrular. Neden P-384 yerine P-512 kullanmıyoruz derseniz Let’s Encrypt ekliptik eğrilerde 384 bitten daha yüksek olursa imzalamıyor ve Google Chrome gibi modern tarayıcılar 512 bitlik ekliptik eğrileri kullanan internet sitelerini geçersiz olarak işaretliyor. Kısa cevap bu.\nSertifika için OpenSSL yapılandırması oluşturalım Şimdi TLS sertifikası almak istediğimiz etki alanına özgü parametreleri içeren bir OpenSSL yapılandırma dosyası oluşturmalıyız. Bu örnekte, bir openssl.cnf dosyasına aşağıdaki konfigürasyonu gireceğiz:\n[ req ]\rprompt = no\rencrypt_key = no\rdefault_md = sha512\rdistinguished_name = dname\rreq_extensions = reqext\r[ dname ]\rCN = example.com\remailAddress = admin@example.com\r[ reqext ]\rsubjectAltName = DNS:example.com, DNS:www.example.com Bu yapılandırma seçeneklerinin kısa bir açıklaması:\nGerekli [ req ] bölümünde:\nprompt = no, OpenSSL’ye yapılandırma dosyasından olabildiğince fazla yapılandırma almasını söyler encrypt_key = no, OpenSSL’ye özel anahtarı bir parola ile şifrelememesini söyler. (Şifreli özel anahtarlar Nginx tarafından desteklenir, ancak ben onları kullanmıyorum.) default_md = sha512, OpenSSL’ye CSR’yi SHA512 ile imzalamasını söyler. (Bildiğim kadarıyla, Let’s Encrypt, imzaları için yalnızca SHA256’lı RSA’yı destekler, ancak bu, CSR’de daha güçlü şifreleme kullanamayacağımız anlamına gelmez.) distinguished_name = dname, OpenSSL’ye Ayırt Edici Ad yapılandırma seçenekleri için bir [ dname ] bölümü aramasını söyler. req_extensions = reqext, OpenSSL’ye, Konu Alternatif Adlarının (SAN’lar) yapılandırılmak istenen uzantılar için yapılandırma seçeneklerinde bir [ reqext ] bölümü aramasını söyler. Ayırt Edici Ad [ dname ] bölümünde:\nCN = example.com, sertifikanın Ortak Adını belirtir. emailAddress = admin@example.com e-posta adresiniz belirgin olmalıdır. İstenen Uzantılar [ reqext ] bölümünde, konuAltName, sertifika için SAN’ların listesini sağlar. (Chrome, v58’den itibaren, Ortak Adın SAN’lar listesine dahil edilmesini gerektirir). Let’s Encrypt v2, joker alan adlarını destekler, bu nedenle bu örnekte, apeks dışındaki ana bilgisayarlar için tek düzeyli bir joker karakter kullanabilirsiniz (*.example.com).\nSertifika İmzalama İsteği Oluşturalım İstemci tarafındaki son adım, OpenSSL kullanarak Sertifika İmzalama Talebi oluşturmaktır, ardından bunu imzalamak için Let’s Encrypt’e ileteceğiz ve imzalı sertifikayı geri alacağız.\nBir CSR oluşturmak için gereken OpenSSL komutu req ‘dir.\nopenssl req -new -config openssl.cnf -key privkey.pem -out csr.pem -new, OpenSSL’ye bir CSR oluşturduğumuzu söyler (ve mevcut bir CSR’yi incelemeyiz) -config openssl.cnf, yukarıda oluşturduğumuz yapılandırma dosyasını belirtir -key privkey.pem, yukarıda oluşturduğumuz özel anahtarı belirtir -out csr.pem OpenSSL’ye CSR’yi bir çıktı dosyasına yazmasını söyler (stdout yerine) CSR’yi doğru şekilde oluşturduğumuzu doğrulayabiliriz:\nopenssl req -in csr.pem -noout -text -verify -verify OpenSSL’nin CSR’deki imzayı doğrulamasını ister Bu, çıktıda beklenen şu sonuçları üretmelidir:\nverify OK\rCertificate Request:\rData:\rVersion: 1 (0x0)\rSubject: CN = example.com, emailAddress = admin@example.com\rSubject Public Key Info:\rPublic Key Algorithm: id-ecPublicKey\rPublic-Key: (384 bit)\rpub:\r[gizli]\rASN1 OID: secp384r1\rNIST CURVE: P-384\rAttributes:\rRequested Extensions:\rX509v3 Subject Alternative Name:\rDNS:example.com, DNS:www.example.com\rSignature Algorithm: ecdsa-with-SHA512\r[gizli] Let’s Encrypt’ten sertifikamızı imzalamasını isteyin Son adım, CSR’yi bir ACME istemcisiyle Let’s Encrypt’e imzalaması için göndermektir, bu iş için certbot en yaygın istemcidir.\nCertbot istemcisine iletilen komut satırı seçenekleri, kurulumumuza, alan adımızın kayıtlı olduğu kişiye vb. bağlı olarak değişir. Genellikle certonly komutunu kullanmamız gerekir ve asterisks (*) kullandıysanız certbot DNS eklentilerinden birini kullanmanız gerekir.\nÖrneğin, example.com alan adı Cloudflare’de kayıtlıysa, son derece uygun olan ve sürece manuel müdahale gerektirmeyen doğrulamayı işlemek için ilgili eklentiyi kullanabiliriz. (Cloudflare eklentisini gizli token bilgileriyle yapılandırmak bu makalenin kapsamı dışındadır.)\nHer şeyin yolunda olduğundan emin olmak için önce --dry-run ile düzgün sonuç alınacağından emin olunması genellikle tavsiye edilir.\ncertbot nginx certonly --dry-run --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem Hatalı işlemeleri önlemek için karakterlerin etrafında tırnak işaretleri gereklidir ve genel olarak bunlar iyi bir fikirdir. --csr csr.pem certbot’a zaten bir sertifikamız olduğunu ve bizim için imzalaması için Let’s Encrypt’e ihtiyacımız olduğunu söyler. Certbot istemcisi, komut satırında istenen alan adları listesinin sertifikada listelenen alan adlarıyla eşleşip eşleşmediğini kontrol edecek ve alan adının bize ait olduğunu doğrulamak için Certbot NGINX eklentisini kullanacak ve herhangi bir sorun olup olmadığını bize bildirecektir.\nHiçbir şey yanlış değilse, size şunu söyleyecektir:\nIMPORTANT NOTES:\r- The dry run was successful. Gerçek komut hemen aşağıdaki gibidir:\ncertbot nginx certonly --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem (Uzun) bir gecikmeden sonra, istemci çıktı olarak şunları üretecektir:\nİmzalı sertifika: 0000_cert.pem Kök ve ara sertifikalar: 0000_chain.pem Sertifika + ara ürünler: 0001_chain.pem Bu noktada, CSR csr.pem silinebilir. Merak ediyorsak, x509 komutunu kullanarak istemci tarafından OpenSSL ile döndürülen sertifikaları inceleyebiliriz:\nopenssl x509 -in 0001_chain.pem -noout -text Ne yazık ki, yukarıda açıklandığı gibi Let’s Encrypt’in sertifikamızı bir SHA256 imzasıyla imzaladığını keşfedeceğiz. (Daha güvenli olmasının yanı sıra, SHA512, modern 64-bit CPU’larda SHA256’dan daha iyi performans gösterir.) Ancak açık anahtarımız yine de ECDSA kullanmalıdır.\nBu dosyalar sıradan değildir, bu yüzden onları daha bilgilendirici bir şekilde taşımalı ve düzenlemeliyiz.\nDebian Linux’ta, özel anahtarımı /home/KULLANICI_ADI/SSL/private/example.com/privkey.pem içinde tutarak etki alanlarım için alt dizinler oluşturmayı seviyorum ve sertifikalar:\n/home/KULLANICI_ADI/SSL/certs/example.com/cert.pem /home/KULLANICI_ADI/SSL/certs/example.com/chain.pem /home/KULLANICI_ADI/SSL/certs/example.com/fullchain.pem SON Her şeyi doğru yaptıysak, sertifikayı Chrome gibi bir web tarayıcısı ile incelediğimizde, bunun bir EC sertifikası olduğunu onaylayacaktır:\nMozilla Gözlemevi de bize A+ notu verecek!\nAyrıca SSL Labs’ın rapor sonucunda 384 Bitlik bir ECC sertifikası’nın kullanıldığını görebiliyoruz.\nNOT: Bu yazıda Benjamin Black‘in aynı konulu yazısından faydalanılmıştır.\n","wordCount":"1278","inLanguage":"tr","datePublished":"2022-03-20T00:00:00Z","dateModified":"2022-03-20T00:00:00Z","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikas%C4%B1/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb-works.github.io/blog/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb-works.github.io/blog/ accesskey=h title="Wise (Alt + H)">Wise</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb-works.github.io/blog/en/ title=English aria-label=:gb:>🇬🇧</a></li><li><a href=https://wiseweb-works.github.io/blog/de/ title=Deutsch aria-label=:de:>🇩🇪</a></li></ul></div></div><ul id=menu><li><a href=https://wiseweb-works.github.io/blog/ title=Anasayfa><span>Anasayfa</span></a></li><li><a href=https://wiseweb-works.github.io/blog/post/ title=Blog><span>Blog</span></a></li><li><a href=https://wiseweb-works.github.io/blog/page/iletisim/ title=İletişim><span>İletişim</span></a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ title=Etiketler><span>Etiketler</span></a></li><li><a href=https://wiseweb-works.github.io/blog/archives/ title=Arşiv><span>Arşiv</span></a></li><li><a href=https://wiseweb-works.github.io/blog/search/ title="Ara 🔍"><span>Ara 🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Linux Sunucuda ECC SSL Sertifikası Üretme</h1><div class=post-meta><span title='2022-03-20 00:00:00 +0000 UTC'>20 Mart, 2022</span>&nbsp;·&nbsp;6 dk&nbsp;·&nbsp;1278 kelime&nbsp;·&nbsp;Wise&nbsp;|&nbsp;Çeviriler:<ul class=i18n_list><li><a href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikas%C4%B1/>🇬🇧</a></li><li><a href=https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikas%C4%B1/>🇩🇪</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/ecc-ssl-sertifikas%c4%b1.md rel="noopener noreferrer" target=_blank>Düzenle</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>İçindekiler</span></summary><div class=inner><ul><li><a href=#giri%c5%9f-ve-%c3%b6zet aria-label="Giriş ve Özet">Giriş ve Özet</a><ul><li><a href=#ecc-sertifikas%c4%b1n%c4%b1n-%c3%bcretim-s%c3%bcreci aria-label="ECC Sertifikasının üretim süreci">ECC Sertifikasının üretim süreci</a></li><li><a href=#%c3%b6zel-anahtar%c4%b1-olu%c5%9ftural%c4%b1m aria-label="Özel anahtarı oluşturalım">Özel anahtarı oluşturalım</a></li><li><a href=#sertifika-i%c3%a7in-openssl-yap%c4%b1land%c4%b1rmas%c4%b1-olu%c5%9ftural%c4%b1m aria-label="Sertifika için OpenSSL yapılandırması oluşturalım">Sertifika için OpenSSL yapılandırması oluşturalım</a></li><li><a href=#sertifika-imzalama-iste%c4%9fi-olu%c5%9ftural%c4%b1m aria-label="Sertifika İmzalama İsteği Oluşturalım">Sertifika İmzalama İsteği Oluşturalım</a></li><li><a href=#lets-encryptten-sertifikam%c4%b1z%c4%b1-imzalamas%c4%b1n%c4%b1-isteyin aria-label="Let&amp;rsquo;s Encrypt&amp;rsquo;ten sertifikamızı imzalamasını isteyin">Let&rsquo;s Encrypt&rsquo;ten sertifikamızı imzalamasını isteyin</a></li></ul></li><li><a href=#son aria-label=SON>SON</a></li></ul></div></details></div><div class=post-content><h1 id=giriş-ve-özet>Giriş ve Özet<a hidden class=anchor aria-hidden=true href=#giriş-ve-özet>#</a></h1><p>Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür. Fakat bu kadar büyük bir anahtarın üretilmesi, ürettikten sonra TLS handshake sırasında kullanılması ve ziyaretçilerin kullandığı cihazlar ile uyumlu olması çoğu senaryoda sorun çıkarmaktadır. Örneğin 2048 bit yerine 4096 bit kullanıldığı zaman bazı denemelerimde 0.4-0.8 sn daha uzun handshake süreleri ile karşı karşıya kalıyorum. Sadece handshake in bu kadar uzaması sorun değilmiş gibi sunucuya da ekstra bir yük bindiriyor. Fakat 4096 bit RSA yerine 384 bit ECC sertifikası ürettiğiniz zaman çok daha hızlı bir sertifikaya sahip olduğunuz gibi aynı zamanda da 7680 bit RSA&rsquo;ya (öyle bir boyut olsaydı) eşit bir güvenlik elde ediyorsunuz.</p><p>Peki iyi güzel anlattın da bu işin aması nerede dediğinizi duyar gibiyim. Sizi üzeceğim fakat bu işin aması yok. Olmamasının sebebi ise işin arka plandaki matematikte saklı. Kısaca her iki sertifika üretim ve kullanımındaki ufak farklardan bahsedip, bunların nasıl ve neden büyük farklara neden olduğunu açıklayıp son kısımda da bonus olarak başlıkta yazmayan bir şeyden bahsedeceğim. (Sonuna kadar okumanız gerekecek bonus için :D)</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_240x0_resize_q50_h2_box.webp 240w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_300x0_resize_q50_h2_box.webp 300w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_360x0_resize_q50_h2_box.webp 360w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_420x0_resize_q50_h2_box.webp 420w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_480x0_resize_q50_h2_box.webp 480w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_600x0_resize_q50_h2_box.webp 600w,https://wiseweb-works.github.io/blog/images/key-size-comparison_hu116862e17af7381ac5d24d7d5b0ba692_18192_711x0_resize_q50_h2_box.webp 711w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/key-size-comparison.jpg alt title></div><figcaption></figcaption></figure><h2 id=ecc-sertifikasının-üretim-süreci>ECC Sertifikasının üretim süreci<a hidden class=anchor aria-hidden=true href=#ecc-sertifikasının-üretim-süreci>#</a></h2><p>Öncelikle (her zaman olduğu gibi) içinde bulunduğumuz Linux sürümünün paket yöneticisi ile son güncellemeleri konsol üzerinden yüklememiz gerekmektedir.</p><pre tabindex=0><code>Ubuntu için: sudo apt update &amp;&amp; sudo apt upgrade -y

Fedora için: sudo yum update -y

Arch Linux için: sudo pacman -Syyu
</code></pre><p>Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) nginx servisini (ki bu servis dışarıdan HTTP/HTTPS bağlantıları almanıza yarayan servistir) yapılandırmaya başlıyoruz. Öncelikle çok karıştırılması nedeniyle belirtmek gerekir ki apache, nginx ve litespeed servisleri aynı işi yapan farklı servislerdir. Ben yönetimi daha kolay ve topluluk desteği daha çok diye NGINX&rsquo;i terchi ettim.</p><h2 id=özel-anahtarı-oluşturalım>Özel anahtarı oluşturalım<a hidden class=anchor aria-hidden=true href=#özel-anahtarı-oluşturalım>#</a></h2><p>İlk olarak, OpenSSL ile özel anahtarı oluşturuyoruz. Kullanacağımız OpenSSL komutu <code>ecparam</code> (EC parametre manipülasyonu) ve konfigürasyon parametrelerini bu komuta geçirmek için:</p><pre tabindex=0><code>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</code></pre><ul><li><code>-genkey</code> seçeneği, OpenSSL&rsquo;ye bir EC anahtarı oluşturmasını söyler.</li><li><code>-name</code> parametresi OpenSSL&rsquo;ye hangi eğrinin kullanılacağını söyler.</li><li><code>-out</code> parametresi OpenSSL&rsquo;ye çıktıyı bir dosyaya yazmasını söyler.</li></ul><p>OpenSSL&rsquo;nin çıktısını varsayılan olarak PEM biçiminde yazdığını unutmayın. EC anahtarlarını işleyen <code>ec</code> komutuyla OpenSSL&rsquo;nin doğru şeyi yaptığını kontrol edebiliriz:</p><pre tabindex=0><code>openssl ec -in privkey.pem -noout -text
</code></pre><ul><li><code>-in</code> girdi dosyasıdır</li><li><code>-noout</code>, OpenSSL&rsquo;ye anahtarı çıkarmamasını söyler, bu da privkey.pem&rsquo;i stdout&rsquo;a anlamsızca yazdırır.</li><li><code>-text</code>, OpenSSL&rsquo;ye anahtar hakkındaki bilgileri düz metin biçiminde yazmasını söyler</li></ul><p>Her şey yolunda giderse ve anahtar doğru şekilde oluşturulduysa, OpenSSL aşağıdakine benzer bir şey gösterecektir:</p><pre tabindex=0><code>read EC key
Private-Key: (384 bit)
priv:
    [gizli]
pub:
    [gizli]
ASN1 OID: secp384r1
NIST CURVE: P-384
</code></pre><p>Bu, anahtarın P-384 eğrisi ile oluşturulduğunu doğrular. Neden P-384 yerine P-512 kullanmıyoruz derseniz Let&rsquo;s Encrypt ekliptik eğrilerde 384 bitten daha yüksek olursa imzalamıyor ve Google Chrome gibi modern tarayıcılar 512 bitlik ekliptik eğrileri kullanan internet sitelerini geçersiz olarak işaretliyor. Kısa cevap bu.</p><h2 id=sertifika-için-openssl-yapılandırması-oluşturalım>Sertifika için OpenSSL yapılandırması oluşturalım<a hidden class=anchor aria-hidden=true href=#sertifika-için-openssl-yapılandırması-oluşturalım>#</a></h2><p>Şimdi TLS sertifikası almak istediğimiz etki alanına özgü parametreleri içeren bir OpenSSL yapılandırma dosyası oluşturmalıyız. Bu örnekte, bir <code>openssl.cnf</code> dosyasına aşağıdaki konfigürasyonu gireceğiz:</p><pre tabindex=0><code>[ req ]
prompt = no
encrypt_key = no
default_md = sha512
distinguished_name = dname
req_extensions = reqext

[ dname ]
CN = example.com
emailAddress = admin@example.com

[ reqext ]
subjectAltName = DNS:example.com, DNS:www.example.com
</code></pre><p>Bu yapılandırma seçeneklerinin kısa bir açıklaması:</p><p>Gerekli <code>[ req ]</code> bölümünde:</p><ul><li><code>prompt = no</code>, OpenSSL&rsquo;ye yapılandırma dosyasından olabildiğince fazla yapılandırma almasını söyler</li><li><code>encrypt_key = no</code>, OpenSSL&rsquo;ye özel anahtarı bir parola ile şifrelememesini söyler. (Şifreli özel anahtarlar Nginx tarafından desteklenir, ancak ben onları kullanmıyorum.)</li><li><code>default_md = sha512</code>, OpenSSL&rsquo;ye CSR&rsquo;yi SHA512 ile imzalamasını söyler. (Bildiğim kadarıyla, Let&rsquo;s Encrypt, imzaları için yalnızca SHA256&rsquo;lı RSA&rsquo;yı destekler, ancak bu, CSR&rsquo;de daha güçlü şifreleme kullanamayacağımız anlamına gelmez.)</li><li><code>distinguished_name = dname</code>, OpenSSL&rsquo;ye Ayırt Edici Ad yapılandırma seçenekleri için bir <code>[ dname ]</code> bölümü aramasını söyler.</li><li><code>req_extensions = reqext</code>, OpenSSL&rsquo;ye, Konu Alternatif Adlarının (SAN&rsquo;lar) yapılandırılmak istenen uzantılar için yapılandırma seçeneklerinde bir <code>[ reqext ]</code> bölümü aramasını söyler.</li></ul><p>Ayırt Edici Ad <code>[ dname ]</code> bölümünde:</p><ul><li><code>CN = example.com</code>, sertifikanın Ortak Adını belirtir.</li><li><code>emailAddress = admin@example.com</code> e-posta adresiniz belirgin olmalıdır.
İstenen Uzantılar <code>[ reqext ]</code> bölümünde, konuAltName, sertifika için SAN&rsquo;ların listesini sağlar. (Chrome, v58&rsquo;den itibaren, Ortak Adın SAN&rsquo;lar listesine dahil edilmesini gerektirir).</li></ul><p>Let&rsquo;s Encrypt v2, joker alan adlarını destekler, bu nedenle bu örnekte, apeks dışındaki ana bilgisayarlar için tek düzeyli bir joker karakter kullanabilirsiniz (*.example.com).</p><h2 id=sertifika-imzalama-isteği-oluşturalım>Sertifika İmzalama İsteği Oluşturalım<a hidden class=anchor aria-hidden=true href=#sertifika-imzalama-isteği-oluşturalım>#</a></h2><p>İstemci tarafındaki son adım, OpenSSL kullanarak Sertifika İmzalama Talebi oluşturmaktır, ardından bunu imzalamak için Let&rsquo;s Encrypt&rsquo;e ileteceğiz ve imzalı sertifikayı geri alacağız.</p><p>Bir CSR oluşturmak için gereken OpenSSL komutu <code>req</code> &lsquo;dir.</p><pre tabindex=0><code>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</code></pre><ul><li><code>-new</code>, OpenSSL&rsquo;ye bir CSR oluşturduğumuzu söyler (ve mevcut bir CSR&rsquo;yi incelemeyiz)</li><li><code>-config</code> openssl.cnf, yukarıda oluşturduğumuz yapılandırma dosyasını belirtir</li><li><code>-key privkey.pem</code>, yukarıda oluşturduğumuz özel anahtarı belirtir</li><li><code>-out csr.pem</code> OpenSSL&rsquo;ye CSR&rsquo;yi bir çıktı dosyasına yazmasını söyler (stdout yerine)</li></ul><p>CSR&rsquo;yi doğru şekilde oluşturduğumuzu doğrulayabiliriz:</p><pre tabindex=0><code>openssl req -in csr.pem -noout -text -verify
</code></pre><ul><li><code>-verify</code> OpenSSL&rsquo;nin CSR&rsquo;deki imzayı doğrulamasını ister</li></ul><p>Bu, çıktıda beklenen şu sonuçları üretmelidir:</p><pre tabindex=0><code>verify OK
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: CN = example.com, emailAddress = admin@example.com
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    [gizli]
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:example.com, DNS:www.example.com
    Signature Algorithm: ecdsa-with-SHA512
         [gizli]
</code></pre><h2 id=lets-encryptten-sertifikamızı-imzalamasını-isteyin>Let&rsquo;s Encrypt&rsquo;ten sertifikamızı imzalamasını isteyin<a hidden class=anchor aria-hidden=true href=#lets-encryptten-sertifikamızı-imzalamasını-isteyin>#</a></h2><p>Son adım, CSR&rsquo;yi bir ACME istemcisiyle Let&rsquo;s Encrypt&rsquo;e imzalaması için göndermektir, bu iş için <code>certbot</code> en yaygın istemcidir.</p><p><code>Certbot</code> istemcisine iletilen komut satırı seçenekleri, kurulumumuza, alan adımızın kayıtlı olduğu kişiye vb. bağlı olarak değişir. Genellikle <code>certonly</code> komutunu kullanmamız gerekir ve asterisks (*) kullandıysanız certbot DNS eklentilerinden birini kullanmanız gerekir.</p><p>Örneğin, <code>example.com</code> alan adı Cloudflare&rsquo;de kayıtlıysa, son derece uygun olan ve sürece manuel müdahale gerektirmeyen doğrulamayı işlemek için ilgili eklentiyi kullanabiliriz. (Cloudflare eklentisini gizli token bilgileriyle yapılandırmak bu makalenin kapsamı dışındadır.)</p><p>Her şeyin yolunda olduğundan emin olmak için önce <code>--dry-run</code> ile düzgün sonuç alınacağından emin olunması genellikle tavsiye edilir.</p><pre tabindex=0><code>certbot nginx certonly --dry-run --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><ul><li>Hatalı işlemeleri önlemek için karakterlerin etrafında tırnak işaretleri gereklidir ve genel olarak bunlar iyi bir fikirdir.</li><li><code>--csr csr.pem</code> certbot&rsquo;a zaten bir sertifikamız olduğunu ve bizim için imzalaması için Let&rsquo;s Encrypt&rsquo;e ihtiyacımız olduğunu söyler.</li></ul><p>Certbot istemcisi, komut satırında istenen alan adları listesinin sertifikada listelenen alan adlarıyla eşleşip eşleşmediğini kontrol edecek ve alan adının bize ait olduğunu doğrulamak için Certbot NGINX eklentisini kullanacak ve herhangi bir sorun olup olmadığını bize bildirecektir.</p><p>Hiçbir şey yanlış değilse, size şunu söyleyecektir:</p><pre tabindex=0><code>IMPORTANT NOTES:
 - The dry run was successful.
</code></pre><p>Gerçek komut hemen aşağıdaki gibidir:</p><pre tabindex=0><code>certbot nginx certonly --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><p>(Uzun) bir gecikmeden sonra, istemci çıktı olarak şunları üretecektir:</p><ol><li>İmzalı sertifika: <code>0000_cert.pem</code></li><li>Kök ve ara sertifikalar: <code>0000_chain.pem</code></li><li>Sertifika + ara ürünler: <code>0001_chain.pem</code>
Bu noktada, CSR <code>csr.pem</code> silinebilir.</li></ol><p>Merak ediyorsak, <code>x509</code> komutunu kullanarak istemci tarafından OpenSSL ile döndürülen sertifikaları inceleyebiliriz:</p><pre tabindex=0><code>openssl x509 -in 0001_chain.pem -noout -text
</code></pre><p>Ne yazık ki, yukarıda açıklandığı gibi Let&rsquo;s Encrypt&rsquo;in sertifikamızı bir SHA256 imzasıyla imzaladığını keşfedeceğiz. (Daha güvenli olmasının yanı sıra, SHA512, modern 64-bit CPU&rsquo;larda SHA256&rsquo;dan daha iyi performans gösterir.) Ancak açık anahtarımız yine de ECDSA kullanmalıdır.</p><p>Bu dosyalar sıradan değildir, bu yüzden onları daha bilgilendirici bir şekilde taşımalı ve düzenlemeliyiz.</p><p>Debian Linux&rsquo;ta, özel anahtarımı <code>/home/KULLANICI_ADI/SSL/private/example.com/privkey.pem</code> içinde tutarak etki alanlarım için alt dizinler oluşturmayı seviyorum ve sertifikalar:</p><ul><li><code>/home/KULLANICI_ADI/SSL/certs/example.com/cert.pem</code></li><li><code>/home/KULLANICI_ADI/SSL/certs/example.com/chain.pem</code></li><li><code>/home/KULLANICI_ADI/SSL/certs/example.com/fullchain.pem</code></li></ul><h1 id=son>SON<a hidden class=anchor aria-hidden=true href=#son>#</a></h1><p>Her şeyi doğru yaptıysak, sertifikayı Chrome gibi bir web tarayıcısı ile incelediğimizde, bunun bir EC sertifikası olduğunu onaylayacaktır:</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_240x0_resize_q50_h2_box_3.webp 240w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_300x0_resize_q50_h2_box_3.webp 300w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_360x0_resize_q50_h2_box_3.webp 360w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_420x0_resize_q50_h2_box_3.webp 420w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_480x0_resize_q50_h2_box_3.webp 480w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_600x0_resize_q50_h2_box_3.webp 600w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_768x0_resize_q50_h2_box_3.webp 768w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_800x0_resize_q50_h2_box_3.webp 800w,https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome_hudc69a2051f83339f6a978d99b5875e0c_18051_854x0_resize_q50_h2_box_3.webp 854w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/ecc-sll-key-chrome.png alt title></div><figcaption></figcaption></figure><p>Mozilla Gözlemevi de bize A+ notu verecek!</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_240x0_resize_q50_h2_box_3.webp 240w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_300x0_resize_q50_h2_box_3.webp 300w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_360x0_resize_q50_h2_box_3.webp 360w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_420x0_resize_q50_h2_box_3.webp 420w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_480x0_resize_q50_h2_box_3.webp 480w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_600x0_resize_q50_h2_box_3.webp 600w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_768x0_resize_q50_h2_box_3.webp 768w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_800x0_resize_q50_h2_box_3.webp 800w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla_huf48d19e76be255dd9b8b8436e32b4e2a_24210_880x0_resize_q50_h2_box_3.webp 880w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/ecc-ssl-key-mozilla.png alt title></div><figcaption></figcaption></figure><p>Ayrıca SSL Labs&rsquo;ın rapor sonucunda 384 Bitlik bir ECC sertifikası&rsquo;nın kullanıldığını görebiliyoruz.</p><figure><div class=img-box><img srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_240x0_resize_q50_h2_box_3.webp 240w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_300x0_resize_q50_h2_box_3.webp 300w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_360x0_resize_q50_h2_box_3.webp 360w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_420x0_resize_q50_h2_box_3.webp 420w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_480x0_resize_q50_h2_box_3.webp 480w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_600x0_resize_q50_h2_box_3.webp 600w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_768x0_resize_q50_h2_box_3.webp 768w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_800x0_resize_q50_h2_box_3.webp 800w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_960x0_resize_q50_h2_box_3.webp 960w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1024x0_resize_q50_h2_box_3.webp 1024w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1080x0_resize_q50_h2_box_3.webp 1080w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1200x0_resize_q50_h2_box_3.webp 1200w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1366x0_resize_q50_h2_box_3.webp 1366w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1440x0_resize_q50_h2_box_3.webp 1440w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1920x0_resize_q50_h2_box_3.webp 1920w,https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs_hue1dd864f2b55004f331c8404d9e3065d_77860_1994x0_resize_q50_h2_box_3.webp 1994w" sizes="(max-width: 200px) 240px 300px 360px 420px,
      (max-width: 400px) 200px 240px 300px 360px 420px 480px 600px 768px 800px,
      (max-width: 600px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px,
      (max-width: 800px) 200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      (max-width: 1000px)200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px,
      200px 240px 300px 360px 420px 480px 600px 768px 800px 960px 1024px 1080px 1200px 1366px 1440px 1920px 100vw" src=https://wiseweb-works.github.io/blog/images/ecc-ssl-key-ssllabs.png alt title></div><figcaption></figcaption></figure><p>NOT: Bu yazıda <a href=https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc>Benjamin Black</a>&lsquo;in aynı konulu yazısından faydalanılmıştır.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb-works.github.io/blog/tags/linux/>linux</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ssl/>ssl</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/security/>security</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ecc/>ecc</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/elliptic-curve/>elliptic curve</a></li></ul><nav class=paginav><a class=prev href=https://wiseweb-works.github.io/blog/post/openvpn-full-anlat%C4%B1m/><span class=title>« Önceki</span><br><span>OpenVPN Derinlemesine Anlatım</span></a>
<a class=next href=https://wiseweb-works.github.io/blog/post/ssl-konfigurasyonu/><span class=title>Sonraki »</span><br><span>Linux Sunucularda SSL güvenliğini arttırma</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wiseweb-works.github.io/blog/>Wise</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Kopyala";function s(){t.innerHTML="Kopyalandı!",setTimeout(()=>{t.innerHTML="Kopyala"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>