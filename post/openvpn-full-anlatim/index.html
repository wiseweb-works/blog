<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenVPN Derinlemesine Anlatım | Wise</title>
<meta name=keywords content="linux,ssl,security,ecc,elliptic curve,openvpn,tls,aes"><meta name=description content="Giriş ve Özet Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN&rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.1dc5045524874cb6405eec9368359dbbf2b48c56f110d6815cb53713394d9397.css integrity="sha256-HcUEVSSHTLZAXuyTaDWdu/K0jFbxENaBXLU3EzlNk5c=" rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb-works.github.io/blog/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb-works.github.io/blog/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb-works.github.io/blog/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb-works.github.io/blog/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb-works.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/><link rel=alternate hreflang=en href=https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/><link rel=alternate hreflang=de href=https://wiseweb-works.github.io/blog/de/post/openvpn-full-anlatim/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="OpenVPN Derinlemesine Anlatım"><meta property="og:description" content="Giriş ve Özet Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN&rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-27T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-11T02:43:18+02:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="OpenVPN Derinlemesine Anlatım"><meta name=twitter:description content="Giriş ve Özet Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN&rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wiseweb-works.github.io/blog/post/"},{"@type":"ListItem","position":2,"name":"OpenVPN Derinlemesine Anlatım","item":"https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenVPN Derinlemesine Anlatım","name":"OpenVPN Derinlemesine Anlatım","description":"Giriş ve Özet Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN\u0026rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak.","keywords":["linux","ssl","security","ecc","elliptic curve","openvpn","tls","aes"],"articleBody":"Giriş ve Özet Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN’in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak. Şimdi kemerlerimizi bağlayalım ve internetin derin ve kasvetli dünyasında bir geziye çıkalım.\nOpenVPN nedir ve ne için kullanılıyor ? Günümüzde artık internet üzerinden yapılmayan bir iş neredeyse kalmadı. Hatta normalde internet üzerinden olmayan çalışma eylemimiz bile pandemi ve yeni normal nedeniyle evden çalışmaya doğru evrildi. Fakat hem alışık olmadığımız bir çalışma yöntemi olması nedeniyle hem de insanlarımızın teknoloji ile arasının pek iyi olmaması nedeniyle büyük sorunlar yaşandı. İnsanların evlerindeki bilgisayarlardan ofisteki bilgisayarlarına bağlanması gerektiği anlaşılmadan önce bazı firmalar çalışanların evlerine ofis bilgisayarlarını gönderme gibi uçuk fikirler buldu. Bunun ne kadar hatalı bir gidiş yolu olduğunu kısa süre içinde aldıkları geri dönüşlerden çok iyi anladılar. Kısaca elektronik cihazların ofiste kalması ve bir şekilde uzaktan güvenli ve sürdürülebilir bir bağlantı yapılması gerektiği sonunda kabullenildi. Kurumlar daha önceleri de kendilerini böyle ihtiyaçlar içinde buluyordu elbette ama bu derece büyük ölçekli bir durum söz konusu değildi o zamanlar. Pandemi öncesinde PPTP, L2TP, IPSec, IKev2, SSTP ve nihayet OpenVPN gibi çeşitli protokoller kullanıyordu. Bunlar genelde belirli uzun ve havalı kelimelerin kısaltması olup temel mantıkları iki veya daha fazla cihazı birbirine bağlamak ve aynı ağdaymış gibi hareket etmelerini sağlamak üzerinedir. OpenVPN’den önceki protokoller belirli zayıflıkları, yavaşlıkları ve uygulanmasıyla ilgili teknik zorlukları da beraberlerinde getirdikleri için çok bahsetmeyeceğim. OpenVPN sunucu ve istemci rolündeki en az 2 cihazın birbirlerine bağlanması ve bunu endüstiri standartlarını karşılayacak şekilde yapmasına yarayan protokol ve programın adıdır. Ben uzak masaüstü programı kullanıyorum buna ne gerek var dediğinizi duyar gibiyim. Maalesef o ve onun gibi diğer tüm programlar temelde bu protokolü kullanmak durumunda kalıyorlar. En meşhurlarından olan TeamViewer programında kalkan simgesine veya bağlantı ayrıntılarına bastığınız takdirde OpenVPN protokolünü görebilirsiniz.\nOpenVPN bağlantısı kurmak için nelere ihtiyaç duyarız ? Öncelikle hem sunucu hem de istemci (bağlanacak cihaz) tarafında OpenVPN’in kurulu olması gerekiyor. Ardından cihazların hangi şartlar altında iletişim kuracaklarını gösterir bir ayar (config) dosyasının düzenlenmesi gerekmektedir. Asıl olay zaten bu config dosyasının üretilmesi ve istemci tarafından kullanılmasıdır. Bu config dosyası sunucu tarafından kullanılan server_config ve istemci tarafından kullanılan client_config olarak ikiye ayrılır.\nServer tarafında tutulan ayar dosyası şu girdileri içermektedir port 1194 OpenVPN bağlantısını yapmak için kendisine hangi port üzerinden bağlantı talebi geleceğini belirtir. proto tcp Bağlantının TCP veya UDP üzerinden yapılması mümkün. Seçim için girilen ayar girdisi. dev tun TAP veya TUN arabirimi kullanılabilir. Bunlar sanal arabirimlerdir. TAP layer 2 bir bağlantı kurarken TUN layer 3 bir bağlantı kurar. user nobody Bağlanan kullanıcıların sunucu üzerinde yetkisiz bir kullanıcıya linklenmesini sağlıyor. group $NOGROUP Bağlanan kullanıcıların sunucu üzerinde grup olarak da yetkisiz bir gruba linklenmesini sağlıyor. persist-key Sanal arabirimin oluşturulması ve yeniden başlatılması ile ilgili bir yetkilendirme ayarı persist-tun Yine aynı şekilde sanal arabirimin oluşturulması ve yeniden başlatılması ile ilgili bir yetkilendirme ayarı keepalive 10 120 Kaç adet bağlantının aktif tutulacağını ve ne kadar süre iletişim kurulmaz ise aktif bağlantının sonlandırılacağı ile ilgili bir ayar ifconfig-pool-persist ipp.txt OpenVPN tarafından istemcilere sanal ağda verilen IP adreslerinin tutulması ve tekrar bağlandıkları takdirde aynı adreslerin verilmesi için bir ayar push \"dhcp-option DNS 1.1.1.1\" Sunucunun ağa çıkarken kullanması için bir DNS ayarı compress Sıkıştırma seçeneklerinin ayarlandığı kısım dh none Diffie-Hellman’ın açılıp kapatılması ile ilgili bir ayar ecdh-curve Eğer Elliptik Eğri Diffie-Hellman kullanıyor iseniz yanında seçmeniz gereken eğrinin ayarlandığı ayar dh dh.pem Diffie-Hellman kullanıyor iseniz önceden oluşturmanız gereken PEM dosyasının konumunu belirten ayar tls-crypt tls-crypt.key TLS katmanının pre-shared master öncesinde dahi şifrelenmesi için gerekli ayar tls-auth tls-auth.key 0 TLS katmanının pre-handshake aşamasında şifrelenmesinin de ötesinde tarafların da doğrulanmasını sağlayan ayar crl-verify crl.pem Üretilen sertifikaların revoke edilip edilmediğinin CRL listesi üzerinden kontrol edilmesine yarayan ayar ca ca.crt Üretilen sertifikaya ait sertifika otoritesinin sertifikasının konumunu bildiren bir ayar cert $SERVER_NAME.crt Sunucunun sertifikasının konumunu bildiren bir ayar key $SERVER_NAME.key Sunucunun sertifikasının yanında yine gerekli olan asimetrik secret keyinin konumunu bildiren bir ayar auth $HMAC_ALG Veri kanalı ve gerekirse tls-auth için hangi özet algoritmasının kullanılacağını bildiren bir ayar cipher $CIPHER Veri kanalı için hangi şifreleme algoritmasının kullanılacağını bildiren bir ayar ncp-ciphers $CIPHER Sunucunun kullanabileceği şifreleme algoritmalarını bildiren bir ayar tls-server Sunucunun TLS kanalını kullanmasını söyleyen bir ayar tls-version-min 1.2 TLS kanalında kullanılması için en düşük versiyonu bildiren bir ayar tls-cipher $CC_CIPHER Veri kanalından hariç TLS katmanında da şifreleme kullanılıyor bu da kontrol kanalı şifrelemesini bildiren ayar client-config-dir /etc/openvpn/ccd İstemci ayar dosyalarının tutulduğu konumu bildiren ayar status /var/log/openvpn/status.log Durum raporlarının yazılacağı konumu ve log dosyalarının tutulduğu konumu bildiren ayar verb 3 Verbose kelimesinin kısaltılmışı olan bu ayar ne kadar detaylı durum raporu verileceğinin ayarıdır. İstemci tarafında tutulan ayar dosyası şu girdileri içermektedir client İlgili cihazın istemci rolünde olduğunu belirtiyor proto tcp-client Protokol olarak TCP’nin kullanılacağını bildiriyor remote $IP $PORT Bağlanılacak sunucu(ların) IP adresinin ve Port numarasının ayarladığı kısım dev tun TUN/TAP arabirimlerinden hangisinin kullanılacağını ayarlıyor resolv-retry infinite Eğer IP veya DNS nedeniyle adres çözümlemesi gecikir ise ne kadar süre ile bekleyeceğini söylüyoruz nobind Lokaldeki herhangi bir adrese bağlanılmamasını bildiren ayar persist-key Yeniden başlatma durumunda anahtar dosyalarının ek bir yetkiye gerek kalmadan okunabilmesini yarar persist-tun Aynı şekilde yeniden başlatma durumunda TUN/TAP arabiriminin yetkiye gerek kalmadan uyandırılabilmesine yarar remote-cert-tls server Bağlanılan sunucunun sertifikasını TLS katmanında doğrulanmasını sağlar verify-x509-name $SERVER_NAME name Sunucunun geri döneceği sertifikasındaki ismi ve sunucunun isminin ne olması gerektiğini bildiren komut auth $HMAC_ALG Doğrulama için hangi algoritmanın kullanılacağını bildiren komut auth-nocache Oturum açmak için gerekli parolayı önbelleğe almaz cipher $CIPHER Şifreleme için kullanılacak algoritmayı seçmeye yarayan komut tls-client TLS iletişimi sırasında TLS’yi etkinleştirir ve istemci rolünü üstlenir tls-version-min 1.2 En düşük TLS versiyonunu ayarlar tls-cipher $CC_CIPHER TLS kontrol kanalında kullanılacak şifreleme algoritmasını seçer ignore-unknown-option block-outside-dns Bilinmeyen DNS adreslerinin kullanılmasını engeller setenv opt block-outside-dns Windows 10 için DNS sızıntılarını engeller verb 3 Rapor verme derecesini belirler compress Sıkıştırma algoritması ayarları burada bildirilir \"/etc/openvpn/easy-rsa/pki/ca.crt\" Beklenilen sunucu sertifika otoritesi dosyasının Hard-Coded gömülmesi \"/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt\" İstemci sertifika dosyasının Hard-Coded gömülmesi \"/etc/openvpn/easy-rsa/pki/private/$CLIENT.key\" İstemci asimetrik secret keyinin Hard-Coded gömülmesi \"/etc/openvpn/tls-crypt.key\" TLS crypt için key dosyasının belirtilmesi \"/etc/openvpn/tls-auth.key\" TLS auth için key dosyasının belirtilmesi key-direction 1 TLS katmanı şifrelenmesi için istemci ve sunucuya rol atıyor (0 ve 1 şeklinde) Bu ayarları ve daha bir çoğunun ayrıntılı dökümantasyonunu OpenVPN web sayfasında bulabilirsiniz.\nOpenVPN bağlantısı kurulurken neler oluyor ? OpenVPN ile bağlantı kurduğum her zaman kendimi Yıldız Filosu planlarını kaçıran R2-D2 gibi hissediyorum. İnsanlar kendilerini her zaman için derinlemesine bir inceleme içerisinde bulmak istemiyorlar ve birilerinin onlara neyin nasıl döndüğünü açıklamalarını isteyebiliyorlar. Benim bu yazıyı kaleme alma amacımda aslında bu soruyu kendime sormuş olmam ve cevabını almak için çok çaba sarfetmiş olmam. Sizin de bu kadar uğraşmanızı istemem fakat size hemencecik bunu yükle gerisini düşünme o iş bende de diyemem. Başta söz verdiğim gibi derinlemesine bir şekilde bu süreci sizlere anlatacağım ve kararı size bırakacağım. Bir OpenVPN bağlantısında artısıyla eksisiyle (benim şu ana kadar çözebildiğim şekliyle) süreç şöyle işliyor. Önce bir TCP/UDP bağlantısı kuruyorsunuz. TCP kullanan her uygulama gibi bir süreç yürütüyorsunuz ve ardından TLS katmanına geçiyorsunuz. TLS katmanında el sıkışma (handshake) ve bazı kimlik doğrulama işlemleri yapıyorsunuz. Bu katmana aynı zamanda kontrol kanalı da deniliyor. Ardından belirli bir iletişim tutturulmuş oluyor ve veri kanalına geçiliyor. Veri veya data kanalında bu sefer gönderilecek veri paketlerinin şifrelenmesi ve çözülmesi süreci başlıyor. Bunun için yine cihazlar birbirleri ile konuşuyor ve belirli ortak şartlar altında veriler gönderilmeye başlanıyor. Kısaca bu şekilde anlattığım sürecin sonunda 0’dan başlattığımız iletişim bize güvenli ve istediğimiz şekilde verilerin ulaşması ile son buluyor veya açık tutulan bağlantı üzerinden bu sefer tersine bir yolla yeniden istekler iletiliyor. Böylece iç içe borular gibi bir sistem ortaya çıkıyor. Yazı için gerekli olan tek önemli şeyi buraya yazmak gerekirse eğer:\nTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512 şeklinde olacaktır. Burada TLS girdisi kontrol kanalının TLS katmanı üzerinden yürütüleceğini belirtir. Diğer alternatifler SSL veya NULL‘dur. ECDHE girdisi Elliptik Diffie-Hellman algoritması kullanılarak ilk ön-anahtarın üretileceğini belirtir. Diğer alternatifler DHE, DH veya kullanmamaktır. ECDSA verisi karşılıklı kimlik doğrulama ve asimetrik anahtar için Elliptik Dijital İmza Sertifikası Algoritmasının kullanılacağını belirtir. Diğer kullanılabilir alternatif RSA‘dır. Diğerlerini saymaya gerek bile yok. AES_256_GCM veri kanalında kullanılacak şifreleme algoritmasının belirtir. Diğer alternatifler AES-128-CBC, AES-128-GCM ve AES-256-CBC‘dir SHA384 kullanılacak özet algoritmasını belirtir. Diğer alternatif SHA256‘dır. P512 ise kullanılacak elliptik eğrinin Prime-512 adlı eğri olarak seçilmesini sağlar. Diğer alternatifler P-256 ve P-384‘dür. TCP bağlantısının kurulması süreci Şimdi kafanızda sürecin yaklaşık bir resmi oluştu ise başlangıcı TCP sürecinin anlatımıyla yapıyorum. Olayımızda bir istemci ve bir sunucunun olduğunu ve bağlantının sadece bu ikisinden ibaret olduğunu düşünelim. İstemci bağlanmak istediği sunucuya bir SYN (m) paketi gönderir. Sunucu ise buna cevap olarak aynı port üzerinden bir SYN (n) paketi ve ACK (m+1) paket gönderir. Bunu alan istemci de cevap olarak ACK (n+1) şeklinde dönüş yapar ve 3’lü TCP el sıkışması veya 3 Way TCP handshake gerçekleşmiş olur. Böylece belirtilen port üzerinden istemci ve sunucu arasında açık bir kanalımız oluştu.\nhttps://blog.shiftasia.com/what-happen-when-access-website (Erişim Tarihi: 08.04.2023) https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Erişim Tarihi: 08.04.2023) Fotoğraflarda da görüleceği üzere eğer süreç sorunsuz işler ise 3 adımda iletişim kurulabiliyor. Fakat neden 3 adımda bu işi yapıyoruz daha kısa şekilde olmaz mı derseniz size (şimdilik) hayır olmaz full-duplex bir iletişim için her iki tarafın da SYN ve ACK paketlerini göndermesi gerekiyor derim. İleride belki farklı yollarını da anlatırım ama şimdilik böyle. Zaten işin TCP/UDP kısmı her zaman için kısa ve basittir.\nTLS katmanındaki işletilen süreç TCP üzerinden bir iletişim kurulmasının ardından yine muhabbeti başka bir aşamaya taşıyan kişi istemci oluyor. Her zaman için istemciler sunucudan bir şeyler talep eder veya bir cevap ister. Sunucular genel olarak kendilerine gelmeyen bir isteği cevapladığı çok görülmemiştir. Önce talep sonra arz ilkesine göre süreç ilerler. Evet, taraflar TLS katmanındalar şimdi. İstemci sunucuya önce bir merhaba diyor. Şaka değil gerçek. İstemci tarafından gönderilen ilk pakete Client-Hello paketi denir. Bu paketin yanında (süreci hızlandırmak adına) desteklediği şifreleme algoritmalarını belirten Supported-Chipers paketi, istemci tarafından rastgele üretilmiş bir sayı, aynı IP adresinde birden fazla hizmet çalıştırılıyor ise bir SNI sunucu adı indikatörü ve yine gerekiyor ise oturum ID’si gönderilir. Sunucunun buna cevabı ise öncelikle kibar bir merhaba demek oluyor. Çünkü sunucunun cevaben gönderdiği ilk pakete de Server-Hello paketi denir. Bu paketin yanında sunucu sertifikasını, kendi desteklediği şifreleme algoritmalarını ve seçtiği algoritmayı belirten Selected-Chiper paketi, kendisinin ürettiği rastgele bir sayıyı, gerekirse Oturum ID’sini ve aynı IP üzerinden birden fazla istemci bağlanıyor ise buna ilişkin SNI benzeri bir ID’yi gönderir. İstemci öncelikle iletişime başladığı tarafından gerçekten beklediği kişi olup olmadığını sunucu sertifikası ile doğrular. Ayrıca bazı durumlarda da sunucu istemcinin beklediği istemcilerden biri olup olmadığını yine sertifika ile doğrular. Eğer bu karşılıklı doğrulama (mutual-authentication) süreci olumlu sonuçlanır ise bir sonraki aşamaya geçilir. Anahtar üretim ve değişim süreci tetiklenmiş olur. Bu aşamda yine istemci devreye girer ve güvensiz önkabul edilen bu iletişim sırasında belirledikleri algoritma ile anahtar değiştirmek istediğini söyler. Taraflar Diffie-Hellman veya ECDHE ile bir önanahtar oluşturmaya başlarlar. Bunun için istemci ve sunucu tarafından ön-sırlar paylaşılır. Bir takım matematiksel işlemler yapılarak bulunan cevaplar karşıya gönderilir ve tekrar matematiksel işlemler yapılarak aynı sonuca ulaşılır. İşte ulaşılan sonuç aralarında güvenli bir şekilde oluşturdukları ilk ön-anahtar oluyor. Bundan sonra belirledikleri şifreleme algoritması ile iletişime geçmek için kontrol kanalından hariç bir veri kanalı oluşturulur ve süreç oradan devam eder.\nhttps://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Erişim Tarihi: 08.04.2023) Fotoğraflarda da görülebileceği üzere süreç bir web sayfasına bağlanılırken yaşanan süreçle neredeyse aynı. Sadece ihtiyaçlara göre belirli aşamalar ekleniyor, çıkarılıyor veya değiştiriliyor. Örneğin İleri Seviye Gizlilik anlamına gelen PFS gereğince taraflar ön-anahtarı sunucunun asimetrik anahtarı ile iletmiyor. Çünkü bu durumda her oturum için aynı anahtar kullanılacağı için verilerin depolanıp daha sonra anahtar açığa çıktığı bir gün beklenerek veriler geçmişe dönük okunabilir bir hale gelecektir. Bu yüzden bu değişiklik yapıldı. Yine sıfır güven tehdit modeli gereğince her bir katmanın ve sürecin bir diğerinin işini doğru yapacağına güvenmeden süreci ilerletmesini istiyorum. Bu yüzden TLS katmanındaki o ilk iletişim anında dahi paketlerin tls-auth özelliği gereğince şifrelenmesini ve gelen-giden verilerin bütünlüğünün doğrulanmasını istiyoruz. Daha ilk merhaba dediğiniz andan itibaren üçüncü kişiler sizin ne konuştuğunuzu hangi aşamada olduğunuzu anlayamayacaklardır. Bunun için önceden belirlenmiş bir anahtar/anahtarlar ile ilk iletişim başlatılır ve gerekirse belirli aralıklarla bu anahtarlar yenilenir. Böylece TLS katmanında ilk ön-anahtar oluşturulana kadar dahi gizlilikten ödün verilmemiş ve yetkisiz kişilerce boşuna tarafik yaratılmamış olur.\nVeri katmanında işleyen süreç Eğer tüm bu süreç başarılı bir şekilde tamamlanmış ve veri kanalına geçilebildiyse eğer artık işin en güzel kısmına gelmiş bulunuyorsunuz. Veriler AES şifreleme methodu ile şifrelenecek. Şifreleme sırasında seçiminize göre CBC-GCM counter moduna göre tablolar karıştırılacak ve bu süreçte seçiminize göre 128 veya 256 bit uzunluğunda şifreleme anahtarı kullanılacak. Tabi ne hangisini seçerseniz seçin şifreleme blok uzunluğu 128 bit olucak. Değişen sadece şifreleme anahtarı uzunluğu. Benim bu anlatımım için seçmiş olduğum AES-256-GCM bir AEAD şifreleme türüdür. Diğer kanallardan ve süreçlerden bağımsız olarak gönderdiği verileri belirli bir aşamada özetini çıkartır ve özeti ile birlikte gönderir. Böylece ‘Authentication Encryption with associated data’ anlamına gelen AEAD’de doğrulama ve şifreleme işlevleri yerine getirilmiş oluyor. Burada bir ayrıma gidilmesini gerektirecek şöyle bir sorun mevcuttur. Şifreleme ve Özet alma algoritmalarını hangi aşamada ve sırayla kullanacağız.\nEncrypt-then-MAC (EtM) Encrypt-and-MAC (E-and-M) MAC-then-Encrypt (MtE) https://en.wikipedia.org/wiki/Authenticated_encryption (Erişim Tarihi: 08.04.2023)\nBirinci yaklaşım olan EtM’ye göre veri önce şifrelenir ardından başka bir anahtar ile özeti sonucu şifrelenir ve ortaya çıkan sonuç bloklar halinde birlikte gönderilir. Bunu kullanan gerçek dünya çözümlerine bakacak olursak IPSec protokolü ilk akla gelen olacaktır. Bu, AE’de en yüksek güvenlik tanımına ulaşabilen tek yöntemdir, ancak bu ancak kullanılan MAC algoritmasının bozulma içermediği veya henüz kırılmadığı takdirde elde edilebilir. SSHv2 için de çeşitli EtM şifre takımları mevcuttur. Ancak veri ve özet için anahtar ayrımının zorunlu olduğunu unutmayın (şifreleme ve anahtarlı karma için farklı anahtarlar kullanılmalıdır), aksi takdirde kullanılan belirli şifreleme yöntemine ve karma işlevine bağlı olarak potansiyel olarak güvensiz bir sonuç elde edebilirsiniz.\nİkinci yaklaşım olan E\u0026M’ye göre düz metin olan veri şifrelenir ve yanına düz metin verinin şifrelenmemiz halinin özeti eklenir. Burada sadece bir anahtar kullanılmış olmasına rağmen aynı veriye ait iki farklı sonucun (şifreleme sonucu ve özet sonucu) olması güvenliğin yeterince iyi olmadığını açıkca gözler önüne sermektedir. Bu sistemi kullanan gerçek dünya çözümü olarak SSH’ın ilk versiyonlarını örnek gösterebiliriz. Bunu geliştirmek için ayrıca gönderilen özet dosyasını da aynı anahtar ile şifreleme gibi yöntemler denenmiştir.\nÜçüncü ve bildiğim son yaklaşım olan MtE’ye göre düz metine dayalı olarak bir özet dosyası üretilir. Ardından düz metin ve özet dosyası birlikteyken anahtar ile şifrelenir. Şifreli metin ve şifreli özet dosyası birlikte gönderilir. Bunu kullanan gerçek dünya çözümlerine bakacak olursak ilk ve en önemlisi SSL/TLS uygulamalarıdır. SSL/TLS uygulamalarının kendi içlerinde ne kadar güvenilir ve sürdürülebilir olduklarını hepimiz biliyoruz. Bunun ötesinde de güvenliği artırmak adına yıllar içersinde MAC-then-pad-then-encrypt gibi geliştirmeler yapıldı. Bu geliştirmeye göre önce düz metinin özeti alınır ardından blok boyutuna kadar doldurulur ve ardından şifreleme işlemi yapılır. Böylece daha da güvenilir bir şifreleme sonucu oluşur. Ama doldurma mekanizmasının belirli hatalar yapması durumunda Padding Oracle gibi saldırılara neden olduğu durumlar mevcuttur.\nhttps://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Erişim Tarihi: 08.04.2023) Kullanılacak AEAD yaklaşımı da seçildikten sonra TAP veya TUN kullanımına göre yukarıdaki grafikte görülen yol izlenir. Bu yola göre kullanıcı alanında yapılan/yapılmak istenen eylem çekirdek (kernel) seviyesinde TAP/TUN adaptörlerine gider. Bu adaptörler çekirdek seviyesinde bulunmaları nedeniyle çok hızlı bir şekilde işlem yaparlar. Ardından sanal adaptörler ilgili kütüphane ile gerekli şifrelemeyi yapar, gerekirse özeti ekler ve paket boyutu ayarı yapar. Ardından sunucu Ethernet arayüzü üzerinden istemcinin Ethernet arayüzüne paketleri sırayla gönderir. Bunu alan istemci ise paketleri yeniden ayarlar, düzenler gerekirse birleştirir ve gerekli kütüphaneler ile şifresini çözer. Şifresini çözdükten sonra bunu sanal adaptör aracılığı ile istemcini son kullanıcısına iletir. Böylece tüm bu matematiksel işlemler, uğraşlar sonucunda birkaç çevrim neticesinde kullanıcı istediği içeriğe ulaşmış oldu. Anlatması oldukça uzun ama kullanması çok kolay sevgili okuyucular. Sadece GitHub sayfama girik ilgili script sayfasını ziyaret etmeniz yeterlidir. İlgili script tüm bu ayarlamaları interaktif olarak sizin yerinize yapmaktadır. Size de arkanıza yaslanıp keyfini çıkarmak kalıyor.\nSSS ve Son Bana mail yoluyla, Fosstodon üzerinden veya GitHub üzerinden gelen soruları zaman zaman buraya eklemeye çalışacağım. Böylece tarihsel olarak da hangi tarihte ne gibi sorular olmuş veya çözümü mevcut mu gibi düşüncelere kapılmadan direk sonuca ulaşabileceksiniz. Bunun haricinde de teknik dökümanı değiştirmeden ekstra açıklama gerektiren sorular gelirse onları da bu kısma almayı düşünüyorum.\n","wordCount":"2650","inLanguage":"tr","datePublished":"2022-03-27T00:00:00Z","dateModified":"2023-04-11T02:43:18+02:00","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb-works.github.io/blog/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb-works.github.io/blog/ accesskey=h title="Wise (Alt + H)">Wise</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb-works.github.io/blog/en/ title=English aria-label=:gb:>🇬🇧</a></li><li><a href=https://wiseweb-works.github.io/blog/de/ title=Deutsch aria-label=:de:>🇩🇪</a></li></ul></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>OpenVPN Derinlemesine Anlatım</h1><div class=post-meta><span title='2022-03-27 00:00:00 +0000 UTC'>27 Mart, 2022</span>&nbsp;·&nbsp;<span title='2023-04-11 02:43:18 +0200 +0200'>(Updated 11 Nisan, 2023)</span>&nbsp;·&nbsp;13 dk&nbsp;·&nbsp;2650 kelime&nbsp;·&nbsp;Wise&nbsp;|&nbsp;Çeviriler:<ul class=i18n_list><li><a href=https://wiseweb-works.github.io/blog/en/post/openvpn-full-anlatim/>🇬🇧</a></li><li><a href=https://wiseweb-works.github.io/blog/de/post/openvpn-full-anlatim/>🇩🇪</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/openvpn-full-anlatim.md rel="noopener noreferrer" target=_blank>Düzenle</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>İçindekiler</span></summary><div class=inner><ul><li><a href=#giri%c5%9f-ve-%c3%b6zet aria-label="Giriş ve Özet">Giriş ve Özet</a><ul><li><a href=#openvpn-nedir-ve-ne-i%c3%a7in-kullan%c4%b1l%c4%b1yor- aria-label="OpenVPN nedir ve ne için kullanılıyor ?">OpenVPN nedir ve ne için kullanılıyor ?</a></li><li><a href=#openvpn-ba%c4%9flant%c4%b1s%c4%b1-kurmak-i%c3%a7in-nelere-ihtiya%c3%a7-duyar%c4%b1z- aria-label="OpenVPN bağlantısı kurmak için nelere ihtiyaç duyarız ?">OpenVPN bağlantısı kurmak için nelere ihtiyaç duyarız ?</a><ul><li><a href=#server-taraf%c4%b1nda-tutulan-ayar-dosyas%c4%b1-%c5%9fu-girdileri-i%c3%a7ermektedir aria-label="Server tarafında tutulan ayar dosyası şu girdileri içermektedir">Server tarafında tutulan ayar dosyası şu girdileri içermektedir</a></li><li><a href=#istemci-taraf%c4%b1nda-tutulan-ayar-dosyas%c4%b1-%c5%9fu-girdileri-i%c3%a7ermektedir aria-label="İstemci tarafında tutulan ayar dosyası şu girdileri içermektedir">İstemci tarafında tutulan ayar dosyası şu girdileri içermektedir</a></li></ul></li><li><a href=#openvpn-ba%c4%9flant%c4%b1s%c4%b1-kurulurken-neler-oluyor- aria-label="OpenVPN bağlantısı kurulurken neler oluyor ?">OpenVPN bağlantısı kurulurken neler oluyor ?</a><ul><li><a href=#tcp-ba%c4%9flant%c4%b1s%c4%b1n%c4%b1n-kurulmas%c4%b1-s%c3%bcreci aria-label="TCP bağlantısının kurulması süreci">TCP bağlantısının kurulması süreci</a></li><li><a href=#tls-katman%c4%b1ndaki-i%c5%9fletilen-s%c3%bcre%c3%a7 aria-label="TLS katmanındaki işletilen süreç">TLS katmanındaki işletilen süreç</a></li><li><a href=#veri-katman%c4%b1nda-i%c5%9fleyen-s%c3%bcre%c3%a7 aria-label="Veri katmanında işleyen süreç">Veri katmanında işleyen süreç</a></li></ul></li></ul></li><li><a href=#sss-ve-son aria-label="SSS ve Son">SSS ve Son</a></li></ul></div></details></div><div class=post-content><h1 id=giriş-ve-özet>Giriş ve Özet<a hidden class=anchor aria-hidden=true href=#giriş-ve-özet>#</a></h1><p>Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN&rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak. Şimdi kemerlerimizi bağlayalım ve internetin derin ve kasvetli dünyasında bir geziye çıkalım.</p><h2 id=openvpn-nedir-ve-ne-için-kullanılıyor->OpenVPN nedir ve ne için kullanılıyor ?<a hidden class=anchor aria-hidden=true href=#openvpn-nedir-ve-ne-için-kullanılıyor->#</a></h2><p>Günümüzde artık internet üzerinden yapılmayan bir iş neredeyse kalmadı. Hatta normalde internet üzerinden olmayan çalışma eylemimiz bile pandemi ve yeni normal nedeniyle evden çalışmaya doğru evrildi. Fakat hem alışık olmadığımız bir çalışma yöntemi olması nedeniyle hem de insanlarımızın teknoloji ile arasının pek iyi olmaması nedeniyle büyük sorunlar yaşandı. İnsanların evlerindeki bilgisayarlardan ofisteki bilgisayarlarına bağlanması gerektiği anlaşılmadan önce bazı firmalar çalışanların evlerine ofis bilgisayarlarını gönderme gibi uçuk fikirler buldu. Bunun ne kadar hatalı bir gidiş yolu olduğunu kısa süre içinde aldıkları geri dönüşlerden çok iyi anladılar. Kısaca elektronik cihazların ofiste kalması ve bir şekilde uzaktan güvenli ve sürdürülebilir bir bağlantı yapılması gerektiği sonunda kabullenildi. Kurumlar daha önceleri de kendilerini böyle ihtiyaçlar içinde buluyordu elbette ama bu derece büyük ölçekli bir durum söz konusu değildi o zamanlar. Pandemi öncesinde PPTP, L2TP, IPSec, IKev2, SSTP ve nihayet OpenVPN gibi çeşitli protokoller kullanıyordu. Bunlar genelde belirli uzun ve havalı kelimelerin kısaltması olup temel mantıkları iki veya daha fazla cihazı birbirine bağlamak ve aynı ağdaymış gibi hareket etmelerini sağlamak üzerinedir. OpenVPN&rsquo;den önceki protokoller belirli zayıflıkları, yavaşlıkları ve uygulanmasıyla ilgili teknik zorlukları da beraberlerinde getirdikleri için çok bahsetmeyeceğim. OpenVPN sunucu ve istemci rolündeki en az 2 cihazın birbirlerine bağlanması ve bunu endüstiri standartlarını karşılayacak şekilde yapmasına yarayan protokol ve programın adıdır. Ben uzak masaüstü programı kullanıyorum buna ne gerek var dediğinizi duyar gibiyim. Maalesef o ve onun gibi diğer tüm programlar temelde bu protokolü kullanmak durumunda kalıyorlar. En meşhurlarından olan TeamViewer programında kalkan simgesine veya bağlantı ayrıntılarına bastığınız takdirde OpenVPN protokolünü görebilirsiniz.</p><h2 id=openvpn-bağlantısı-kurmak-için-nelere-ihtiyaç-duyarız->OpenVPN bağlantısı kurmak için nelere ihtiyaç duyarız ?<a hidden class=anchor aria-hidden=true href=#openvpn-bağlantısı-kurmak-için-nelere-ihtiyaç-duyarız->#</a></h2><p>Öncelikle hem sunucu hem de istemci (bağlanacak cihaz) tarafında OpenVPN&rsquo;in kurulu olması gerekiyor. Ardından cihazların hangi şartlar altında iletişim kuracaklarını gösterir bir ayar (config) dosyasının düzenlenmesi gerekmektedir. Asıl olay zaten bu config dosyasının üretilmesi ve istemci tarafından kullanılmasıdır. Bu config dosyası sunucu tarafından kullanılan server_config ve istemci tarafından kullanılan client_config olarak ikiye ayrılır.</p><h3 id=server-tarafında-tutulan-ayar-dosyası-şu-girdileri-içermektedir>Server tarafında tutulan ayar dosyası şu girdileri içermektedir<a hidden class=anchor aria-hidden=true href=#server-tarafında-tutulan-ayar-dosyası-şu-girdileri-içermektedir>#</a></h3><ul><li><code>port 1194</code> OpenVPN bağlantısını yapmak için kendisine hangi port üzerinden bağlantı talebi geleceğini belirtir.</li><li><code>proto tcp</code> Bağlantının TCP veya UDP üzerinden yapılması mümkün. Seçim için girilen ayar girdisi.</li><li><code>dev tun</code> TAP veya TUN arabirimi kullanılabilir. Bunlar sanal arabirimlerdir. TAP layer 2 bir bağlantı kurarken TUN layer 3 bir bağlantı kurar.</li><li><code>user nobody</code> Bağlanan kullanıcıların sunucu üzerinde yetkisiz bir kullanıcıya linklenmesini sağlıyor.</li><li><code>group $NOGROUP</code> Bağlanan kullanıcıların sunucu üzerinde grup olarak da yetkisiz bir gruba linklenmesini sağlıyor.</li><li><code>persist-key</code> Sanal arabirimin oluşturulması ve yeniden başlatılması ile ilgili bir yetkilendirme ayarı</li><li><code>persist-tun</code> Yine aynı şekilde sanal arabirimin oluşturulması ve yeniden başlatılması ile ilgili bir yetkilendirme ayarı</li><li><code>keepalive 10 120</code> Kaç adet bağlantının aktif tutulacağını ve ne kadar süre iletişim kurulmaz ise aktif bağlantının sonlandırılacağı ile ilgili bir ayar</li><li><code>ifconfig-pool-persist ipp.txt</code> OpenVPN tarafından istemcilere sanal ağda verilen IP adreslerinin tutulması ve tekrar bağlandıkları takdirde aynı adreslerin verilmesi için bir ayar</li><li><code>push "dhcp-option DNS 1.1.1.1"</code> Sunucunun ağa çıkarken kullanması için bir DNS ayarı</li><li><code>compress</code> Sıkıştırma seçeneklerinin ayarlandığı kısım</li><li><code>dh none</code> Diffie-Hellman&rsquo;ın açılıp kapatılması ile ilgili bir ayar</li><li><code>ecdh-curve</code> Eğer Elliptik Eğri Diffie-Hellman kullanıyor iseniz yanında seçmeniz gereken eğrinin ayarlandığı ayar</li><li><code>dh dh.pem</code> Diffie-Hellman kullanıyor iseniz önceden oluşturmanız gereken PEM dosyasının konumunu belirten ayar</li><li><code>tls-crypt tls-crypt.key</code> TLS katmanının pre-shared master öncesinde dahi şifrelenmesi için gerekli ayar</li><li><code>tls-auth tls-auth.key 0</code> TLS katmanının pre-handshake aşamasında şifrelenmesinin de ötesinde tarafların da doğrulanmasını sağlayan ayar</li><li><code>crl-verify crl.pem</code> Üretilen sertifikaların revoke edilip edilmediğinin CRL listesi üzerinden kontrol edilmesine yarayan ayar</li><li><code>ca ca.crt</code> Üretilen sertifikaya ait sertifika otoritesinin sertifikasının konumunu bildiren bir ayar</li><li><code>cert $SERVER_NAME.crt</code> Sunucunun sertifikasının konumunu bildiren bir ayar</li><li><code>key $SERVER_NAME.key</code> Sunucunun sertifikasının yanında yine gerekli olan asimetrik secret keyinin konumunu bildiren bir ayar</li><li><code>auth $HMAC_ALG</code> Veri kanalı ve gerekirse <code>tls-auth</code> için hangi özet algoritmasının kullanılacağını bildiren bir ayar</li><li><code>cipher $CIPHER</code> Veri kanalı için hangi şifreleme algoritmasının kullanılacağını bildiren bir ayar</li><li><code>ncp-ciphers $CIPHER</code> Sunucunun kullanabileceği şifreleme algoritmalarını bildiren bir ayar</li><li><code>tls-server</code> Sunucunun TLS kanalını kullanmasını söyleyen bir ayar</li><li><code>tls-version-min 1.2</code> TLS kanalında kullanılması için en düşük versiyonu bildiren bir ayar</li><li><code>tls-cipher $CC_CIPHER</code> Veri kanalından hariç TLS katmanında da şifreleme kullanılıyor bu da kontrol kanalı şifrelemesini bildiren ayar</li><li><code>client-config-dir /etc/openvpn/ccd</code> İstemci ayar dosyalarının tutulduğu konumu bildiren ayar</li><li><code>status /var/log/openvpn/status.log</code> Durum raporlarının yazılacağı konumu ve log dosyalarının tutulduğu konumu bildiren ayar</li><li><code>verb 3</code> Verbose kelimesinin kısaltılmışı olan bu ayar ne kadar detaylı durum raporu verileceğinin ayarıdır.</li></ul><h3 id=istemci-tarafında-tutulan-ayar-dosyası-şu-girdileri-içermektedir>İstemci tarafında tutulan ayar dosyası şu girdileri içermektedir<a hidden class=anchor aria-hidden=true href=#istemci-tarafında-tutulan-ayar-dosyası-şu-girdileri-içermektedir>#</a></h3><ul><li><code>client</code> İlgili cihazın istemci rolünde olduğunu belirtiyor</li><li><code>proto tcp-client</code> Protokol olarak TCP&rsquo;nin kullanılacağını bildiriyor</li><li><code>remote $IP $PORT</code> Bağlanılacak sunucu(ların) IP adresinin ve Port numarasının ayarladığı kısım</li><li><code>dev tun</code> TUN/TAP arabirimlerinden hangisinin kullanılacağını ayarlıyor</li><li><code>resolv-retry infinite</code> Eğer IP veya DNS nedeniyle adres çözümlemesi gecikir ise ne kadar süre ile bekleyeceğini söylüyoruz</li><li><code>nobind</code> Lokaldeki herhangi bir adrese bağlanılmamasını bildiren ayar</li><li><code>persist-key</code> Yeniden başlatma durumunda anahtar dosyalarının ek bir yetkiye gerek kalmadan okunabilmesini yarar</li><li><code>persist-tun</code> Aynı şekilde yeniden başlatma durumunda TUN/TAP arabiriminin yetkiye gerek kalmadan uyandırılabilmesine yarar</li><li><code>remote-cert-tls server</code> Bağlanılan sunucunun sertifikasını TLS katmanında doğrulanmasını sağlar</li><li><code>verify-x509-name $SERVER_NAME name</code> Sunucunun geri döneceği sertifikasındaki ismi ve sunucunun isminin ne olması gerektiğini bildiren komut</li><li><code>auth $HMAC_ALG</code> Doğrulama için hangi algoritmanın kullanılacağını bildiren komut</li><li><code>auth-nocache</code> Oturum açmak için gerekli parolayı önbelleğe almaz</li><li><code>cipher $CIPHER</code> Şifreleme için kullanılacak algoritmayı seçmeye yarayan komut</li><li><code>tls-client</code> TLS iletişimi sırasında TLS&rsquo;yi etkinleştirir ve istemci rolünü üstlenir</li><li><code>tls-version-min 1.2</code> En düşük TLS versiyonunu ayarlar</li><li><code>tls-cipher $CC_CIPHER</code> TLS kontrol kanalında kullanılacak şifreleme algoritmasını seçer</li><li><code>ignore-unknown-option block-outside-dns</code> Bilinmeyen DNS adreslerinin kullanılmasını engeller</li><li><code>setenv opt block-outside-dns</code> Windows 10 için DNS sızıntılarını engeller</li><li><code>verb 3</code> Rapor verme derecesini belirler</li><li><code>compress</code> Sıkıştırma algoritması ayarları burada bildirilir</li><li><code>"&lt;ca>/etc/openvpn/easy-rsa/pki/ca.crt&lt;/ca>"</code> Beklenilen sunucu sertifika otoritesi dosyasının Hard-Coded gömülmesi</li><li><code>"&lt;cert>/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt&lt;/cert>"</code> İstemci sertifika dosyasının Hard-Coded gömülmesi</li><li><code>"&lt;key>/etc/openvpn/easy-rsa/pki/private/$CLIENT.key&lt;/key>"</code> İstemci asimetrik secret keyinin Hard-Coded gömülmesi</li><li><code>"&lt;tls-crypt>/etc/openvpn/tls-crypt.key&lt;/tls-crypt>"</code> TLS crypt için key dosyasının belirtilmesi</li><li><code>"&lt;tls-auth>/etc/openvpn/tls-auth.key&lt;/tls-auth>"</code> TLS auth için key dosyasının belirtilmesi</li><li><code>key-direction 1</code> TLS katmanı şifrelenmesi için istemci ve sunucuya rol atıyor (0 ve 1 şeklinde)</li></ul><p>Bu ayarları ve daha bir çoğunun ayrıntılı dökümantasyonunu <a href=https://openvpn.net/community-resources/reference-manual-for-openvpn-2-4/>OpenVPN</a> web sayfasında bulabilirsiniz.</p><h2 id=openvpn-bağlantısı-kurulurken-neler-oluyor->OpenVPN bağlantısı kurulurken neler oluyor ?<a hidden class=anchor aria-hidden=true href=#openvpn-bağlantısı-kurulurken-neler-oluyor->#</a></h2><p>OpenVPN ile bağlantı kurduğum her zaman kendimi Yıldız Filosu planlarını kaçıran R2-D2 gibi hissediyorum. İnsanlar kendilerini her zaman için derinlemesine bir inceleme içerisinde bulmak istemiyorlar ve birilerinin onlara neyin nasıl döndüğünü açıklamalarını isteyebiliyorlar. Benim bu yazıyı kaleme alma amacımda aslında bu soruyu kendime sormuş olmam ve cevabını almak için çok çaba sarfetmiş olmam. Sizin de bu kadar uğraşmanızı istemem fakat size hemencecik bunu yükle gerisini düşünme o iş bende de diyemem. Başta söz verdiğim gibi derinlemesine bir şekilde bu süreci sizlere anlatacağım ve kararı size bırakacağım. Bir OpenVPN bağlantısında artısıyla eksisiyle (benim şu ana kadar çözebildiğim şekliyle) süreç şöyle işliyor. Önce bir TCP/UDP bağlantısı kuruyorsunuz. TCP kullanan her uygulama gibi bir süreç yürütüyorsunuz ve ardından TLS katmanına geçiyorsunuz. TLS katmanında el sıkışma (handshake) ve bazı kimlik doğrulama işlemleri yapıyorsunuz. Bu katmana aynı zamanda kontrol kanalı da deniliyor. Ardından belirli bir iletişim tutturulmuş oluyor ve veri kanalına geçiliyor. Veri veya data kanalında bu sefer gönderilecek veri paketlerinin şifrelenmesi ve çözülmesi süreci başlıyor. Bunun için yine cihazlar birbirleri ile konuşuyor ve belirli ortak şartlar altında veriler gönderilmeye başlanıyor. Kısaca bu şekilde anlattığım sürecin sonunda 0&rsquo;dan başlattığımız iletişim bize güvenli ve istediğimiz şekilde verilerin ulaşması ile son buluyor veya açık tutulan bağlantı üzerinden bu sefer tersine bir yolla yeniden istekler iletiliyor. Böylece iç içe borular gibi bir sistem ortaya çıkıyor. Yazı için gerekli olan tek önemli şeyi buraya yazmak gerekirse eğer:</p><ul><li><code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512</code> şeklinde olacaktır.<ul><li>Burada <code>TLS</code> girdisi kontrol kanalının TLS katmanı üzerinden yürütüleceğini belirtir. Diğer alternatifler <code>SSL</code> veya <code>NULL</code>&lsquo;dur.</li><li><code>ECDHE</code> girdisi Elliptik Diffie-Hellman algoritması kullanılarak ilk ön-anahtarın üretileceğini belirtir. Diğer alternatifler <code>DHE</code>, <code>DH</code> veya kullanmamaktır.</li><li><code>ECDSA</code> verisi karşılıklı kimlik doğrulama ve asimetrik anahtar için Elliptik Dijital İmza Sertifikası Algoritmasının kullanılacağını belirtir. Diğer kullanılabilir alternatif <code>RSA</code>&lsquo;dır. Diğerlerini saymaya gerek bile yok.</li><li><code>AES_256_GCM</code> veri kanalında kullanılacak şifreleme algoritmasının belirtir. Diğer alternatifler <code>AES-128-CBC</code>, <code>AES-128-GCM</code> ve <code>AES-256-CBC</code>&lsquo;dir</li><li><code>SHA384</code> kullanılacak özet algoritmasını belirtir. Diğer alternatif <code>SHA256</code>&lsquo;dır.</li><li><code>P512</code> ise kullanılacak elliptik eğrinin Prime-512 adlı eğri olarak seçilmesini sağlar. Diğer alternatifler <code>P-256</code> ve <code>P-384</code>&lsquo;dür.</li></ul></li></ul><h3 id=tcp-bağlantısının-kurulması-süreci>TCP bağlantısının kurulması süreci<a hidden class=anchor aria-hidden=true href=#tcp-bağlantısının-kurulması-süreci>#</a></h3><p>Şimdi kafanızda sürecin yaklaşık bir resmi oluştu ise başlangıcı TCP sürecinin anlatımıyla yapıyorum. Olayımızda bir istemci ve bir sunucunun olduğunu ve bağlantının sadece bu ikisinden ibaret olduğunu düşünelim. İstemci bağlanmak istediği sunucuya bir SYN (m) paketi gönderir. Sunucu ise buna cevap olarak aynı port üzerinden bir SYN (n) paketi ve ACK (m+1) paket gönderir. Bunu alan istemci de cevap olarak ACK (n+1) şeklinde dönüş yapar ve 3&rsquo;lü TCP el sıkışması veya 3 Way TCP handshake gerçekleşmiş olur. Böylece belirtilen port üzerinden istemci ve sunucu arasında açık bir kanalımız oluştu.</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.jpg loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://blog.shiftasia.com/what-happen-when-access-website (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><hr><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><p>Fotoğraflarda da görüleceği üzere eğer süreç sorunsuz işler ise 3 adımda iletişim kurulabiliyor. Fakat neden 3 adımda bu işi yapıyoruz daha kısa şekilde olmaz mı derseniz size (şimdilik) hayır olmaz full-duplex bir iletişim için her iki tarafın da SYN ve ACK paketlerini göndermesi gerekiyor derim. İleride belki farklı yollarını da anlatırım ama şimdilik böyle. Zaten işin TCP/UDP kısmı her zaman için kısa ve basittir.</p><h3 id=tls-katmanındaki-işletilen-süreç>TLS katmanındaki işletilen süreç<a hidden class=anchor aria-hidden=true href=#tls-katmanındaki-işletilen-süreç>#</a></h3><p>TCP üzerinden bir iletişim kurulmasının ardından yine muhabbeti başka bir aşamaya taşıyan kişi istemci oluyor. Her zaman için istemciler sunucudan bir şeyler talep eder veya bir cevap ister. Sunucular genel olarak kendilerine gelmeyen bir isteği cevapladığı çok görülmemiştir. Önce talep sonra arz ilkesine göre süreç ilerler. Evet, taraflar TLS katmanındalar şimdi. İstemci sunucuya önce bir merhaba diyor. Şaka değil gerçek. İstemci tarafından gönderilen ilk pakete <code>Client-Hello</code> paketi denir. Bu paketin yanında (süreci hızlandırmak adına) desteklediği şifreleme algoritmalarını belirten <code>Supported-Chipers</code> paketi, istemci tarafından rastgele üretilmiş bir sayı, aynı IP adresinde birden fazla hizmet çalıştırılıyor ise bir <code>SNI</code> sunucu adı indikatörü ve yine gerekiyor ise oturum ID&rsquo;si gönderilir. Sunucunun buna cevabı ise öncelikle kibar bir merhaba demek oluyor. Çünkü sunucunun cevaben gönderdiği ilk pakete de <code>Server-Hello</code> paketi denir. Bu paketin yanında sunucu sertifikasını, kendi desteklediği şifreleme algoritmalarını ve seçtiği algoritmayı belirten <code>Selected-Chiper</code> paketi, kendisinin ürettiği rastgele bir sayıyı, gerekirse Oturum ID&rsquo;sini ve aynı IP üzerinden birden fazla istemci bağlanıyor ise buna ilişkin SNI benzeri bir ID&rsquo;yi gönderir. İstemci öncelikle iletişime başladığı tarafından gerçekten beklediği kişi olup olmadığını sunucu sertifikası ile doğrular. Ayrıca bazı durumlarda da sunucu istemcinin beklediği istemcilerden biri olup olmadığını yine sertifika ile doğrular. Eğer bu karşılıklı doğrulama (mutual-authentication) süreci olumlu sonuçlanır ise bir sonraki aşamaya geçilir. Anahtar üretim ve değişim süreci tetiklenmiş olur. Bu aşamda yine istemci devreye girer ve güvensiz önkabul edilen bu iletişim sırasında belirledikleri algoritma ile anahtar değiştirmek istediğini söyler. Taraflar Diffie-Hellman veya ECDHE ile bir önanahtar oluşturmaya başlarlar. Bunun için istemci ve sunucu tarafından ön-sırlar paylaşılır. Bir takım matematiksel işlemler yapılarak bulunan cevaplar karşıya gönderilir ve tekrar matematiksel işlemler yapılarak aynı sonuca ulaşılır. İşte ulaşılan sonuç aralarında güvenli bir şekilde oluşturdukları ilk ön-anahtar oluyor. Bundan sonra belirledikleri şifreleme algoritması ile
iletişime geçmek için kontrol kanalından hariç bir veri kanalı oluşturulur ve süreç oradan devam eder.</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><hr><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b></b></small></center></picture></p><p>Fotoğraflarda da görülebileceği üzere süreç bir web sayfasına bağlanılırken yaşanan süreçle neredeyse aynı. Sadece ihtiyaçlara göre belirli aşamalar ekleniyor, çıkarılıyor veya değiştiriliyor. Örneğin İleri Seviye Gizlilik anlamına gelen PFS gereğince taraflar ön-anahtarı sunucunun asimetrik anahtarı ile iletmiyor. Çünkü bu durumda her oturum için aynı anahtar kullanılacağı için verilerin depolanıp daha sonra anahtar açığa çıktığı bir gün beklenerek veriler geçmişe dönük okunabilir bir hale gelecektir. Bu yüzden bu değişiklik yapıldı. Yine sıfır güven tehdit modeli gereğince her bir katmanın ve sürecin bir diğerinin işini doğru yapacağına güvenmeden süreci ilerletmesini istiyorum. Bu yüzden TLS katmanındaki o ilk iletişim anında dahi paketlerin <code>tls-auth</code> özelliği gereğince şifrelenmesini ve gelen-giden verilerin bütünlüğünün doğrulanmasını istiyoruz. Daha ilk merhaba dediğiniz andan itibaren üçüncü kişiler sizin ne konuştuğunuzu hangi aşamada olduğunuzu anlayamayacaklardır. Bunun için önceden belirlenmiş bir anahtar/anahtarlar ile ilk iletişim başlatılır ve gerekirse belirli aralıklarla bu anahtarlar yenilenir. Böylece TLS katmanında ilk ön-anahtar oluşturulana kadar dahi gizlilikten ödün verilmemiş ve yetkisiz kişilerce boşuna tarafik yaratılmamış olur.</p><h3 id=veri-katmanında-işleyen-süreç>Veri katmanında işleyen süreç<a hidden class=anchor aria-hidden=true href=#veri-katmanında-işleyen-süreç>#</a></h3><p>Eğer tüm bu süreç başarılı bir şekilde tamamlanmış ve veri kanalına geçilebildiyse eğer artık işin en güzel kısmına gelmiş bulunuyorsunuz. Veriler AES şifreleme methodu ile şifrelenecek. Şifreleme sırasında seçiminize göre CBC-GCM counter moduna göre tablolar karıştırılacak ve bu süreçte seçiminize göre 128 veya 256 bit uzunluğunda şifreleme anahtarı kullanılacak. Tabi ne hangisini seçerseniz seçin şifreleme blok uzunluğu 128 bit olucak. Değişen sadece şifreleme anahtarı uzunluğu. Benim bu anlatımım için seçmiş olduğum AES-256-GCM bir AEAD şifreleme türüdür. Diğer kanallardan ve süreçlerden bağımsız olarak gönderdiği verileri belirli bir aşamada özetini çıkartır ve özeti ile birlikte gönderir. Böylece &lsquo;Authentication Encryption with associated data&rsquo; anlamına gelen AEAD&rsquo;de doğrulama ve şifreleme işlevleri yerine getirilmiş oluyor. Burada bir ayrıma gidilmesini gerektirecek şöyle bir sorun mevcuttur. Şifreleme ve Özet alma algoritmalarını hangi aşamada ve sırayla kullanacağız.</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center></th><th></th></tr></thead><tbody><tr><td style=text-align:center><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>Encrypt-then-MAC (EtM)</b></small></center></picture></td><td style=text-align:center><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>Encrypt-and-MAC (E-and-M)</b></small></center></picture></td><td style=text-align:center><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>MAC-then-Encrypt (MtE)</b></small></center></picture></td></tr></tbody></table><blockquote><p><a href=https://en.wikipedia.org/wiki/Authenticated_encryption>https://en.wikipedia.org/wiki/Authenticated_encryption</a> (Erişim Tarihi: 08.04.2023)</p></blockquote><ul><li><p>Birinci yaklaşım olan EtM&rsquo;ye göre veri önce şifrelenir ardından başka bir anahtar ile özeti sonucu şifrelenir ve ortaya çıkan sonuç bloklar halinde birlikte gönderilir. Bunu kullanan gerçek dünya çözümlerine bakacak olursak IPSec protokolü ilk akla gelen olacaktır. Bu, AE&rsquo;de en yüksek güvenlik tanımına ulaşabilen tek yöntemdir, ancak bu ancak kullanılan MAC algoritmasının bozulma içermediği veya henüz kırılmadığı takdirde elde edilebilir. SSHv2 için de çeşitli EtM şifre takımları mevcuttur. Ancak veri ve özet için anahtar ayrımının zorunlu olduğunu unutmayın (şifreleme ve anahtarlı karma için farklı anahtarlar kullanılmalıdır), aksi takdirde kullanılan belirli şifreleme yöntemine ve karma işlevine bağlı olarak potansiyel olarak güvensiz bir sonuç elde edebilirsiniz.</p></li><li><p>İkinci yaklaşım olan E&amp;M&rsquo;ye göre düz metin olan veri şifrelenir ve yanına düz metin verinin şifrelenmemiz halinin özeti eklenir. Burada sadece bir anahtar kullanılmış olmasına rağmen aynı veriye ait iki farklı sonucun (şifreleme sonucu ve özet sonucu) olması güvenliğin yeterince iyi olmadığını açıkca gözler önüne sermektedir. Bu sistemi kullanan gerçek dünya çözümü olarak SSH&rsquo;ın ilk versiyonlarını örnek gösterebiliriz. Bunu geliştirmek için ayrıca gönderilen özet dosyasını da aynı anahtar ile şifreleme gibi yöntemler denenmiştir.</p></li><li><p>Üçüncü ve bildiğim son yaklaşım olan MtE&rsquo;ye göre düz metine dayalı olarak bir özet dosyası üretilir. Ardından düz metin ve özet dosyası birlikteyken anahtar ile şifrelenir. Şifreli metin ve şifreli özet dosyası birlikte gönderilir. Bunu kullanan gerçek dünya çözümlerine bakacak olursak ilk ve en önemlisi SSL/TLS uygulamalarıdır. SSL/TLS uygulamalarının kendi içlerinde ne kadar güvenilir ve sürdürülebilir olduklarını hepimiz biliyoruz. Bunun ötesinde de güvenliği artırmak adına yıllar içersinde <code>MAC-then-pad-then-encrypt</code> gibi geliştirmeler yapıldı. Bu geliştirmeye göre önce düz metinin özeti alınır ardından blok boyutuna kadar doldurulur ve ardından şifreleme işlemi yapılır. Böylece daha da güvenilir bir şifreleme sonucu oluşur. Ama doldurma mekanizmasının belirli hatalar yapması durumunda Padding Oracle gibi saldırılara neden olduğu durumlar mevcuttur.</p></li></ul><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><p>Kullanılacak AEAD yaklaşımı da seçildikten sonra TAP veya TUN kullanımına göre yukarıdaki grafikte görülen yol izlenir. Bu yola göre kullanıcı alanında yapılan/yapılmak istenen eylem çekirdek (kernel) seviyesinde TAP/TUN adaptörlerine gider. Bu adaptörler çekirdek seviyesinde bulunmaları nedeniyle çok hızlı bir şekilde işlem yaparlar. Ardından sanal adaptörler ilgili kütüphane ile gerekli şifrelemeyi yapar, gerekirse özeti ekler ve paket boyutu ayarı yapar. Ardından sunucu Ethernet arayüzü üzerinden istemcinin Ethernet arayüzüne paketleri sırayla gönderir. Bunu alan istemci ise paketleri yeniden ayarlar, düzenler gerekirse birleştirir ve gerekli kütüphaneler ile şifresini çözer. Şifresini çözdükten sonra bunu sanal adaptör aracılığı ile istemcini son kullanıcısına iletir. Böylece tüm bu matematiksel işlemler, uğraşlar sonucunda birkaç çevrim neticesinde kullanıcı istediği içeriğe ulaşmış oldu. Anlatması oldukça uzun ama kullanması çok kolay sevgili okuyucular. Sadece GitHub sayfama girik ilgili <a href=https://github.com/wiseweb-works/openvpn-most-secure-install/>script sayfasını</a> ziyaret etmeniz yeterlidir. İlgili script tüm bu ayarlamaları interaktif olarak sizin yerinize yapmaktadır. Size de arkanıza yaslanıp keyfini çıkarmak kalıyor.</p><h1 id=sss-ve-son>SSS ve Son<a hidden class=anchor aria-hidden=true href=#sss-ve-son>#</a></h1><p>Bana <a href=mailto:wisewebworks@outlook.com>mail</a> yoluyla, <a href=https://fosstodon.org/@wise>Fosstodon</a> üzerinden veya <a href=https://github.com/wiseweb-works>GitHub</a> üzerinden gelen soruları zaman zaman buraya eklemeye çalışacağım. Böylece tarihsel olarak da hangi tarihte ne gibi sorular olmuş veya çözümü mevcut mu gibi düşüncelere kapılmadan direk sonuca ulaşabileceksiniz. Bunun haricinde de teknik dökümanı değiştirmeden ekstra açıklama gerektiren sorular gelirse onları da bu kısma almayı düşünüyorum.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb-works.github.io/blog/tags/linux/>linux</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ssl/>ssl</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/security/>security</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ecc/>ecc</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/elliptic-curve/>elliptic curve</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/openvpn/>openvpn</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/tls/>tls</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/aes/>aes</a></li></ul><nav class=paginav><a class=prev href=https://wiseweb-works.github.io/blog/post/adguard-reklam-engelleme/><span class=title>« Önceki</span><br><span>AdGuard ile Reklam Engelleme</span>
</a><a class=next href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/><span class=title>Sonraki »</span><br><span>Linux Sunucuda ECC SSL Sertifikası Üretme</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://wiseweb-works.github.io/blog/>Wise</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Kopyala";function s(){t.innerHTML="Kopyalandı!",setTimeout(()=>{t.innerHTML="Kopyala"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>