<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Linux Sunucuda ECC SSL Sertifikası Üretme | Wise</title>
<meta name=keywords content="linux,ssl,security,ecc,elliptic curve"><meta name=description content="Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.342dd4efd6228f58cff35ccd173d34ed0eb821b1b593eaceceeb0d64db7234c1.css integrity="sha256-NC3U79Yij1jP81zNFz007Q64IbG1k+rOzusNZNtyNME=" rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb-works.github.io/blog/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb-works.github.io/blog/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb-works.github.io/blog/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb-works.github.io/blog/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb-works.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/><link rel=alternate hreflang=en href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikasi/><link rel=alternate hreflang=de href=https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikasi/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Linux Sunucuda ECC SSL Sertifikası Üretme"><meta property="og:description" content="Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-16T22:17:43+02:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux Sunucuda ECC SSL Sertifikası Üretme"><meta name=twitter:description content="Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wiseweb-works.github.io/blog/post/"},{"@type":"ListItem","position":2,"name":"Linux Sunucuda ECC SSL Sertifikası Üretme","item":"https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Linux Sunucuda ECC SSL Sertifikası Üretme","name":"Linux Sunucuda ECC SSL Sertifikası Üretme","description":"Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let\u0026rsquo;s Encrypt\u0026rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür.","keywords":["linux","ssl","security","ecc","elliptic curve"],"articleBody":"Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let’s Encrypt’in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür. Fakat bu kadar büyük bir anahtarın üretilmesi, ürettikten sonra TLS handshake sırasında kullanılması ve ziyaretçilerin kullandığı cihazlar ile uyumlu olması çoğu senaryoda sorun çıkarmaktadır. Örneğin 2048 bit yerine 4096 bit kullanıldığı zaman bazı denemelerimde 0.4-0.8 sn daha uzun handshake süreleri ile karşı karşıya kalıyorum. Sadece handshake in bu kadar uzaması sorun değilmiş gibi sunucuya da ekstra bir yük bindiriyor. Fakat 4096 bit RSA yerine 384 bit ECC sertifikası ürettiğiniz zaman çok daha hızlı bir sertifikaya sahip olduğunuz gibi aynı zamanda da 7680 bit RSA’ya (öyle bir boyut olsaydı) eşit bir güvenlik elde ediyorsunuz.\nPeki iyi güzel anlattın da bu işin aması nerede dediğinizi duyar gibiyim. Sizi üzeceğim fakat bu işin aması yok. Olmamasının sebebi ise işin arka plandaki matematikte saklı. Kısaca her iki sertifika üretim ve kullanımındaki ufak farklardan bahsedip, bunların nasıl ve neden büyük farklara neden olduğunu açıklayıp son kısımda da bonus olarak başlıkta yazmayan bir şeyden bahsedeceğim. (Sonuna kadar okumanız gerekecek bonus için :D)\nhttps://www.globalsign.com/en/blog/elliptic-curve-cryptography (Erişim Tarihi: 08.04.2023) ECC Sertifikasının üretim süreci Öncelikle (her zaman olduğu gibi) içinde bulunduğumuz Linux sürümünün paket yöneticisi ile son güncellemeleri konsol üzerinden yüklememiz gerekmektedir.\nUbuntu için: sudo apt update \u0026\u0026 sudo apt upgrade -y Fedora için: sudo yum update -y Arch Linux için: sudo pacman -Syyu Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) nginx servisini (ki bu servis dışarıdan HTTP/HTTPS bağlantıları almanıza yarayan servistir) yapılandırmaya başlıyoruz. Öncelikle çok karıştırılması nedeniyle belirtmek gerekir ki apache, nginx ve litespeed servisleri aynı işi yapan farklı servislerdir. Ben yönetimi daha kolay ve topluluk desteği daha çok diye NGINX’i terchi ettim.\nÖzel anahtarı oluşturalım İlk olarak, OpenSSL ile özel anahtarı oluşturuyoruz. Kullanacağımız OpenSSL komutu ecparam (EC parametre manipülasyonu) ve konfigürasyon parametrelerini bu komuta geçirmek için:\nopenssl ecparam -genkey -name secp384r1 -out privkey.pem -genkey seçeneği, OpenSSL’ye bir EC anahtarı oluşturmasını söyler. -name parametresi OpenSSL’ye hangi eğrinin kullanılacağını söyler. -out parametresi OpenSSL’ye çıktıyı bir dosyaya yazmasını söyler. OpenSSL’nin çıktısını varsayılan olarak PEM biçiminde yazdığını unutmayın. EC anahtarlarını işleyen ec komutuyla OpenSSL’nin doğru şeyi yaptığını kontrol edebiliriz:\nopenssl ec -in privkey.pem -noout -text -in girdi dosyasıdır -noout, OpenSSL’ye anahtarı çıkarmamasını söyler, bu da privkey.pem’i stdout’a anlamsızca yazdırır. -text, OpenSSL’ye anahtar hakkındaki bilgileri düz metin biçiminde yazmasını söyler Her şey yolunda giderse ve anahtar doğru şekilde oluşturulduysa, OpenSSL aşağıdakine benzer bir şey gösterecektir:\nread EC key Private-Key: (384 bit) priv: [gizli] pub: [gizli] ASN1 OID: secp384r1 NIST CURVE: P-384 Bu, anahtarın P-384 eğrisi ile oluşturulduğunu doğrular. Neden P-384 yerine P-512 kullanmıyoruz derseniz Let’s Encrypt ekliptik eğrilerde 384 bitten daha yüksek olursa imzalamıyor ve Google Chrome gibi modern tarayıcılar 512 bitlik ekliptik eğrileri kullanan internet sitelerini geçersiz olarak işaretliyor. Kısa cevap bu.\nSertifika için OpenSSL yapılandırması oluşturalım Şimdi TLS sertifikası almak istediğimiz etki alanına özgü parametreleri içeren bir OpenSSL yapılandırma dosyası oluşturmalıyız. Bu örnekte, bir openssl.cnf dosyasına aşağıdaki konfigürasyonu gireceğiz:\n[ req ] prompt = no encrypt_key = no default_md = sha512 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:www.example.com Bu yapılandırma seçeneklerinin kısa bir açıklaması:\nGerekli [ req ] bölümünde:\nprompt = no, OpenSSL’ye yapılandırma dosyasından olabildiğince fazla yapılandırma almasını söyler encrypt_key = no, OpenSSL’ye özel anahtarı bir parola ile şifrelememesini söyler. (Şifreli özel anahtarlar Nginx tarafından desteklenir, ancak ben onları kullanmıyorum.) default_md = sha512, OpenSSL’ye CSR’yi SHA512 ile imzalamasını söyler. (Bildiğim kadarıyla, Let’s Encrypt, imzaları için yalnızca SHA256’lı RSA’yı destekler, ancak bu, CSR’de daha güçlü şifreleme kullanamayacağımız anlamına gelmez.) distinguished_name = dname, OpenSSL’ye Ayırt Edici Ad yapılandırma seçenekleri için bir [ dname ] bölümü aramasını söyler. req_extensions = reqext, OpenSSL’ye, Konu Alternatif Adlarının (SAN’lar) yapılandırılmak istenen uzantılar için yapılandırma seçeneklerinde bir [ reqext ] bölümü aramasını söyler. Ayırt Edici Ad [ dname ] bölümünde:\nCN = example.com, sertifikanın Ortak Adını belirtir. emailAddress = admin@example.com e-posta adresiniz belirgin olmalıdır. İstenen Uzantılar [ reqext ] bölümünde, konuAltName, sertifika için SAN’ların listesini sağlar. (Chrome, v58’den itibaren, Ortak Adın SAN’lar listesine dahil edilmesini gerektirir). Let’s Encrypt v2, joker alan adlarını destekler, bu nedenle bu örnekte, apeks dışındaki ana bilgisayarlar için tek düzeyli bir joker karakter kullanabilirsiniz (*.example.com).\nSertifika İmzalama İsteği Oluşturalım İstemci tarafındaki son adım, OpenSSL kullanarak Sertifika İmzalama Talebi oluşturmaktır, ardından bunu imzalamak için Let’s Encrypt’e ileteceğiz ve imzalı sertifikayı geri alacağız.\nBir CSR oluşturmak için gereken OpenSSL komutu req ‘dir.\nopenssl req -new -config openssl.cnf -key privkey.pem -out csr.pem -new, OpenSSL’ye bir CSR oluşturduğumuzu söyler (ve mevcut bir CSR’yi incelemeyiz) -config openssl.cnf, yukarıda oluşturduğumuz yapılandırma dosyasını belirtir -key privkey.pem, yukarıda oluşturduğumuz özel anahtarı belirtir -out csr.pem OpenSSL’ye CSR’yi bir çıktı dosyasına yazmasını söyler (stdout yerine) CSR’yi doğru şekilde oluşturduğumuzu doğrulayabiliriz:\nopenssl req -in csr.pem -noout -text -verify -verify OpenSSL’nin CSR’deki imzayı doğrulamasını ister Bu, çıktıda beklenen şu sonuçları üretmelidir:\nverify OK Certificate Request: Data: Version: 1 (0x0) Subject: CN = example.com, emailAddress = admin@example.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (384 bit) pub: [gizli] ASN1 OID: secp384r1 NIST CURVE: P-384 Attributes: Requested Extensions: X509v3 Subject Alternative Name: DNS:example.com, DNS:www.example.com Signature Algorithm: ecdsa-with-SHA512 [gizli] Let’s Encrypt’ten sertifikamızı imzalamasını isteyin Son adım, CSR’yi bir ACME istemcisiyle Let’s Encrypt’e imzalaması için göndermektir, bu iş için certbot en yaygın istemcidir.\nCertbot istemcisine iletilen komut satırı seçenekleri, kurulumumuza, alan adımızın kayıtlı olduğu kişiye vb. bağlı olarak değişir. Genellikle certonly komutunu kullanmamız gerekir ve asterisks (*) kullandıysanız certbot DNS eklentilerinden birini kullanmanız gerekir.\nÖrneğin, example.com alan adı Cloudflare’de kayıtlıysa, son derece uygun olan ve sürece manuel müdahale gerektirmeyen doğrulamayı işlemek için ilgili eklentiyi kullanabiliriz. (Cloudflare eklentisini gizli token bilgileriyle yapılandırmak bu makalenin kapsamı dışındadır.)\nHer şeyin yolunda olduğundan emin olmak için önce --dry-run ile düzgün sonuç alınacağından emin olunması genellikle tavsiye edilir.\ncertbot nginx certonly --dry-run --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem Hatalı işlemeleri önlemek için karakterlerin etrafında tırnak işaretleri gereklidir ve genel olarak bunlar iyi bir fikirdir. --csr csr.pem certbot’a zaten bir sertifikamız olduğunu ve bizim için imzalaması için Let’s Encrypt’e ihtiyacımız olduğunu söyler. Certbot istemcisi, komut satırında istenen alan adları listesinin sertifikada listelenen alan adlarıyla eşleşip eşleşmediğini kontrol edecek ve alan adının bize ait olduğunu doğrulamak için Certbot NGINX eklentisini kullanacak ve herhangi bir sorun olup olmadığını bize bildirecektir.\nHiçbir şey yanlış değilse, size şunu söyleyecektir:\nIMPORTANT NOTES: - The dry run was successful. Gerçek komut hemen aşağıdaki gibidir:\ncertbot nginx certonly --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem (Uzun) bir gecikmeden sonra, istemci çıktı olarak şunları üretecektir:\nİmzalı sertifika: 0000_cert.pem Kök ve ara sertifikalar: 0000_chain.pem Sertifika + ara ürünler: 0001_chain.pem Bu noktada, CSR csr.pem silinebilir. Merak ediyorsak, x509 komutunu kullanarak istemci tarafından OpenSSL ile döndürülen sertifikaları inceleyebiliriz:\nopenssl x509 -in 0001_chain.pem -noout -text Ne yazık ki, yukarıda açıklandığı gibi Let’s Encrypt’in sertifikamızı bir SHA256 imzasıyla imzaladığını keşfedeceğiz. (Daha güvenli olmasının yanı sıra, SHA512, modern 64-bit CPU’larda SHA256’dan daha iyi performans gösterir.) Ancak açık anahtarımız yine de ECDSA kullanmalıdır.\nBu dosyalar sıradan değildir, bu yüzden onları daha bilgilendirici bir şekilde taşımalı ve düzenlemeliyiz.\nDebian Linux’ta, özel anahtarımı /home/KULLANICI_ADI/SSL/private/example.com/privkey.pem içinde tutarak etki alanlarım için alt dizinler oluşturmayı seviyorum ve sertifikalar:\n/home/KULLANICI_ADI/SSL/certs/example.com/cert.pem /home/KULLANICI_ADI/SSL/certs/example.com/chain.pem /home/KULLANICI_ADI/SSL/certs/example.com/fullchain.pem SON Her şeyi doğru yaptıysak, sertifikayı Chrome gibi bir web tarayıcısı ile incelediğimizde, bunun bir EC sertifikası olduğunu onaylayacaktır:\nhttps://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Erişim Tarihi: 08.04.2023) Mozilla Gözlemevi de bize A+ notu verecek!\nhttps://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Erişim Tarihi: 08.04.2023) Ayrıca SSL Labs’ın rapor sonucunda 384 Bitlik bir ECC sertifikası’nın kullanıldığını görebiliyoruz.\nSSL Labs Test Sonucu NOT: Bu yazıda Benjamin Black‘in aynı konulu yazısından faydalanılmıştır.\n","wordCount":"1294","inLanguage":"tr","datePublished":"2022-03-20T00:00:00Z","dateModified":"2024-04-16T22:17:43+02:00","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb-works.github.io/blog/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb-works.github.io/blog/ accesskey=h title="Wise (Alt + H)">Wise</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb-works.github.io/blog/en/ title=English aria-label=:gb:>🇬🇧</a></li><li><a href=https://wiseweb-works.github.io/blog/de/ title=Deutsch aria-label=:de:>🇩🇪</a></li></ul></div></div><ul id=menu><li><a href=https://wiseweb-works.github.io/blog/ title=Anasayfa><span>Anasayfa</span></a></li><li><a href=https://wiseweb-works.github.io/blog/post/ title=Blog><span>Blog</span></a></li><li><a href=https://wiseweb-works.github.io/blog/page/iletisim/ title=İletişim><span>İletişim</span></a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ title=Etiketler><span>Etiketler</span></a></li><li><a href=https://wiseweb-works.github.io/blog/archives/ title=Arşiv><span>Arşiv</span></a></li><li><a href=https://wiseweb-works.github.io/blog/search/ title="Ara 🔍"><span>Ara 🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Linux Sunucuda ECC SSL Sertifikası Üretme</h1><div class=post-meta><span title='2022-03-20 00:00:00 +0000 UTC'>20 Mart, 2022</span>&nbsp;·&nbsp;<span title='2024-04-16 22:17:43 +0200 +0200'>(Updated 16 Nisan, 2024)</span>&nbsp;·&nbsp;7 dk&nbsp;·&nbsp;1294 kelime&nbsp;·&nbsp;Wise&nbsp;|&nbsp;Çeviriler:<ul class=i18n_list><li><a href=https://wiseweb-works.github.io/blog/en/post/ecc-ssl-sertifikasi/>🇬🇧</a></li><li><a href=https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikasi/>🇩🇪</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/ecc-ssl-sertifikasi.md rel="noopener noreferrer" target=_blank>Düzenle</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>İçindekiler</span></summary><div class=inner><ul><li><a href=#giri%c5%9f-ve-%c3%b6zet aria-label="Giriş ve Özet">Giriş ve Özet</a><ul><li><a href=#ecc-sertifikas%c4%b1n%c4%b1n-%c3%bcretim-s%c3%bcreci aria-label="ECC Sertifikasının üretim süreci">ECC Sertifikasının üretim süreci</a></li><li><a href=#%c3%b6zel-anahtar%c4%b1-olu%c5%9ftural%c4%b1m aria-label="Özel anahtarı oluşturalım">Özel anahtarı oluşturalım</a></li><li><a href=#sertifika-i%c3%a7in-openssl-yap%c4%b1land%c4%b1rmas%c4%b1-olu%c5%9ftural%c4%b1m aria-label="Sertifika için OpenSSL yapılandırması oluşturalım">Sertifika için OpenSSL yapılandırması oluşturalım</a></li><li><a href=#sertifika-imzalama-iste%c4%9fi-olu%c5%9ftural%c4%b1m aria-label="Sertifika İmzalama İsteği Oluşturalım">Sertifika İmzalama İsteği Oluşturalım</a></li><li><a href=#lets-encryptten-sertifikam%c4%b1z%c4%b1-imzalamas%c4%b1n%c4%b1-isteyin aria-label="Let&rsquo;s Encrypt&rsquo;ten sertifikamızı imzalamasını isteyin">Let&rsquo;s Encrypt&rsquo;ten sertifikamızı imzalamasını isteyin</a></li></ul></li><li><a href=#son aria-label=SON>SON</a></li></ul></div></details></div><div class=post-content><h1 id=giriş-ve-özet>Giriş ve Özet<a hidden class=anchor aria-hidden=true href=#giriş-ve-özet>#</a></h1><p>Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür. Fakat bu kadar büyük bir anahtarın üretilmesi, ürettikten sonra TLS handshake sırasında kullanılması ve ziyaretçilerin kullandığı cihazlar ile uyumlu olması çoğu senaryoda sorun çıkarmaktadır. Örneğin 2048 bit yerine 4096 bit kullanıldığı zaman bazı denemelerimde 0.4-0.8 sn daha uzun handshake süreleri ile karşı karşıya kalıyorum. Sadece handshake in bu kadar uzaması sorun değilmiş gibi sunucuya da ekstra bir yük bindiriyor. Fakat 4096 bit RSA yerine 384 bit ECC sertifikası ürettiğiniz zaman çok daha hızlı bir sertifikaya sahip olduğunuz gibi aynı zamanda da 7680 bit RSA&rsquo;ya (öyle bir boyut olsaydı) eşit bir güvenlik elde ediyorsunuz.</p><p>Peki iyi güzel anlattın da bu işin aması nerede dediğinizi duyar gibiyim. Sizi üzeceğim fakat bu işin aması yok. Olmamasının sebebi ise işin arka plandaki matematikte saklı. Kısaca her iki sertifika üretim ve kullanımındaki ufak farklardan bahsedip, bunların nasıl ve neden büyük farklara neden olduğunu açıklayıp son kısımda da bonus olarak başlıkta yazmayan bir şeyden bahsedeceğim. (Sonuna kadar okumanız gerekecek bonus için :D)</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.jpg loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://www.globalsign.com/en/blog/elliptic-curve-cryptography (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><h2 id=ecc-sertifikasının-üretim-süreci>ECC Sertifikasının üretim süreci<a hidden class=anchor aria-hidden=true href=#ecc-sertifikasının-üretim-süreci>#</a></h2><p>Öncelikle (her zaman olduğu gibi) içinde bulunduğumuz Linux sürümünün paket yöneticisi ile son güncellemeleri konsol üzerinden yüklememiz gerekmektedir.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Ubuntu için: sudo apt update <span style=color:#f92672>&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Fedora için: sudo yum update -y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Arch Linux için: sudo pacman -Syyu
</span></span></code></pre></div><p>Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) nginx servisini (ki bu servis dışarıdan HTTP/HTTPS bağlantıları almanıza yarayan servistir) yapılandırmaya başlıyoruz. Öncelikle çok karıştırılması nedeniyle belirtmek gerekir ki apache, nginx ve litespeed servisleri aynı işi yapan farklı servislerdir. Ben yönetimi daha kolay ve topluluk desteği daha çok diye NGINX&rsquo;i terchi ettim.</p><h2 id=özel-anahtarı-oluşturalım>Özel anahtarı oluşturalım<a hidden class=anchor aria-hidden=true href=#özel-anahtarı-oluşturalım>#</a></h2><p>İlk olarak, OpenSSL ile özel anahtarı oluşturuyoruz. Kullanacağımız OpenSSL komutu <code>ecparam</code> (EC parametre manipülasyonu) ve konfigürasyon parametrelerini bu komuta geçirmek için:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</span></span></code></pre></div><ul><li><code>-genkey</code> seçeneği, OpenSSL&rsquo;ye bir EC anahtarı oluşturmasını söyler.</li><li><code>-name</code> parametresi OpenSSL&rsquo;ye hangi eğrinin kullanılacağını söyler.</li><li><code>-out</code> parametresi OpenSSL&rsquo;ye çıktıyı bir dosyaya yazmasını söyler.</li></ul><p>OpenSSL&rsquo;nin çıktısını varsayılan olarak PEM biçiminde yazdığını unutmayın. EC anahtarlarını işleyen <code>ec</code> komutuyla OpenSSL&rsquo;nin doğru şeyi yaptığını kontrol edebiliriz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl ec -in privkey.pem -noout -text
</span></span></code></pre></div><ul><li><code>-in</code> girdi dosyasıdır</li><li><code>-noout</code>, OpenSSL&rsquo;ye anahtarı çıkarmamasını söyler, bu da privkey.pem&rsquo;i stdout&rsquo;a anlamsızca yazdırır.</li><li><code>-text</code>, OpenSSL&rsquo;ye anahtar hakkındaki bilgileri düz metin biçiminde yazmasını söyler</li></ul><p>Her şey yolunda giderse ve anahtar doğru şekilde oluşturulduysa, OpenSSL aşağıdakine benzer bir şey gösterecektir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>read EC key
</span></span><span style=display:flex><span>Private-Key: (384 bit)
</span></span><span style=display:flex><span>priv:
</span></span><span style=display:flex><span>    [gizli]
</span></span><span style=display:flex><span>pub:
</span></span><span style=display:flex><span>    [gizli]
</span></span><span style=display:flex><span>ASN1 OID: secp384r1
</span></span><span style=display:flex><span>NIST CURVE: P-384
</span></span></code></pre></div><p>Bu, anahtarın P-384 eğrisi ile oluşturulduğunu doğrular. Neden P-384 yerine P-512 kullanmıyoruz derseniz Let&rsquo;s Encrypt ekliptik eğrilerde 384 bitten daha yüksek olursa imzalamıyor ve Google Chrome gibi modern tarayıcılar 512 bitlik ekliptik eğrileri kullanan internet sitelerini geçersiz olarak işaretliyor. Kısa cevap bu.</p><h2 id=sertifika-için-openssl-yapılandırması-oluşturalım>Sertifika için OpenSSL yapılandırması oluşturalım<a hidden class=anchor aria-hidden=true href=#sertifika-için-openssl-yapılandırması-oluşturalım>#</a></h2><p>Şimdi TLS sertifikası almak istediğimiz etki alanına özgü parametreleri içeren bir OpenSSL yapılandırma dosyası oluşturmalıyız. Bu örnekte, bir <code>openssl.cnf</code> dosyasına aşağıdaki konfigürasyonu gireceğiz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[ req ]
</span></span><span style=display:flex><span>prompt = no
</span></span><span style=display:flex><span>encrypt_key = no
</span></span><span style=display:flex><span>default_md = sha512
</span></span><span style=display:flex><span>distinguished_name = dname
</span></span><span style=display:flex><span>req_extensions = reqext
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[ dname ]
</span></span><span style=display:flex><span>CN = example.com
</span></span><span style=display:flex><span>emailAddress = admin@example.com
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[ reqext ]
</span></span><span style=display:flex><span>subjectAltName = DNS:example.com, DNS:www.example.com
</span></span></code></pre></div><p>Bu yapılandırma seçeneklerinin kısa bir açıklaması:</p><p>Gerekli <code>[ req ]</code> bölümünde:</p><ul><li><code>prompt = no</code>, OpenSSL&rsquo;ye yapılandırma dosyasından olabildiğince fazla yapılandırma almasını söyler</li><li><code>encrypt_key = no</code>, OpenSSL&rsquo;ye özel anahtarı bir parola ile şifrelememesini söyler. (Şifreli özel anahtarlar Nginx tarafından desteklenir, ancak ben onları kullanmıyorum.)</li><li><code>default_md = sha512</code>, OpenSSL&rsquo;ye CSR&rsquo;yi SHA512 ile imzalamasını söyler. (Bildiğim kadarıyla, Let&rsquo;s Encrypt, imzaları için yalnızca SHA256&rsquo;lı RSA&rsquo;yı destekler, ancak bu, CSR&rsquo;de daha güçlü şifreleme kullanamayacağımız anlamına gelmez.)</li><li><code>distinguished_name = dname</code>, OpenSSL&rsquo;ye Ayırt Edici Ad yapılandırma seçenekleri için bir <code>[ dname ]</code> bölümü aramasını söyler.</li><li><code>req_extensions = reqext</code>, OpenSSL&rsquo;ye, Konu Alternatif Adlarının (SAN&rsquo;lar) yapılandırılmak istenen uzantılar için yapılandırma seçeneklerinde bir <code>[ reqext ]</code> bölümü aramasını söyler.</li></ul><p>Ayırt Edici Ad <code>[ dname ]</code> bölümünde:</p><ul><li><code>CN = example.com</code>, sertifikanın Ortak Adını belirtir.</li><li><code>emailAddress = admin@example.com</code> e-posta adresiniz belirgin olmalıdır.
İstenen Uzantılar <code>[ reqext ]</code> bölümünde, konuAltName, sertifika için SAN&rsquo;ların listesini sağlar. (Chrome, v58&rsquo;den itibaren, Ortak Adın SAN&rsquo;lar listesine dahil edilmesini gerektirir).</li></ul><p>Let&rsquo;s Encrypt v2, joker alan adlarını destekler, bu nedenle bu örnekte, apeks dışındaki ana bilgisayarlar için tek düzeyli bir joker karakter kullanabilirsiniz (*.example.com).</p><h2 id=sertifika-imzalama-isteği-oluşturalım>Sertifika İmzalama İsteği Oluşturalım<a hidden class=anchor aria-hidden=true href=#sertifika-imzalama-isteği-oluşturalım>#</a></h2><p>İstemci tarafındaki son adım, OpenSSL kullanarak Sertifika İmzalama Talebi oluşturmaktır, ardından bunu imzalamak için Let&rsquo;s Encrypt&rsquo;e ileteceğiz ve imzalı sertifikayı geri alacağız.</p><p>Bir CSR oluşturmak için gereken OpenSSL komutu <code>req</code> &lsquo;dir.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</span></span></code></pre></div><ul><li><code>-new</code>, OpenSSL&rsquo;ye bir CSR oluşturduğumuzu söyler (ve mevcut bir CSR&rsquo;yi incelemeyiz)</li><li><code>-config</code> openssl.cnf, yukarıda oluşturduğumuz yapılandırma dosyasını belirtir</li><li><code>-key privkey.pem</code>, yukarıda oluşturduğumuz özel anahtarı belirtir</li><li><code>-out csr.pem</code> OpenSSL&rsquo;ye CSR&rsquo;yi bir çıktı dosyasına yazmasını söyler (stdout yerine)</li></ul><p>CSR&rsquo;yi doğru şekilde oluşturduğumuzu doğrulayabiliriz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -in csr.pem -noout -text -verify
</span></span></code></pre></div><ul><li><code>-verify</code> OpenSSL&rsquo;nin CSR&rsquo;deki imzayı doğrulamasını ister</li></ul><p>Bu, çıktıda beklenen şu sonuçları üretmelidir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>verify OK
</span></span><span style=display:flex><span>Certificate Request:
</span></span><span style=display:flex><span>    Data:
</span></span><span style=display:flex><span>        Version: 1 (0x0)
</span></span><span style=display:flex><span>        Subject: CN = example.com, emailAddress = admin@example.com
</span></span><span style=display:flex><span>        Subject Public Key Info:
</span></span><span style=display:flex><span>            Public Key Algorithm: id-ecPublicKey
</span></span><span style=display:flex><span>                Public-Key: (384 bit)
</span></span><span style=display:flex><span>                pub:
</span></span><span style=display:flex><span>                    [gizli]
</span></span><span style=display:flex><span>                ASN1 OID: secp384r1
</span></span><span style=display:flex><span>                NIST CURVE: P-384
</span></span><span style=display:flex><span>        Attributes:
</span></span><span style=display:flex><span>        Requested Extensions:
</span></span><span style=display:flex><span>            X509v3 Subject Alternative Name:
</span></span><span style=display:flex><span>                DNS:example.com, DNS:www.example.com
</span></span><span style=display:flex><span>    Signature Algorithm: ecdsa-with-SHA512
</span></span><span style=display:flex><span>         [gizli]
</span></span></code></pre></div><h2 id=lets-encryptten-sertifikamızı-imzalamasını-isteyin>Let&rsquo;s Encrypt&rsquo;ten sertifikamızı imzalamasını isteyin<a hidden class=anchor aria-hidden=true href=#lets-encryptten-sertifikamızı-imzalamasını-isteyin>#</a></h2><p>Son adım, CSR&rsquo;yi bir ACME istemcisiyle Let&rsquo;s Encrypt&rsquo;e imzalaması için göndermektir, bu iş için <code>certbot</code> en yaygın istemcidir.</p><p><code>Certbot</code> istemcisine iletilen komut satırı seçenekleri, kurulumumuza, alan adımızın kayıtlı olduğu kişiye vb. bağlı olarak değişir. Genellikle <code>certonly</code> komutunu kullanmamız gerekir ve asterisks (*) kullandıysanız certbot DNS eklentilerinden birini kullanmanız gerekir.</p><p>Örneğin, <code>example.com</code> alan adı Cloudflare&rsquo;de kayıtlıysa, son derece uygun olan ve sürece manuel müdahale gerektirmeyen doğrulamayı işlemek için ilgili eklentiyi kullanabiliriz. (Cloudflare eklentisini gizli token bilgileriyle yapılandırmak bu makalenin kapsamı dışındadır.)</p><p>Her şeyin yolunda olduğundan emin olmak için önce <code>--dry-run</code> ile düzgün sonuç alınacağından emin olunması genellikle tavsiye edilir.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>certbot nginx certonly --dry-run --domain <span style=color:#e6db74>&#34;example.com&#34;</span> --domain <span style=color:#e6db74>&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><ul><li>Hatalı işlemeleri önlemek için karakterlerin etrafında tırnak işaretleri gereklidir ve genel olarak bunlar iyi bir fikirdir.</li><li><code>--csr csr.pem</code> certbot&rsquo;a zaten bir sertifikamız olduğunu ve bizim için imzalaması için Let&rsquo;s Encrypt&rsquo;e ihtiyacımız olduğunu söyler.</li></ul><p>Certbot istemcisi, komut satırında istenen alan adları listesinin sertifikada listelenen alan adlarıyla eşleşip eşleşmediğini kontrol edecek ve alan adının bize ait olduğunu doğrulamak için Certbot NGINX eklentisini kullanacak ve herhangi bir sorun olup olmadığını bize bildirecektir.</p><p>Hiçbir şey yanlış değilse, size şunu söyleyecektir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>IMPORTANT NOTES:
</span></span><span style=display:flex><span> - The dry run was successful.
</span></span></code></pre></div><p>Gerçek komut hemen aşağıdaki gibidir:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>certbot nginx certonly --domain <span style=color:#e6db74>&#34;example.com&#34;</span> --domain <span style=color:#e6db74>&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><p>(Uzun) bir gecikmeden sonra, istemci çıktı olarak şunları üretecektir:</p><ol><li>İmzalı sertifika: <code>0000_cert.pem</code></li><li>Kök ve ara sertifikalar: <code>0000_chain.pem</code></li><li>Sertifika + ara ürünler: <code>0001_chain.pem</code>
Bu noktada, CSR <code>csr.pem</code> silinebilir.</li></ol><p>Merak ediyorsak, <code>x509</code> komutunu kullanarak istemci tarafından OpenSSL ile döndürülen sertifikaları inceleyebiliriz:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl x509 -in 0001_chain.pem -noout -text
</span></span></code></pre></div><p>Ne yazık ki, yukarıda açıklandığı gibi Let&rsquo;s Encrypt&rsquo;in sertifikamızı bir SHA256 imzasıyla imzaladığını keşfedeceğiz. (Daha güvenli olmasının yanı sıra, SHA512, modern 64-bit CPU&rsquo;larda SHA256&rsquo;dan daha iyi performans gösterir.) Ancak açık anahtarımız yine de ECDSA kullanmalıdır.</p><p>Bu dosyalar sıradan değildir, bu yüzden onları daha bilgilendirici bir şekilde taşımalı ve düzenlemeliyiz.</p><p>Debian Linux&rsquo;ta, özel anahtarımı <code>/home/KULLANICI_ADI/SSL/private/example.com/privkey.pem</code> içinde tutarak etki alanlarım için alt dizinler oluşturmayı seviyorum ve sertifikalar:</p><ul><li><code>/home/KULLANICI_ADI/SSL/certs/example.com/cert.pem</code></li><li><code>/home/KULLANICI_ADI/SSL/certs/example.com/chain.pem</code></li><li><code>/home/KULLANICI_ADI/SSL/certs/example.com/fullchain.pem</code></li></ul><h1 id=son>SON<a hidden class=anchor aria-hidden=true href=#son>#</a></h1><p>Her şeyi doğru yaptıysak, sertifikayı Chrome gibi bir web tarayıcısı ile incelediğimizde, bunun bir EC sertifikası olduğunu onaylayacaktır:</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><p>Mozilla Gözlemevi de bize A+ notu verecek!</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Erişim Tarihi: 08.04.2023)</b></small></center></picture></p><p>Ayrıca SSL Labs&rsquo;ın rapor sonucunda 384 Bitlik bir ECC sertifikası&rsquo;nın kullanıldığını görebiliyoruz.</p><p><picture><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.avif type=image/avif><source srcset=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.webp type=image/webp><img src=https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.png loading=lazy decoding=async width=min(100%, 720px) height=auto><center><small><b>SSL Labs Test Sonucu</b></small></center></picture></p><p>NOT: Bu yazıda <a href=https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc>Benjamin Black</a>&lsquo;in aynı konulu yazısından faydalanılmıştır.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb-works.github.io/blog/tags/linux/>Linux</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ssl/>Ssl</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/security/>Security</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/ecc/>Ecc</a></li><li><a href=https://wiseweb-works.github.io/blog/tags/elliptic-curve/>Elliptic Curve</a></li></ul><nav class=paginav><a class=prev href=https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/><span class=title>« Önceki</span><br><span>OpenVPN Derinlemesine Anlatım</span>
</a><a class=next href=https://wiseweb-works.github.io/blog/post/ssl-konfigurasyonu/><span class=title>Sonraki »</span><br><span>Linux Sunucularda SSL güvenliğini arttırma</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://wiseweb-works.github.io/blog/>Wise</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Kopyala";function s(){t.innerHTML="Kopyalandı!",setTimeout(()=>{t.innerHTML="Kopyala"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>