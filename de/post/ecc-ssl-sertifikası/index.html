<!doctype html><html lang=de dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server | Wise</title><meta name=keywords content="linux,ssl,sicherheit,ecc,elliptische kurve"><meta name=description content="Einf√ºhrung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverl√§ssig und √ºberpr√ºfbar ist. In meinen vorherigen Artikeln habe ich erkl√§rt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen w√ºrden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung ‚Äûweniger Brot, mehr Frikadellen‚Äú aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb.works/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb.works/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb.works/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb.works/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb.works/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb.works/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=en href=https://wiseweb.works/en/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=de href=https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server"><meta property="og:description" content="Einf√ºhrung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverl√§ssig und √ºberpr√ºfbar ist. In meinen vorherigen Artikeln habe ich erkl√§rt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen w√ºrden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung ‚Äûweniger Brot, mehr Frikadellen‚Äú aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-20T00:00:00+00:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server"><meta name=twitter:description content="Einf√ºhrung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverl√§ssig und √ºberpr√ºfbar ist. In meinen vorherigen Artikeln habe ich erkl√§rt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen w√ºrden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung ‚Äûweniger Brot, mehr Frikadellen‚Äú aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server","item":"https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server","name":"Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server","description":"Einf√ºhrung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverl√§ssig und √ºberpr√ºfbar ist. In meinen vorherigen Artikeln habe ich erkl√§rt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen w√ºrden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung ‚Äûweniger Brot, mehr Frikadellen‚Äú aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen.","keywords":["linux","ssl","sicherheit","ecc","elliptische kurve"],"articleBody":"Einf√ºhrung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverl√§ssig und √ºberpr√ºfbar ist. In meinen vorherigen Artikeln habe ich erkl√§rt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen w√ºrden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung ‚Äûweniger Brot, mehr Frikadellen‚Äú aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen. Wenn Sie mit dem ACME-Protokoll von Let‚Äôs Encrypt vertraut sind (zum Zeitpunkt des Schreibens), ist es normalerweise m√∂glich, ein 1024-4098 (wenn Sie sich zu sehr anstrengen, vielleicht 8196) Bit-Zertifikat mit einer asymmetrischen RSA-Schl√ºsselstruktur zu generieren und es f√ºr zu verwenden 90 Tage relativ. Das Generieren eines so gro√üen Schl√ºssels, dessen Verwendung w√§hrend des TLS-Handshakes nach der Generierung und die Kompatibilit√§t mit den von den Besuchern verwendeten Ger√§ten verursachen jedoch in den meisten Szenarien Probleme. Wenn beispielsweise 4096 Bit anstelle von 2048 Bit verwendet werden, bin ich bei einigen meiner Versuche mit 0,4-0,8 Sekunden l√§ngeren Handshake-Zeiten konfrontiert. Als ob es in Ordnung w√§re, dass der Handshake so lange dauert, wird der Server dadurch zus√§tzlich belastet. Aber wenn Sie ein 384-Bit-ECC-Zertifikat anstelle von 4096-Bit-RSA generieren, erhalten Sie ein viel schnelleres Zertifikat und gleichzeitig eine Sicherheit, die 7680-Bit-RSA entspricht (wenn es diese Gr√∂√üe h√§tte).\nNun, Sie haben es gut erkl√§rt, aber wo ist der Sinn dieser Arbeit, scheine ich Sie sagen zu h√∂ren. Ich werde Sie ver√§rgern, aber dieses Gesch√§ft hat keinen Sinn. Der Grund, warum dies nicht der Fall ist, ist in der Hintergrundmathematik verborgen. Ich werde kurz auf die kleinen Unterschiede in der Herstellung und Verwendung beider Zertifikate eingehen, erkl√§ren, wie und warum sie gro√üe Unterschiede verursachen, und im letzten Teil werde ich √ºber etwas sprechen, das nicht als Bonus im Titel steht. (F√ºr den Bonus musst du bis zum Ende lesen :D)\nProduktionsprozess des ECC-Zertifikats Zuerst m√ºssen wir (wie immer) die neuesten Updates √ºber die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.\nUbuntu: sudo apt update \u0026\u0026 sudo apt upgrade -y Fedora: sudo yum update -y Arch Linux: sudo pacman -Syyu Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx-Dienstes (das ist der Dienst, der es Ihnen erm√∂glicht, externe HTTP/HTTPS-Verbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Zun√§chst einmal sollte angemerkt werden, dass es sich aufgrund der Verwirrung bei Apache-, Nginx- und Litespeed-Diensten um unterschiedliche Dienste handelt, die die gleiche Aufgabe erf√ºllen. Ich habe mich f√ºr NGINX entschieden, weil es einfacher zu verwalten ist und mehr Community-Unterst√ºtzung bietet.\nLassen Sie uns den privaten Schl√ºssel generieren Zuerst generieren wir den privaten Schl√ºssel mit OpenSSL. Der OpenSSL-Befehl, den wir verwenden werden, ist ‚Äûecparam‚Äú (EC-Parametermanipulation) und um die Konfigurationsparameter an diesen Befehl zu √ºbergeben:\nopenssl ecparam -genkey -name secp384r1 -out privkey.pem  Die Option -genkey weist OpenSSL an, einen EC-Schl√ºssel zu generieren. Der Parameter -name teilt OpenSSL mit, welche Kurve verwendet werden soll. Der Parameter -out weist OpenSSL an, die Ausgabe in eine Datei zu schreiben.  Beachten Sie, dass OpenSSL seine Ausgabe standardm√§√üig im PEM-Format schreibt. Wir k√∂nnen √ºberpr√ºfen, ob OpenSSL das Richtige tut, mit dem Befehl ec, der EC-Schl√ºssel verarbeitet:\nopenssl ec -in privkey.pem -noout -text  -in ist eine Eingabedatei Das -noout weist OpenSSL an, den Schl√ºssel nicht zu extrahieren, und gibt sinnlos privkey.pem nach stdout aus. -text weist OpenSSL an, Informationen √ºber den Schl√ºssel im Klartextformat zu schreiben  Wenn alles gut geht und der Schl√ºssel korrekt generiert wurde, zeigt OpenSSL etwa Folgendes:\nread EC key Private-Key: (384 bit) priv: [secret] pub: [secret] ASN1 OID: secp384r1 NIST CURVE: P-384 Dadurch wird best√§tigt, dass der Schl√ºssel mit der P-384-Kurve erstellt wurde. Wenn Sie sich fragen, warum wir nicht P-512 statt P-384 verwenden, Let‚Äôs Encrypt signiert nicht, wenn die Ekliptikkurven h√∂her als 384 Bit sind, und moderne Browser wie Google Chrome markieren Websites, die 512-Bit-Ekliptikkurven verwenden, als ung√ºltig . Das ist die kurze Antwort.\nErstellen wir eine OpenSSL-Konfiguration f√ºr das Zertifikat Jetzt m√ºssen wir eine OpenSSL-Konfigurationsdatei erstellen, die die dom√§nenspezifischen Parameter enth√§lt, f√ºr die wir das TLS-Zertifikat erhalten m√∂chten. In diesem Beispiel tragen wir die folgende Konfiguration in eine openssl.cnf-Datei ein:\n[ req ] prompt = no encrypt_key = no default_md = sha512 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:www.example.com Hier ist eine kurze Beschreibung dieser Konfigurationsoptionen:\nIm erforderlichen [ req ]-Abschnitt:\n prompt=no weist OpenSSL an, so viel Konfiguration wie m√∂glich aus der Konfigurationsdatei zu holen encrypt_key = no weist OpenSSL an, den privaten Schl√ºssel nicht mit einem Passwort zu verschl√ºsseln. (Verschl√ºsselte private Schl√ºssel werden von Nginx unterst√ºtzt, aber ich verwende sie nicht.) default_md=sha512 weist OpenSSL an, die CSR mit SHA512 zu signieren. (Soweit ich wei√ü, unterst√ºtzt Let‚Äôs Encrypt nur RSA mit SHA256 f√ºr seine Signaturen, aber das bedeutet nicht, dass wir in CSR keine st√§rkere Verschl√ºsselung verwenden k√∂nnen.) distinguished_name=dname weist OpenSSL an, nach einem [ dname ]-Abschnitt f√ºr Konfigurationsoptionen f√ºr Distinguished Name zu suchen. ‚Äûreq_extensions=reqext‚Äú weist OpenSSL an, in den Konfigurationsoptionen nach ‚ÄûSubject Alternative Names‚Äú (SANs)-Erweiterungen, die es konfigurieren m√∂chte, nach einem ‚Äû[ reqext ]‚Äú-Abschnitt zu suchen.  Im Abschnitt Distinguished Name [ dname ]:\n ‚ÄûCN = example.com‚Äú gibt den Common Name des Zertifikats an. Ihre emailAddress = admin@example.com E-Mail-Adresse muss prominent sein. Gew√ºnschte Erweiterungen Im Abschnitt ‚Äû[ reqext ]‚Äú stellt subjectAltName die Liste der SANs f√ºr das Zertifikat bereit. (Chrome ab v58 erfordert, dass der Common Name in der Liste der SANs enthalten ist).  Let‚Äôs Encrypt v2 unterst√ºtzt Platzhalterdom√§nen, daher k√∂nnen Sie in diesem Beispiel einen einstufigen Platzhalter f√ºr Nicht-Apex-Hosts (*.example.com) verwenden.\nLassen Sie uns eine Zertifikatsignieranforderung erstellen Der letzte Schritt auf der Client-Seite besteht darin, die Zertifikatsignieranforderung mit OpenSSL zu generieren, dann leiten wir sie zum Signieren an Let‚Äôs Encrypt weiter und rufen das signierte Zertifikat ab.\nDer zum Generieren einer CSR erforderliche OpenSSL-Befehl lautet req .\nopenssl req -new -config openssl.cnf -key privkey.pem -out csr.pem  -new teilt OpenSSL mit, dass wir eine CSR erstellt haben (und wir keine bestehende CSR untersuchen) -config openssl.cnf gibt die Konfigurationsdatei an, die wir oben erstellt haben -key privkey.pem gibt den privaten Schl√ºssel an, den wir oben erstellt haben -out csr.pem weist OpenSSL an, die CSR in eine Ausgabedatei zu schreiben (anstelle von stdout)  Wir k√∂nnen √ºberpr√ºfen, ob wir die CSR korrekt erstellt haben:\nopenssl req -in csr.pem -noout -text -verify  -verify fordert OpenSSL auf, die Signatur in der CSR zu verifizieren  Dies sollte die folgenden erwarteten Ergebnisse in der Ausgabe erzeugen:\nverify OK Certificate Request: Data: Version: 1 (0x0) Subject: CN = example.com, emailAddress = admin@example.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (384 bit) pub: [ommited] ASN1 OID: secp384r1 NIST CURVE: P-384 Attributes: Requested Extensions: X509v3 Subject Alternative Name: DNS:example.com, DNS:www.example.com Signature Algorithm: ecdsa-with-SHA512 [ommited] Bitten Sie Let‚Äôs Encrypt, unser Zertifikat zu signieren Der letzte Schritt besteht darin, die CSR mit einem ACME-Client zum Signieren an Let‚Äôs Encrypt zu senden, ‚Äúcertbot‚Äù ist der h√§ufigste Client f√ºr diesen Job.\nBefehlszeilenoptionen, die an den ‚ÄûCertbot‚Äú-Client √ºbergeben werden, h√§ngen von unserem Setup, der Person, f√ºr die unsere Domain registriert ist, usw. ab. Normalerweise m√ºssen wir den Befehl ‚Äúcertonly‚Äù verwenden, und wenn Sie Sternchen (*) verwendet haben, m√ºssen Sie eines der certbot-DNS-Plugins verwenden.\nIst beispielsweise die Domain ‚Äûexample.com‚Äú bei Cloudflare registriert, k√∂nnen wir die Verifizierung √ºber das entsprechende Plugin durchf√ºhren, was √§u√üerst komfortabel ist und keinen manuellen Eingriff in den Vorgang erfordert. (Das Konfigurieren des Cloudflare-Plugins mit geheimen Token-Informationen w√ºrde den Rahmen dieses Artikels sprengen.)\nEs wird normalerweise empfohlen, zuerst mit --dry-run sicherzustellen, dass alles in Ordnung ist, um sicherzustellen, dass alles in Ordnung ist.\ncertbot nginx certonly --dry-run --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem  Anf√ºhrungszeichen sind um Zeichen herum erforderlich, um fehlerhafte Manipulationen zu vermeiden, und sind im Allgemeinen eine gute Idee. --csr csr.pem teilt certbot mit, dass wir bereits ein Zertifikat haben und Let‚Äôs Encrypt ben√∂tigen, um es f√ºr uns zu signieren.  Der Certbot-Client √ºberpr√ºft auf der Befehlszeile, ob die angeforderte Liste der Dom√§nen mit den im Zertifikat aufgef√ºhrten Dom√§nen √ºbereinstimmt, und verwendet das Certbot-NGINX-Plug-in, um zu √ºberpr√ºfen, ob die Dom√§ne unsere ist, und teilt uns mit, falls es Probleme gibt.\nWenn nichts falsch ist, wird es Ihnen sagen:\nWICHTIGE NOTIZEN: - Der Probelauf war erfolgreich. Der eigentliche Befehl lautet wie folgt:\ncertbot nginx certonly --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem Nach einer (langen) Verz√∂gerung gibt der Client Folgendes aus:\n Signiertes Zertifikat: 0000_cert.pem Stamm- und Zwischenzertifikate: ‚Äû0000_chain.pem‚Äú. Zertifikat + Zwischenprodukte: 0001_chain.pem An dieser Stelle kann die CSR csr.pem gel√∂scht werden.  Wenn wir neugierig sind, k√∂nnen wir die vom Client zur√ºckgegebenen Zertifikate mit OpenSSL mit dem Befehl ‚Äúx509‚Äù √ºberpr√ºfen:\nopenssl x509 -in 0001_chain.pem -noout -text Leider werden wir feststellen, dass Let‚Äôs Encrypt wie oben beschrieben unser Zertifikat mit einer SHA256-Signatur signiert. (SHA512 ist nicht nur sicherer, sondern √ºbertrifft SHA256 auf modernen 64-Bit-CPUs.) Aber unser √∂ffentlicher Schl√ºssel sollte immer noch ECDSA verwenden.\nDiese Dateien sind nicht gew√∂hnlich, daher m√ºssen wir sie auf informativere Weise verschieben und bearbeiten.\nUnter Debian Linux erstelle ich gerne Unterverzeichnisse f√ºr meine Domains, indem ich meinen privaten Schl√ºssel in /home/USER_NAME/SSL/private/example.com/privkey.pem und Zertifikate behalte:\n /home/USER_NAME/SSL/certs/example.com/cert.pem /home/USER_NAME/SSL/certs/example.com/chain.pem /home/USER_NAME/SSL/certs/example.com/fullchain.pem  ENDE Wenn wir alles richtig gemacht haben, best√§tigt die √úberpr√ºfung des Zertifikats mit einem Webbrowser wie Chrome, dass es sich um ein EC-Zertifikat handelt:\nMozilla Observatory wird uns auch eine A+ Bewertung geben!\nDar√ºber hinaus k√∂nnen wir als Ergebnis des SSL Labs-Berichts sehen, dass ein 384-Bit-ECC-Zertifikat verwendet wurde.\nHINWEIS: Dieser Artikel profitiert vom Artikel von Benjamin Black zum gleichen Thema.\n","wordCount":"1553","inLanguage":"de","datePublished":"2022-03-20T00:00:00Z","dateModified":"2022-03-20T00:00:00Z","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb.works/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb.works/de/ accesskey=h title="Wise (Alt + H)">Wise</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb.works/ title=Turkish aria-label=:tr:>üáπüá∑</a></li><li><a href=https://wiseweb.works/en/ title=English aria-label=:gb:>üá¨üáß</a></li></ul></span></div><ul id=menu><li><a href=https://wiseweb.works/de/ title=Startzeite><span>Startzeite</span></a></li><li><a href=https://wiseweb.works/de/post/ title=Bloggen><span>Bloggen</span></a></li><li><a href=https://wiseweb.works/de/page/iletisim/ title=Kontakt><span>Kontakt</span></a></li><li><a href=https://wiseweb.works/de/tags/ title=Stichworte><span>Stichworte</span></a></li><li><a href=https://wiseweb.works/de/archives/ title=Archiv><span>Archiv</span></a></li><li><a href=https://wiseweb.works/de/search/ title="Suche üîç"><span>Suche üîç</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server</h1><div class=post-meta><span title="2022-03-20 00:00:00 +0000 UTC">20 M√§rz, 2022</span>&nbsp;¬∑&nbsp;8 Minuten&nbsp;¬∑&nbsp;Wise&nbsp;|&nbsp;<ul class=i18n_list>√úbersetzungen:<li><a href=https://wiseweb.works/post/ecc-ssl-sertifikas%C4%B1/>üáπüá∑</a></li><li><a href=https://wiseweb.works/en/post/ecc-ssl-sertifikas%C4%B1/>üá¨üáß</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/ecc-ssl-sertifikas%c4%b1.de.md rel="noopener noreferrer" target=_blank>Bearbeiten</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Inhaltsverzeichnis</span></summary><div class=inner><ul><li><a href=#einf%c3%bchrung-und-zusammenfassung aria-label="Einf√ºhrung und Zusammenfassung">Einf√ºhrung und Zusammenfassung</a><ul><li><a href=#produktionsprozess-des-ecc-zertifikats aria-label="Produktionsprozess des ECC-Zertifikats">Produktionsprozess des ECC-Zertifikats</a></li><li><a href=#lassen-sie-uns-den-privaten-schl%c3%bcssel-generieren aria-label="Lassen Sie uns den privaten Schl√ºssel generieren">Lassen Sie uns den privaten Schl√ºssel generieren</a></li><li><a href=#erstellen-wir-eine-openssl-konfiguration-f%c3%bcr-das-zertifikat aria-label="Erstellen wir eine OpenSSL-Konfiguration f√ºr das Zertifikat">Erstellen wir eine OpenSSL-Konfiguration f√ºr das Zertifikat</a></li><li><a href=#lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen aria-label="Lassen Sie uns eine Zertifikatsignieranforderung erstellen">Lassen Sie uns eine Zertifikatsignieranforderung erstellen</a></li><li><a href=#bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren aria-label="Bitten Sie Let&amp;rsquo;s Encrypt, unser Zertifikat zu signieren">Bitten Sie Let&rsquo;s Encrypt, unser Zertifikat zu signieren</a></li></ul></li><li><a href=#ende aria-label=ENDE>ENDE</a></li></ul></div></details></div><div class=post-content><h1 id=einf√ºhrung-und-zusammenfassung>Einf√ºhrung und Zusammenfassung<a hidden class=anchor aria-hidden=true href=#einf√ºhrung-und-zusammenfassung>#</a></h1><p>Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverl√§ssig und √ºberpr√ºfbar ist. In meinen vorherigen Artikeln habe ich erkl√§rt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen w√ºrden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung ‚Äûweniger Brot, mehr Frikadellen‚Äú aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen. Wenn Sie mit dem ACME-Protokoll von Let‚Äôs Encrypt vertraut sind (zum Zeitpunkt des Schreibens), ist es normalerweise m√∂glich, ein 1024-4098 (wenn Sie sich zu sehr anstrengen, vielleicht 8196) Bit-Zertifikat mit einer asymmetrischen RSA-Schl√ºsselstruktur zu generieren und es f√ºr zu verwenden 90 Tage relativ. Das Generieren eines so gro√üen Schl√ºssels, dessen Verwendung w√§hrend des TLS-Handshakes nach der Generierung und die Kompatibilit√§t mit den von den Besuchern verwendeten Ger√§ten verursachen jedoch in den meisten Szenarien Probleme. Wenn beispielsweise 4096 Bit anstelle von 2048 Bit verwendet werden, bin ich bei einigen meiner Versuche mit 0,4-0,8 Sekunden l√§ngeren Handshake-Zeiten konfrontiert. Als ob es in Ordnung w√§re, dass der Handshake so lange dauert, wird der Server dadurch zus√§tzlich belastet. Aber wenn Sie ein 384-Bit-ECC-Zertifikat anstelle von 4096-Bit-RSA generieren, erhalten Sie ein viel schnelleres Zertifikat und gleichzeitig eine Sicherheit, die 7680-Bit-RSA entspricht (wenn es diese Gr√∂√üe h√§tte).</p><p>Nun, Sie haben es gut erkl√§rt, aber wo ist der Sinn dieser Arbeit, scheine ich Sie sagen zu h√∂ren. Ich werde Sie ver√§rgern, aber dieses Gesch√§ft hat keinen Sinn. Der Grund, warum dies nicht der Fall ist, ist in der Hintergrundmathematik verborgen. Ich werde kurz auf die kleinen Unterschiede in der Herstellung und Verwendung beider Zertifikate eingehen, erkl√§ren, wie und warum sie gro√üe Unterschiede verursachen, und im letzten Teil werde ich √ºber etwas sprechen, das nicht als Bonus im Titel steht. (F√ºr den Bonus musst du bis zum Ende lesen :D)</p><p><img loading=lazy src=/images/key-size-comparison.jpg alt></p><h2 id=produktionsprozess-des-ecc-zertifikats>Produktionsprozess des ECC-Zertifikats<a hidden class=anchor aria-hidden=true href=#produktionsprozess-des-ecc-zertifikats>#</a></h2><p>Zuerst m√ºssen wir (wie immer) die neuesten Updates √ºber die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.</p><pre tabindex=0><code>Ubuntu: sudo apt update &amp;&amp; sudo apt upgrade -y

Fedora: sudo yum update -y

Arch Linux: sudo pacman -Syyu
</code></pre><p>Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx-Dienstes (das ist der Dienst, der es Ihnen erm√∂glicht, externe HTTP/HTTPS-Verbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Zun√§chst einmal sollte angemerkt werden, dass es sich aufgrund der Verwirrung bei Apache-, Nginx- und Litespeed-Diensten um unterschiedliche Dienste handelt, die die gleiche Aufgabe erf√ºllen. Ich habe mich f√ºr NGINX entschieden, weil es einfacher zu verwalten ist und mehr Community-Unterst√ºtzung bietet.</p><h2 id=lassen-sie-uns-den-privaten-schl√ºssel-generieren>Lassen Sie uns den privaten Schl√ºssel generieren<a hidden class=anchor aria-hidden=true href=#lassen-sie-uns-den-privaten-schl√ºssel-generieren>#</a></h2><p>Zuerst generieren wir den privaten Schl√ºssel mit OpenSSL. Der OpenSSL-Befehl, den wir verwenden werden, ist ‚Äûecparam‚Äú (EC-Parametermanipulation) und um die Konfigurationsparameter an diesen Befehl zu √ºbergeben:</p><pre tabindex=0><code>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</code></pre><ul><li>Die Option <code>-genkey</code> weist OpenSSL an, einen EC-Schl√ºssel zu generieren.</li><li>Der Parameter <code>-name</code> teilt OpenSSL mit, welche Kurve verwendet werden soll.</li><li>Der Parameter <code>-out</code> weist OpenSSL an, die Ausgabe in eine Datei zu schreiben.</li></ul><p>Beachten Sie, dass OpenSSL seine Ausgabe standardm√§√üig im PEM-Format schreibt. Wir k√∂nnen √ºberpr√ºfen, ob OpenSSL das Richtige tut, mit dem Befehl <code>ec</code>, der EC-Schl√ºssel verarbeitet:</p><pre tabindex=0><code>openssl ec -in privkey.pem -noout -text
</code></pre><ul><li><code>-in</code> ist eine Eingabedatei</li><li>Das <code>-noout</code> weist OpenSSL an, den Schl√ºssel nicht zu extrahieren, und gibt sinnlos privkey.pem nach stdout aus.</li><li><code>-text</code> weist OpenSSL an, Informationen √ºber den Schl√ºssel im Klartextformat zu schreiben</li></ul><p>Wenn alles gut geht und der Schl√ºssel korrekt generiert wurde, zeigt OpenSSL etwa Folgendes:</p><pre tabindex=0><code>read EC key
Private-Key: (384 bit)
priv:
    [secret]
pub:
    [secret]
ASN1 OID: secp384r1
NIST CURVE: P-384
</code></pre><p>Dadurch wird best√§tigt, dass der Schl√ºssel mit der P-384-Kurve erstellt wurde. Wenn Sie sich fragen, warum wir nicht P-512 statt P-384 verwenden, Let&rsquo;s Encrypt signiert nicht, wenn die Ekliptikkurven h√∂her als 384 Bit sind, und moderne Browser wie Google Chrome markieren Websites, die 512-Bit-Ekliptikkurven verwenden, als ung√ºltig . Das ist die kurze Antwort.</p><h2 id=erstellen-wir-eine-openssl-konfiguration-f√ºr-das-zertifikat>Erstellen wir eine OpenSSL-Konfiguration f√ºr das Zertifikat<a hidden class=anchor aria-hidden=true href=#erstellen-wir-eine-openssl-konfiguration-f√ºr-das-zertifikat>#</a></h2><p>Jetzt m√ºssen wir eine OpenSSL-Konfigurationsdatei erstellen, die die dom√§nenspezifischen Parameter enth√§lt, f√ºr die wir das TLS-Zertifikat erhalten m√∂chten. In diesem Beispiel tragen wir die folgende Konfiguration in eine <code>openssl.cnf</code>-Datei ein:</p><pre tabindex=0><code>[ req ]
prompt = no
encrypt_key = no
default_md = sha512
distinguished_name = dname
req_extensions = reqext

[ dname ]
CN = example.com
emailAddress = admin@example.com

[ reqext ]
subjectAltName = DNS:example.com, DNS:www.example.com
</code></pre><p>Hier ist eine kurze Beschreibung dieser Konfigurationsoptionen:</p><p>Im erforderlichen <code>[ req ]</code>-Abschnitt:</p><ul><li><code>prompt=no</code> weist OpenSSL an, so viel Konfiguration wie m√∂glich aus der Konfigurationsdatei zu holen</li><li><code>encrypt_key = no</code> weist OpenSSL an, den privaten Schl√ºssel nicht mit einem Passwort zu verschl√ºsseln. (Verschl√ºsselte private Schl√ºssel werden von Nginx unterst√ºtzt, aber ich verwende sie nicht.)</li><li><code>default_md=sha512</code> weist OpenSSL an, die CSR mit SHA512 zu signieren. (Soweit ich wei√ü, unterst√ºtzt Let&rsquo;s Encrypt nur RSA mit SHA256 f√ºr seine Signaturen, aber das bedeutet nicht, dass wir in CSR keine st√§rkere Verschl√ºsselung verwenden k√∂nnen.)</li><li><code>distinguished_name=dname</code> weist OpenSSL an, nach einem <code>[ dname ]</code>-Abschnitt f√ºr Konfigurationsoptionen f√ºr Distinguished Name zu suchen.</li><li>‚Äûreq_extensions=reqext‚Äú weist OpenSSL an, in den Konfigurationsoptionen nach ‚ÄûSubject Alternative Names‚Äú (SANs)-Erweiterungen, die es konfigurieren m√∂chte, nach einem ‚Äû[ reqext ]‚Äú-Abschnitt zu suchen.</li></ul><p>Im Abschnitt Distinguished Name <code>[ dname ]</code>:</p><ul><li>‚ÄûCN = example.com‚Äú gibt den Common Name des Zertifikats an.</li><li>Ihre <code>emailAddress = admin@example.com</code> E-Mail-Adresse muss prominent sein.
Gew√ºnschte Erweiterungen Im Abschnitt ‚Äû[ reqext ]‚Äú stellt subjectAltName die Liste der SANs f√ºr das Zertifikat bereit. (Chrome ab v58 erfordert, dass der Common Name in der Liste der SANs enthalten ist).</li></ul><p>Let&rsquo;s Encrypt v2 unterst√ºtzt Platzhalterdom√§nen, daher k√∂nnen Sie in diesem Beispiel einen einstufigen Platzhalter f√ºr Nicht-Apex-Hosts (*.example.com) verwenden.</p><h2 id=lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen>Lassen Sie uns eine Zertifikatsignieranforderung erstellen<a hidden class=anchor aria-hidden=true href=#lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen>#</a></h2><p>Der letzte Schritt auf der Client-Seite besteht darin, die Zertifikatsignieranforderung mit OpenSSL zu generieren, dann leiten wir sie zum Signieren an Let‚Äôs Encrypt weiter und rufen das signierte Zertifikat ab.</p><p>Der zum Generieren einer CSR erforderliche OpenSSL-Befehl lautet <code>req</code> .</p><pre tabindex=0><code>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</code></pre><ul><li><code>-new</code> teilt OpenSSL mit, dass wir eine CSR erstellt haben (und wir keine bestehende CSR untersuchen)</li><li><code>-config</code> openssl.cnf gibt die Konfigurationsdatei an, die wir oben erstellt haben</li><li><code>-key privkey.pem</code> gibt den privaten Schl√ºssel an, den wir oben erstellt haben</li><li><code>-out csr.pem</code> weist OpenSSL an, die CSR in eine Ausgabedatei zu schreiben (anstelle von stdout)</li></ul><p>Wir k√∂nnen √ºberpr√ºfen, ob wir die CSR korrekt erstellt haben:</p><pre tabindex=0><code>openssl req -in csr.pem -noout -text -verify
</code></pre><ul><li><code>-verify</code> fordert OpenSSL auf, die Signatur in der CSR zu verifizieren</li></ul><p>Dies sollte die folgenden erwarteten Ergebnisse in der Ausgabe erzeugen:</p><pre tabindex=0><code>verify OK
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: CN = example.com, emailAddress = admin@example.com
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    [ommited]
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:example.com, DNS:www.example.com
    Signature Algorithm: ecdsa-with-SHA512
         [ommited]
</code></pre><h2 id=bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren>Bitten Sie Let&rsquo;s Encrypt, unser Zertifikat zu signieren<a hidden class=anchor aria-hidden=true href=#bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren>#</a></h2><p>Der letzte Schritt besteht darin, die CSR mit einem ACME-Client zum Signieren an Let&rsquo;s Encrypt zu senden, &ldquo;certbot&rdquo; ist der h√§ufigste Client f√ºr diesen Job.</p><p>Befehlszeilenoptionen, die an den ‚ÄûCertbot‚Äú-Client √ºbergeben werden, h√§ngen von unserem Setup, der Person, f√ºr die unsere Domain registriert ist, usw. ab. Normalerweise m√ºssen wir den Befehl &ldquo;certonly&rdquo; verwenden, und wenn Sie Sternchen (*) verwendet haben, m√ºssen Sie eines der certbot-DNS-Plugins verwenden.</p><p>Ist beispielsweise die Domain ‚Äûexample.com‚Äú bei Cloudflare registriert, k√∂nnen wir die Verifizierung √ºber das entsprechende Plugin durchf√ºhren, was √§u√üerst komfortabel ist und keinen manuellen Eingriff in den Vorgang erfordert. (Das Konfigurieren des Cloudflare-Plugins mit geheimen Token-Informationen w√ºrde den Rahmen dieses Artikels sprengen.)</p><p>Es wird normalerweise empfohlen, zuerst mit <code>--dry-run</code> sicherzustellen, dass alles in Ordnung ist, um sicherzustellen, dass alles in Ordnung ist.</p><pre tabindex=0><code>certbot nginx certonly --dry-run --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><ul><li>Anf√ºhrungszeichen sind um Zeichen herum erforderlich, um fehlerhafte Manipulationen zu vermeiden, und sind im Allgemeinen eine gute Idee.</li><li><code>--csr csr.pem</code> teilt certbot mit, dass wir bereits ein Zertifikat haben und Let‚Äôs Encrypt ben√∂tigen, um es f√ºr uns zu signieren.</li></ul><p>Der Certbot-Client √ºberpr√ºft auf der Befehlszeile, ob die angeforderte Liste der Dom√§nen mit den im Zertifikat aufgef√ºhrten Dom√§nen √ºbereinstimmt, und verwendet das Certbot-NGINX-Plug-in, um zu √ºberpr√ºfen, ob die Dom√§ne unsere ist, und teilt uns mit, falls es Probleme gibt.</p><p>Wenn nichts falsch ist, wird es Ihnen sagen:</p><pre tabindex=0><code>WICHTIGE NOTIZEN:
 - Der Probelauf war erfolgreich.
</code></pre><p>Der eigentliche Befehl lautet wie folgt:</p><pre tabindex=0><code>certbot nginx certonly --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><p>Nach einer (langen) Verz√∂gerung gibt der Client Folgendes aus:</p><ol><li>Signiertes Zertifikat: <code>0000_cert.pem</code></li><li>Stamm- und Zwischenzertifikate: ‚Äû0000_chain.pem‚Äú.</li><li>Zertifikat + Zwischenprodukte: <code>0001_chain.pem</code>
An dieser Stelle kann die CSR <code>csr.pem</code> gel√∂scht werden.</li></ol><p>Wenn wir neugierig sind, k√∂nnen wir die vom Client zur√ºckgegebenen Zertifikate mit OpenSSL mit dem Befehl &ldquo;x509&rdquo; √ºberpr√ºfen:</p><pre tabindex=0><code>openssl x509 -in 0001_chain.pem -noout -text
</code></pre><p>Leider werden wir feststellen, dass Let‚Äôs Encrypt wie oben beschrieben unser Zertifikat mit einer SHA256-Signatur signiert. (SHA512 ist nicht nur sicherer, sondern √ºbertrifft SHA256 auf modernen 64-Bit-CPUs.) Aber unser √∂ffentlicher Schl√ºssel sollte immer noch ECDSA verwenden.</p><p>Diese Dateien sind nicht gew√∂hnlich, daher m√ºssen wir sie auf informativere Weise verschieben und bearbeiten.</p><p>Unter Debian Linux erstelle ich gerne Unterverzeichnisse f√ºr meine Domains, indem ich meinen privaten Schl√ºssel in <code>/home/USER_NAME/SSL/private/example.com/privkey.pem</code> und Zertifikate behalte:</p><ul><li><code>/home/USER_NAME/SSL/certs/example.com/cert.pem</code></li><li><code>/home/USER_NAME/SSL/certs/example.com/chain.pem</code></li><li><code>/home/USER_NAME/SSL/certs/example.com/fullchain.pem</code></li></ul><h1 id=ende>ENDE<a hidden class=anchor aria-hidden=true href=#ende>#</a></h1><p>Wenn wir alles richtig gemacht haben, best√§tigt die √úberpr√ºfung des Zertifikats mit einem Webbrowser wie Chrome, dass es sich um ein EC-Zertifikat handelt:</p><p><img loading=lazy src=/images/ecc-sll-key-chrome.png alt></p><p>Mozilla Observatory wird uns auch eine A+ Bewertung geben!</p><p><img loading=lazy src=/images/ecc-ssl-key-mozilla.png alt></p><p>Dar√ºber hinaus k√∂nnen wir als Ergebnis des SSL Labs-Berichts sehen, dass ein 384-Bit-ECC-Zertifikat verwendet wurde.</p><p><img loading=lazy src=/images/ecc-ssl-key-ssllabs.png alt></p><p>HINWEIS: Dieser Artikel profitiert vom Artikel von <a href=https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc>Benjamin Black</a> zum gleichen Thema.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb.works/de/tags/linux/>linux</a></li><li><a href=https://wiseweb.works/de/tags/ssl/>ssl</a></li><li><a href=https://wiseweb.works/de/tags/sicherheit/>sicherheit</a></li><li><a href=https://wiseweb.works/de/tags/ecc/>ecc</a></li><li><a href=https://wiseweb.works/de/tags/elliptische-kurve/>elliptische kurve</a></li></ul><nav class=paginav><a class=next href=https://wiseweb.works/de/post/ssl-konfigurasyonu/><span class=title>N√§chste Seite ¬ª</span><br><span>Erh√∂hung der SSL-Sicherheit auf Linux-Servern</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wiseweb.works/de/>Wise</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="Kopieren";function s(){e.innerText="Kopiert!",setTimeout(()=>{e.innerText="Kopieren"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>