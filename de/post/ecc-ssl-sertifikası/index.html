<!doctype html><html lang=de dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server | Wise</title><meta name=keywords content="linux,ssl,sicherheit,ecc,elliptische kurve"><meta name=description content="Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen."><meta name=author content="Wise"><link rel=canonical href=https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/><link crossorigin=anonymous href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style><link rel=icon href=https://wiseweb.works/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wiseweb.works/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wiseweb.works/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://wiseweb.works/favicons/apple-touch-icon.png><link rel=mask-icon href=https://wiseweb.works/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=tr href=https://wiseweb.works/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=en href=https://wiseweb.works/en/post/ecc-ssl-sertifikas%C4%B1/><link rel=alternate hreflang=de href=https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server"><meta property="og:description" content="Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen."><meta property="og:type" content="article"><meta property="og:url" content="https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-20T00:00:00+00:00"><meta property="og:site_name" content="Wise Web Works"><meta name=twitter:card content="summary"><meta name=twitter:title content="Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server"><meta name=twitter:description content="Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":4,"name":"Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server","item":"https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server","name":"Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server","description":"Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen.","keywords":["linux","ssl","sicherheit","ecc","elliptische kurve"],"articleBody":"Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen. Wenn Sie mit dem ACME-Protokoll von Let’s Encrypt vertraut sind (zum Zeitpunkt des Schreibens), ist es normalerweise möglich, ein 1024-4098 (wenn Sie sich zu sehr anstrengen, vielleicht 8196) Bit-Zertifikat mit einer asymmetrischen RSA-Schlüsselstruktur zu generieren und es für zu verwenden 90 Tage relativ. Das Generieren eines so großen Schlüssels, dessen Verwendung während des TLS-Handshakes nach der Generierung und die Kompatibilität mit den von den Besuchern verwendeten Geräten verursachen jedoch in den meisten Szenarien Probleme. Wenn beispielsweise 4096 Bit anstelle von 2048 Bit verwendet werden, bin ich bei einigen meiner Versuche mit 0,4-0,8 Sekunden längeren Handshake-Zeiten konfrontiert. Als ob es in Ordnung wäre, dass der Handshake so lange dauert, wird der Server dadurch zusätzlich belastet. Aber wenn Sie ein 384-Bit-ECC-Zertifikat anstelle von 4096-Bit-RSA generieren, erhalten Sie ein viel schnelleres Zertifikat und gleichzeitig eine Sicherheit, die 7680-Bit-RSA entspricht (wenn es diese Größe hätte).\nNun, Sie haben es gut erklärt, aber wo ist der Sinn dieser Arbeit, scheine ich Sie sagen zu hören. Ich werde Sie verärgern, aber dieses Geschäft hat keinen Sinn. Der Grund, warum dies nicht der Fall ist, ist in der Hintergrundmathematik verborgen. Ich werde kurz auf die kleinen Unterschiede in der Herstellung und Verwendung beider Zertifikate eingehen, erklären, wie und warum sie große Unterschiede verursachen, und im letzten Teil werde ich über etwas sprechen, das nicht als Bonus im Titel steht. (Für den Bonus musst du bis zum Ende lesen :D)\nProduktionsprozess des ECC-Zertifikats Zuerst müssen wir (wie immer) die neuesten Updates über die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.\nUbuntu: sudo apt update \u0026\u0026 sudo apt upgrade -y Fedora: sudo yum update -y Arch Linux: sudo pacman -Syyu Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx-Dienstes (das ist der Dienst, der es Ihnen ermöglicht, externe HTTP/HTTPS-Verbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Zunächst einmal sollte angemerkt werden, dass es sich aufgrund der Verwirrung bei Apache-, Nginx- und Litespeed-Diensten um unterschiedliche Dienste handelt, die die gleiche Aufgabe erfüllen. Ich habe mich für NGINX entschieden, weil es einfacher zu verwalten ist und mehr Community-Unterstützung bietet.\nLassen Sie uns den privaten Schlüssel generieren Zuerst generieren wir den privaten Schlüssel mit OpenSSL. Der OpenSSL-Befehl, den wir verwenden werden, ist „ecparam“ (EC-Parametermanipulation) und um die Konfigurationsparameter an diesen Befehl zu übergeben:\nopenssl ecparam -genkey -name secp384r1 -out privkey.pem  Die Option -genkey weist OpenSSL an, einen EC-Schlüssel zu generieren. Der Parameter -name teilt OpenSSL mit, welche Kurve verwendet werden soll. Der Parameter -out weist OpenSSL an, die Ausgabe in eine Datei zu schreiben.  Beachten Sie, dass OpenSSL seine Ausgabe standardmäßig im PEM-Format schreibt. Wir können überprüfen, ob OpenSSL das Richtige tut, mit dem Befehl ec, der EC-Schlüssel verarbeitet:\nopenssl ec -in privkey.pem -noout -text  -in ist eine Eingabedatei Das -noout weist OpenSSL an, den Schlüssel nicht zu extrahieren, und gibt sinnlos privkey.pem nach stdout aus. -text weist OpenSSL an, Informationen über den Schlüssel im Klartextformat zu schreiben  Wenn alles gut geht und der Schlüssel korrekt generiert wurde, zeigt OpenSSL etwa Folgendes:\nread EC key Private-Key: (384 bit) priv: [secret] pub: [secret] ASN1 OID: secp384r1 NIST CURVE: P-384 Dadurch wird bestätigt, dass der Schlüssel mit der P-384-Kurve erstellt wurde. Wenn Sie sich fragen, warum wir nicht P-512 statt P-384 verwenden, Let’s Encrypt signiert nicht, wenn die Ekliptikkurven höher als 384 Bit sind, und moderne Browser wie Google Chrome markieren Websites, die 512-Bit-Ekliptikkurven verwenden, als ungültig . Das ist die kurze Antwort.\nErstellen wir eine OpenSSL-Konfiguration für das Zertifikat Jetzt müssen wir eine OpenSSL-Konfigurationsdatei erstellen, die die domänenspezifischen Parameter enthält, für die wir das TLS-Zertifikat erhalten möchten. In diesem Beispiel tragen wir die folgende Konfiguration in eine openssl.cnf-Datei ein:\n[ req ] prompt = no encrypt_key = no default_md = sha512 distinguished_name = dname req_extensions = reqext [ dname ] CN = example.com emailAddress = admin@example.com [ reqext ] subjectAltName = DNS:example.com, DNS:www.example.com Hier ist eine kurze Beschreibung dieser Konfigurationsoptionen:\nIm erforderlichen [ req ]-Abschnitt:\n prompt=no weist OpenSSL an, so viel Konfiguration wie möglich aus der Konfigurationsdatei zu holen encrypt_key = no weist OpenSSL an, den privaten Schlüssel nicht mit einem Passwort zu verschlüsseln. (Verschlüsselte private Schlüssel werden von Nginx unterstützt, aber ich verwende sie nicht.) default_md=sha512 weist OpenSSL an, die CSR mit SHA512 zu signieren. (Soweit ich weiß, unterstützt Let’s Encrypt nur RSA mit SHA256 für seine Signaturen, aber das bedeutet nicht, dass wir in CSR keine stärkere Verschlüsselung verwenden können.) distinguished_name=dname weist OpenSSL an, nach einem [ dname ]-Abschnitt für Konfigurationsoptionen für Distinguished Name zu suchen. „req_extensions=reqext“ weist OpenSSL an, in den Konfigurationsoptionen nach „Subject Alternative Names“ (SANs)-Erweiterungen, die es konfigurieren möchte, nach einem „[ reqext ]“-Abschnitt zu suchen.  Im Abschnitt Distinguished Name [ dname ]:\n „CN = example.com“ gibt den Common Name des Zertifikats an. Ihre emailAddress = admin@example.com E-Mail-Adresse muss prominent sein. Gewünschte Erweiterungen Im Abschnitt „[ reqext ]“ stellt subjectAltName die Liste der SANs für das Zertifikat bereit. (Chrome ab v58 erfordert, dass der Common Name in der Liste der SANs enthalten ist).  Let’s Encrypt v2 unterstützt Platzhalterdomänen, daher können Sie in diesem Beispiel einen einstufigen Platzhalter für Nicht-Apex-Hosts (*.example.com) verwenden.\nLassen Sie uns eine Zertifikatsignieranforderung erstellen Der letzte Schritt auf der Client-Seite besteht darin, die Zertifikatsignieranforderung mit OpenSSL zu generieren, dann leiten wir sie zum Signieren an Let’s Encrypt weiter und rufen das signierte Zertifikat ab.\nDer zum Generieren einer CSR erforderliche OpenSSL-Befehl lautet req .\nopenssl req -new -config openssl.cnf -key privkey.pem -out csr.pem  -new teilt OpenSSL mit, dass wir eine CSR erstellt haben (und wir keine bestehende CSR untersuchen) -config openssl.cnf gibt die Konfigurationsdatei an, die wir oben erstellt haben -key privkey.pem gibt den privaten Schlüssel an, den wir oben erstellt haben -out csr.pem weist OpenSSL an, die CSR in eine Ausgabedatei zu schreiben (anstelle von stdout)  Wir können überprüfen, ob wir die CSR korrekt erstellt haben:\nopenssl req -in csr.pem -noout -text -verify  -verify fordert OpenSSL auf, die Signatur in der CSR zu verifizieren  Dies sollte die folgenden erwarteten Ergebnisse in der Ausgabe erzeugen:\nverify OK Certificate Request: Data: Version: 1 (0x0) Subject: CN = example.com, emailAddress = admin@example.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (384 bit) pub: [ommited] ASN1 OID: secp384r1 NIST CURVE: P-384 Attributes: Requested Extensions: X509v3 Subject Alternative Name: DNS:example.com, DNS:www.example.com Signature Algorithm: ecdsa-with-SHA512 [ommited] Bitten Sie Let’s Encrypt, unser Zertifikat zu signieren Der letzte Schritt besteht darin, die CSR mit einem ACME-Client zum Signieren an Let’s Encrypt zu senden, “certbot” ist der häufigste Client für diesen Job.\nBefehlszeilenoptionen, die an den „Certbot“-Client übergeben werden, hängen von unserem Setup, der Person, für die unsere Domain registriert ist, usw. ab. Normalerweise müssen wir den Befehl “certonly” verwenden, und wenn Sie Sternchen (*) verwendet haben, müssen Sie eines der certbot-DNS-Plugins verwenden.\nIst beispielsweise die Domain „example.com“ bei Cloudflare registriert, können wir die Verifizierung über das entsprechende Plugin durchführen, was äußerst komfortabel ist und keinen manuellen Eingriff in den Vorgang erfordert. (Das Konfigurieren des Cloudflare-Plugins mit geheimen Token-Informationen würde den Rahmen dieses Artikels sprengen.)\nEs wird normalerweise empfohlen, zuerst mit --dry-run sicherzustellen, dass alles in Ordnung ist, um sicherzustellen, dass alles in Ordnung ist.\ncertbot nginx certonly --dry-run --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem  Anführungszeichen sind um Zeichen herum erforderlich, um fehlerhafte Manipulationen zu vermeiden, und sind im Allgemeinen eine gute Idee. --csr csr.pem teilt certbot mit, dass wir bereits ein Zertifikat haben und Let’s Encrypt benötigen, um es für uns zu signieren.  Der Certbot-Client überprüft auf der Befehlszeile, ob die angeforderte Liste der Domänen mit den im Zertifikat aufgeführten Domänen übereinstimmt, und verwendet das Certbot-NGINX-Plug-in, um zu überprüfen, ob die Domäne unsere ist, und teilt uns mit, falls es Probleme gibt.\nWenn nichts falsch ist, wird es Ihnen sagen:\nWICHTIGE NOTIZEN: - Der Probelauf war erfolgreich. Der eigentliche Befehl lautet wie folgt:\ncertbot nginx certonly --domain \"example.com\" --domain \"www.example.com\" --csr csr.pem Nach einer (langen) Verzögerung gibt der Client Folgendes aus:\n Signiertes Zertifikat: 0000_cert.pem Stamm- und Zwischenzertifikate: „0000_chain.pem“. Zertifikat + Zwischenprodukte: 0001_chain.pem An dieser Stelle kann die CSR csr.pem gelöscht werden.  Wenn wir neugierig sind, können wir die vom Client zurückgegebenen Zertifikate mit OpenSSL mit dem Befehl “x509” überprüfen:\nopenssl x509 -in 0001_chain.pem -noout -text Leider werden wir feststellen, dass Let’s Encrypt wie oben beschrieben unser Zertifikat mit einer SHA256-Signatur signiert. (SHA512 ist nicht nur sicherer, sondern übertrifft SHA256 auf modernen 64-Bit-CPUs.) Aber unser öffentlicher Schlüssel sollte immer noch ECDSA verwenden.\nDiese Dateien sind nicht gewöhnlich, daher müssen wir sie auf informativere Weise verschieben und bearbeiten.\nUnter Debian Linux erstelle ich gerne Unterverzeichnisse für meine Domains, indem ich meinen privaten Schlüssel in /home/USER_NAME/SSL/private/example.com/privkey.pem und Zertifikate behalte:\n /home/USER_NAME/SSL/certs/example.com/cert.pem /home/USER_NAME/SSL/certs/example.com/chain.pem /home/USER_NAME/SSL/certs/example.com/fullchain.pem  ENDE Wenn wir alles richtig gemacht haben, bestätigt die Überprüfung des Zertifikats mit einem Webbrowser wie Chrome, dass es sich um ein EC-Zertifikat handelt:\nMozilla Observatory wird uns auch eine A+ Bewertung geben!\nDarüber hinaus können wir als Ergebnis des SSL Labs-Berichts sehen, dass ein 384-Bit-ECC-Zertifikat verwendet wurde.\nHINWEIS: Dieser Artikel profitiert vom Artikel von Benjamin Black zum gleichen Thema.\n","wordCount":"1553","inLanguage":"de","datePublished":"2022-03-20T00:00:00Z","dateModified":"2022-03-20T00:00:00Z","author":{"@type":"Person","name":"Wise"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wiseweb.works/de/post/ecc-ssl-sertifikas%C4%B1/"},"publisher":{"@type":"Organization","name":"Wise","logo":{"@type":"ImageObject","url":"https://wiseweb.works/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wiseweb.works/de/ accesskey=h title="Wise (Alt + H)">Wise</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://wiseweb.works/ title=Turkish aria-label=:tr:>🇹🇷</a></li><li><a href=https://wiseweb.works/en/ title=English aria-label=:gb:>🇬🇧</a></li></ul></span></div><ul id=menu><li><a href=https://wiseweb.works/de/ title=Startzeite><span>Startzeite</span></a></li><li><a href=https://wiseweb.works/de/post/ title=Bloggen><span>Bloggen</span></a></li><li><a href=https://wiseweb.works/de/page/iletisim/ title=Kontakt><span>Kontakt</span></a></li><li><a href=https://wiseweb.works/de/tags/ title=Stichworte><span>Stichworte</span></a></li><li><a href=https://wiseweb.works/de/archives/ title=Archiv><span>Archiv</span></a></li><li><a href=https://wiseweb.works/de/search/ title="Suche 🔍"><span>Suche 🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server</h1><div class=post-meta><span title="2022-03-20 00:00:00 +0000 UTC">20 März, 2022</span>&nbsp;·&nbsp;8 Minuten&nbsp;·&nbsp;Wise&nbsp;|&nbsp;<ul class=i18n_list>Übersetzungen:<li><a href=https://wiseweb.works/post/ecc-ssl-sertifikas%C4%B1/>🇹🇷</a></li><li><a href=https://wiseweb.works/en/post/ecc-ssl-sertifikas%C4%B1/>🇬🇧</a></li></ul>&nbsp;|&nbsp;<a href=https://github.com/wiseweb-works/blog/tree/master/content/post/ecc-ssl-sertifikas%c4%b1.de.md rel="noopener noreferrer" target=_blank>Bearbeiten</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Inhaltsverzeichnis</span></summary><div class=inner><ul><li><a href=#einf%c3%bchrung-und-zusammenfassung aria-label="Einführung und Zusammenfassung">Einführung und Zusammenfassung</a><ul><li><a href=#produktionsprozess-des-ecc-zertifikats aria-label="Produktionsprozess des ECC-Zertifikats">Produktionsprozess des ECC-Zertifikats</a></li><li><a href=#lassen-sie-uns-den-privaten-schl%c3%bcssel-generieren aria-label="Lassen Sie uns den privaten Schlüssel generieren">Lassen Sie uns den privaten Schlüssel generieren</a></li><li><a href=#erstellen-wir-eine-openssl-konfiguration-f%c3%bcr-das-zertifikat aria-label="Erstellen wir eine OpenSSL-Konfiguration für das Zertifikat">Erstellen wir eine OpenSSL-Konfiguration für das Zertifikat</a></li><li><a href=#lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen aria-label="Lassen Sie uns eine Zertifikatsignieranforderung erstellen">Lassen Sie uns eine Zertifikatsignieranforderung erstellen</a></li><li><a href=#bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren aria-label="Bitten Sie Let&amp;rsquo;s Encrypt, unser Zertifikat zu signieren">Bitten Sie Let&rsquo;s Encrypt, unser Zertifikat zu signieren</a></li></ul></li><li><a href=#ende aria-label=ENDE>ENDE</a></li></ul></div></details></div><div class=post-content><h1 id=einführung-und-zusammenfassung>Einführung und Zusammenfassung<a hidden class=anchor aria-hidden=true href=#einführung-und-zusammenfassung>#</a></h1><p>Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen. Wenn Sie mit dem ACME-Protokoll von Let’s Encrypt vertraut sind (zum Zeitpunkt des Schreibens), ist es normalerweise möglich, ein 1024-4098 (wenn Sie sich zu sehr anstrengen, vielleicht 8196) Bit-Zertifikat mit einer asymmetrischen RSA-Schlüsselstruktur zu generieren und es für zu verwenden 90 Tage relativ. Das Generieren eines so großen Schlüssels, dessen Verwendung während des TLS-Handshakes nach der Generierung und die Kompatibilität mit den von den Besuchern verwendeten Geräten verursachen jedoch in den meisten Szenarien Probleme. Wenn beispielsweise 4096 Bit anstelle von 2048 Bit verwendet werden, bin ich bei einigen meiner Versuche mit 0,4-0,8 Sekunden längeren Handshake-Zeiten konfrontiert. Als ob es in Ordnung wäre, dass der Handshake so lange dauert, wird der Server dadurch zusätzlich belastet. Aber wenn Sie ein 384-Bit-ECC-Zertifikat anstelle von 4096-Bit-RSA generieren, erhalten Sie ein viel schnelleres Zertifikat und gleichzeitig eine Sicherheit, die 7680-Bit-RSA entspricht (wenn es diese Größe hätte).</p><p>Nun, Sie haben es gut erklärt, aber wo ist der Sinn dieser Arbeit, scheine ich Sie sagen zu hören. Ich werde Sie verärgern, aber dieses Geschäft hat keinen Sinn. Der Grund, warum dies nicht der Fall ist, ist in der Hintergrundmathematik verborgen. Ich werde kurz auf die kleinen Unterschiede in der Herstellung und Verwendung beider Zertifikate eingehen, erklären, wie und warum sie große Unterschiede verursachen, und im letzten Teil werde ich über etwas sprechen, das nicht als Bonus im Titel steht. (Für den Bonus musst du bis zum Ende lesen :D)</p><p><img loading=lazy src=/images/key-size-comparison.jpg alt></p><h2 id=produktionsprozess-des-ecc-zertifikats>Produktionsprozess des ECC-Zertifikats<a hidden class=anchor aria-hidden=true href=#produktionsprozess-des-ecc-zertifikats>#</a></h2><p>Zuerst müssen wir (wie immer) die neuesten Updates über die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.</p><pre tabindex=0><code>Ubuntu: sudo apt update &amp;&amp; sudo apt upgrade -y

Fedora: sudo yum update -y

Arch Linux: sudo pacman -Syyu
</code></pre><p>Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx-Dienstes (das ist der Dienst, der es Ihnen ermöglicht, externe HTTP/HTTPS-Verbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Zunächst einmal sollte angemerkt werden, dass es sich aufgrund der Verwirrung bei Apache-, Nginx- und Litespeed-Diensten um unterschiedliche Dienste handelt, die die gleiche Aufgabe erfüllen. Ich habe mich für NGINX entschieden, weil es einfacher zu verwalten ist und mehr Community-Unterstützung bietet.</p><h2 id=lassen-sie-uns-den-privaten-schlüssel-generieren>Lassen Sie uns den privaten Schlüssel generieren<a hidden class=anchor aria-hidden=true href=#lassen-sie-uns-den-privaten-schlüssel-generieren>#</a></h2><p>Zuerst generieren wir den privaten Schlüssel mit OpenSSL. Der OpenSSL-Befehl, den wir verwenden werden, ist „ecparam“ (EC-Parametermanipulation) und um die Konfigurationsparameter an diesen Befehl zu übergeben:</p><pre tabindex=0><code>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</code></pre><ul><li>Die Option <code>-genkey</code> weist OpenSSL an, einen EC-Schlüssel zu generieren.</li><li>Der Parameter <code>-name</code> teilt OpenSSL mit, welche Kurve verwendet werden soll.</li><li>Der Parameter <code>-out</code> weist OpenSSL an, die Ausgabe in eine Datei zu schreiben.</li></ul><p>Beachten Sie, dass OpenSSL seine Ausgabe standardmäßig im PEM-Format schreibt. Wir können überprüfen, ob OpenSSL das Richtige tut, mit dem Befehl <code>ec</code>, der EC-Schlüssel verarbeitet:</p><pre tabindex=0><code>openssl ec -in privkey.pem -noout -text
</code></pre><ul><li><code>-in</code> ist eine Eingabedatei</li><li>Das <code>-noout</code> weist OpenSSL an, den Schlüssel nicht zu extrahieren, und gibt sinnlos privkey.pem nach stdout aus.</li><li><code>-text</code> weist OpenSSL an, Informationen über den Schlüssel im Klartextformat zu schreiben</li></ul><p>Wenn alles gut geht und der Schlüssel korrekt generiert wurde, zeigt OpenSSL etwa Folgendes:</p><pre tabindex=0><code>read EC key
Private-Key: (384 bit)
priv:
    [secret]
pub:
    [secret]
ASN1 OID: secp384r1
NIST CURVE: P-384
</code></pre><p>Dadurch wird bestätigt, dass der Schlüssel mit der P-384-Kurve erstellt wurde. Wenn Sie sich fragen, warum wir nicht P-512 statt P-384 verwenden, Let&rsquo;s Encrypt signiert nicht, wenn die Ekliptikkurven höher als 384 Bit sind, und moderne Browser wie Google Chrome markieren Websites, die 512-Bit-Ekliptikkurven verwenden, als ungültig . Das ist die kurze Antwort.</p><h2 id=erstellen-wir-eine-openssl-konfiguration-für-das-zertifikat>Erstellen wir eine OpenSSL-Konfiguration für das Zertifikat<a hidden class=anchor aria-hidden=true href=#erstellen-wir-eine-openssl-konfiguration-für-das-zertifikat>#</a></h2><p>Jetzt müssen wir eine OpenSSL-Konfigurationsdatei erstellen, die die domänenspezifischen Parameter enthält, für die wir das TLS-Zertifikat erhalten möchten. In diesem Beispiel tragen wir die folgende Konfiguration in eine <code>openssl.cnf</code>-Datei ein:</p><pre tabindex=0><code>[ req ]
prompt = no
encrypt_key = no
default_md = sha512
distinguished_name = dname
req_extensions = reqext

[ dname ]
CN = example.com
emailAddress = admin@example.com

[ reqext ]
subjectAltName = DNS:example.com, DNS:www.example.com
</code></pre><p>Hier ist eine kurze Beschreibung dieser Konfigurationsoptionen:</p><p>Im erforderlichen <code>[ req ]</code>-Abschnitt:</p><ul><li><code>prompt=no</code> weist OpenSSL an, so viel Konfiguration wie möglich aus der Konfigurationsdatei zu holen</li><li><code>encrypt_key = no</code> weist OpenSSL an, den privaten Schlüssel nicht mit einem Passwort zu verschlüsseln. (Verschlüsselte private Schlüssel werden von Nginx unterstützt, aber ich verwende sie nicht.)</li><li><code>default_md=sha512</code> weist OpenSSL an, die CSR mit SHA512 zu signieren. (Soweit ich weiß, unterstützt Let&rsquo;s Encrypt nur RSA mit SHA256 für seine Signaturen, aber das bedeutet nicht, dass wir in CSR keine stärkere Verschlüsselung verwenden können.)</li><li><code>distinguished_name=dname</code> weist OpenSSL an, nach einem <code>[ dname ]</code>-Abschnitt für Konfigurationsoptionen für Distinguished Name zu suchen.</li><li>„req_extensions=reqext“ weist OpenSSL an, in den Konfigurationsoptionen nach „Subject Alternative Names“ (SANs)-Erweiterungen, die es konfigurieren möchte, nach einem „[ reqext ]“-Abschnitt zu suchen.</li></ul><p>Im Abschnitt Distinguished Name <code>[ dname ]</code>:</p><ul><li>„CN = example.com“ gibt den Common Name des Zertifikats an.</li><li>Ihre <code>emailAddress = admin@example.com</code> E-Mail-Adresse muss prominent sein.
Gewünschte Erweiterungen Im Abschnitt „[ reqext ]“ stellt subjectAltName die Liste der SANs für das Zertifikat bereit. (Chrome ab v58 erfordert, dass der Common Name in der Liste der SANs enthalten ist).</li></ul><p>Let&rsquo;s Encrypt v2 unterstützt Platzhalterdomänen, daher können Sie in diesem Beispiel einen einstufigen Platzhalter für Nicht-Apex-Hosts (*.example.com) verwenden.</p><h2 id=lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen>Lassen Sie uns eine Zertifikatsignieranforderung erstellen<a hidden class=anchor aria-hidden=true href=#lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen>#</a></h2><p>Der letzte Schritt auf der Client-Seite besteht darin, die Zertifikatsignieranforderung mit OpenSSL zu generieren, dann leiten wir sie zum Signieren an Let’s Encrypt weiter und rufen das signierte Zertifikat ab.</p><p>Der zum Generieren einer CSR erforderliche OpenSSL-Befehl lautet <code>req</code> .</p><pre tabindex=0><code>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</code></pre><ul><li><code>-new</code> teilt OpenSSL mit, dass wir eine CSR erstellt haben (und wir keine bestehende CSR untersuchen)</li><li><code>-config</code> openssl.cnf gibt die Konfigurationsdatei an, die wir oben erstellt haben</li><li><code>-key privkey.pem</code> gibt den privaten Schlüssel an, den wir oben erstellt haben</li><li><code>-out csr.pem</code> weist OpenSSL an, die CSR in eine Ausgabedatei zu schreiben (anstelle von stdout)</li></ul><p>Wir können überprüfen, ob wir die CSR korrekt erstellt haben:</p><pre tabindex=0><code>openssl req -in csr.pem -noout -text -verify
</code></pre><ul><li><code>-verify</code> fordert OpenSSL auf, die Signatur in der CSR zu verifizieren</li></ul><p>Dies sollte die folgenden erwarteten Ergebnisse in der Ausgabe erzeugen:</p><pre tabindex=0><code>verify OK
Certificate Request:
    Data:
        Version: 1 (0x0)
        Subject: CN = example.com, emailAddress = admin@example.com
        Subject Public Key Info:
            Public Key Algorithm: id-ecPublicKey
                Public-Key: (384 bit)
                pub:
                    [ommited]
                ASN1 OID: secp384r1
                NIST CURVE: P-384
        Attributes:
        Requested Extensions:
            X509v3 Subject Alternative Name:
                DNS:example.com, DNS:www.example.com
    Signature Algorithm: ecdsa-with-SHA512
         [ommited]
</code></pre><h2 id=bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren>Bitten Sie Let&rsquo;s Encrypt, unser Zertifikat zu signieren<a hidden class=anchor aria-hidden=true href=#bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren>#</a></h2><p>Der letzte Schritt besteht darin, die CSR mit einem ACME-Client zum Signieren an Let&rsquo;s Encrypt zu senden, &ldquo;certbot&rdquo; ist der häufigste Client für diesen Job.</p><p>Befehlszeilenoptionen, die an den „Certbot“-Client übergeben werden, hängen von unserem Setup, der Person, für die unsere Domain registriert ist, usw. ab. Normalerweise müssen wir den Befehl &ldquo;certonly&rdquo; verwenden, und wenn Sie Sternchen (*) verwendet haben, müssen Sie eines der certbot-DNS-Plugins verwenden.</p><p>Ist beispielsweise die Domain „example.com“ bei Cloudflare registriert, können wir die Verifizierung über das entsprechende Plugin durchführen, was äußerst komfortabel ist und keinen manuellen Eingriff in den Vorgang erfordert. (Das Konfigurieren des Cloudflare-Plugins mit geheimen Token-Informationen würde den Rahmen dieses Artikels sprengen.)</p><p>Es wird normalerweise empfohlen, zuerst mit <code>--dry-run</code> sicherzustellen, dass alles in Ordnung ist, um sicherzustellen, dass alles in Ordnung ist.</p><pre tabindex=0><code>certbot nginx certonly --dry-run --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><ul><li>Anführungszeichen sind um Zeichen herum erforderlich, um fehlerhafte Manipulationen zu vermeiden, und sind im Allgemeinen eine gute Idee.</li><li><code>--csr csr.pem</code> teilt certbot mit, dass wir bereits ein Zertifikat haben und Let’s Encrypt benötigen, um es für uns zu signieren.</li></ul><p>Der Certbot-Client überprüft auf der Befehlszeile, ob die angeforderte Liste der Domänen mit den im Zertifikat aufgeführten Domänen übereinstimmt, und verwendet das Certbot-NGINX-Plug-in, um zu überprüfen, ob die Domäne unsere ist, und teilt uns mit, falls es Probleme gibt.</p><p>Wenn nichts falsch ist, wird es Ihnen sagen:</p><pre tabindex=0><code>WICHTIGE NOTIZEN:
 - Der Probelauf war erfolgreich.
</code></pre><p>Der eigentliche Befehl lautet wie folgt:</p><pre tabindex=0><code>certbot nginx certonly --domain &#34;example.com&#34; --domain &#34;www.example.com&#34; --csr csr.pem
</code></pre><p>Nach einer (langen) Verzögerung gibt der Client Folgendes aus:</p><ol><li>Signiertes Zertifikat: <code>0000_cert.pem</code></li><li>Stamm- und Zwischenzertifikate: „0000_chain.pem“.</li><li>Zertifikat + Zwischenprodukte: <code>0001_chain.pem</code>
An dieser Stelle kann die CSR <code>csr.pem</code> gelöscht werden.</li></ol><p>Wenn wir neugierig sind, können wir die vom Client zurückgegebenen Zertifikate mit OpenSSL mit dem Befehl &ldquo;x509&rdquo; überprüfen:</p><pre tabindex=0><code>openssl x509 -in 0001_chain.pem -noout -text
</code></pre><p>Leider werden wir feststellen, dass Let’s Encrypt wie oben beschrieben unser Zertifikat mit einer SHA256-Signatur signiert. (SHA512 ist nicht nur sicherer, sondern übertrifft SHA256 auf modernen 64-Bit-CPUs.) Aber unser öffentlicher Schlüssel sollte immer noch ECDSA verwenden.</p><p>Diese Dateien sind nicht gewöhnlich, daher müssen wir sie auf informativere Weise verschieben und bearbeiten.</p><p>Unter Debian Linux erstelle ich gerne Unterverzeichnisse für meine Domains, indem ich meinen privaten Schlüssel in <code>/home/USER_NAME/SSL/private/example.com/privkey.pem</code> und Zertifikate behalte:</p><ul><li><code>/home/USER_NAME/SSL/certs/example.com/cert.pem</code></li><li><code>/home/USER_NAME/SSL/certs/example.com/chain.pem</code></li><li><code>/home/USER_NAME/SSL/certs/example.com/fullchain.pem</code></li></ul><h1 id=ende>ENDE<a hidden class=anchor aria-hidden=true href=#ende>#</a></h1><p>Wenn wir alles richtig gemacht haben, bestätigt die Überprüfung des Zertifikats mit einem Webbrowser wie Chrome, dass es sich um ein EC-Zertifikat handelt:</p><p><img loading=lazy src=/images/ecc-sll-key-chrome.png alt></p><p>Mozilla Observatory wird uns auch eine A+ Bewertung geben!</p><p><img loading=lazy src=/images/ecc-ssl-key-mozilla.png alt></p><p>Darüber hinaus können wir als Ergebnis des SSL Labs-Berichts sehen, dass ein 384-Bit-ECC-Zertifikat verwendet wurde.</p><p><img loading=lazy src=/images/ecc-ssl-key-ssllabs.png alt></p><p>HINWEIS: Dieser Artikel profitiert vom Artikel von <a href=https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc>Benjamin Black</a> zum gleichen Thema.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wiseweb.works/de/tags/linux/>linux</a></li><li><a href=https://wiseweb.works/de/tags/ssl/>ssl</a></li><li><a href=https://wiseweb.works/de/tags/sicherheit/>sicherheit</a></li><li><a href=https://wiseweb.works/de/tags/ecc/>ecc</a></li><li><a href=https://wiseweb.works/de/tags/elliptische-kurve/>elliptische kurve</a></li></ul><nav class=paginav><a class=next href=https://wiseweb.works/de/post/ssl-konfigurasyonu/><span class=title>Nächste Seite »</span><br><span>Erhöhung der SSL-Sicherheit auf Linux-Servern</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://wiseweb.works/de/>Wise</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="Kopieren";function s(){e.innerText="Kopiert!",setTimeout(()=>{e.innerText="Kopieren"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>