<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>elliptische kurve on Wise</title><link>https://wiseweb-works.github.io/blog/de/tags/elliptische-kurve/</link><description>Recent content in elliptische kurve on Wise</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 20 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://wiseweb-works.github.io/blog/de/tags/elliptische-kurve/index.xml" rel="self" type="application/rss+xml"/><item><title>Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server</title><link>https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikasi/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikasi/</guid><description>Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen.</description><content:encoded><![CDATA[<h1 id="einführung-und-zusammenfassung">Einführung und Zusammenfassung</h1>
<p>Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen. Wenn Sie mit dem ACME-Protokoll von Let’s Encrypt vertraut sind (zum Zeitpunkt des Schreibens), ist es normalerweise möglich, ein 1024-4098 (wenn Sie sich zu sehr anstrengen, vielleicht 8196) Bit-Zertifikat mit einer asymmetrischen RSA-Schlüsselstruktur zu generieren und es für zu verwenden 90 Tage relativ. Das Generieren eines so großen Schlüssels, dessen Verwendung während des TLS-Handshakes nach der Generierung und die Kompatibilität mit den von den Besuchern verwendeten Geräten verursachen jedoch in den meisten Szenarien Probleme. Wenn beispielsweise 4096 Bit anstelle von 2048 Bit verwendet werden, bin ich bei einigen meiner Versuche mit 0,4-0,8 Sekunden längeren Handshake-Zeiten konfrontiert. Als ob es in Ordnung wäre, dass der Handshake so lange dauert, wird der Server dadurch zusätzlich belastet. Aber wenn Sie ein 384-Bit-ECC-Zertifikat anstelle von 4096-Bit-RSA generieren, erhalten Sie ein viel schnelleres Zertifikat und gleichzeitig eine Sicherheit, die 7680-Bit-RSA entspricht (wenn es diese Größe hätte).</p>
<p>Nun, Sie haben es gut erklärt, aber wo ist der Sinn dieser Arbeit, scheine ich Sie sagen zu hören. Ich werde Sie verärgern, aber dieses Geschäft hat keinen Sinn. Der Grund, warum dies nicht der Fall ist, ist in der Hintergrundmathematik verborgen. Ich werde kurz auf die kleinen Unterschiede in der Herstellung und Verwendung beider Zertifikate eingehen, erklären, wie und warum sie große Unterschiede verursachen, und im letzten Teil werde ich über etwas sprechen, das nicht als Bonus im Titel steht. (Für den Bonus musst du bis zum Ende lesen :D)</p>
<p><picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/key-size-comparison.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/key-size-comparison.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/images/ecc-ssl/key-size-comparison.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://www.globalsign.com/en/blog/elliptic-curve-cryptography (Datum: 08.04.2023)</small></b></center></caption>
</picture></p>
<h2 id="produktionsprozess-des-ecc-zertifikats">Produktionsprozess des ECC-Zertifikats</h2>
<p>Zuerst müssen wir (wie immer) die neuesten Updates über die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx-Dienstes (das ist der Dienst, der es Ihnen ermöglicht, externe HTTP/HTTPS-Verbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Zunächst einmal sollte angemerkt werden, dass es sich aufgrund der Verwirrung bei Apache-, Nginx- und Litespeed-Diensten um unterschiedliche Dienste handelt, die die gleiche Aufgabe erfüllen. Ich habe mich für NGINX entschieden, weil es einfacher zu verwalten ist und mehr Community-Unterstützung bietet.</p>
<h2 id="lassen-sie-uns-den-privaten-schlüssel-generieren">Lassen Sie uns den privaten Schlüssel generieren</h2>
<p>Zuerst generieren wir den privaten Schlüssel mit OpenSSL. Der OpenSSL-Befehl, den wir verwenden werden, ist „ecparam“ (EC-Parametermanipulation) und um die Konfigurationsparameter an diesen Befehl zu übergeben:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</span></span></code></pre></div><ul>
<li>Die Option <code>-genkey</code> weist OpenSSL an, einen EC-Schlüssel zu generieren.</li>
<li>Der Parameter <code>-name</code> teilt OpenSSL mit, welche Kurve verwendet werden soll.</li>
<li>Der Parameter <code>-out</code> weist OpenSSL an, die Ausgabe in eine Datei zu schreiben.</li>
</ul>
<p>Beachten Sie, dass OpenSSL seine Ausgabe standardmäßig im PEM-Format schreibt. Wir können überprüfen, ob OpenSSL das Richtige tut, mit dem Befehl <code>ec</code>, der EC-Schlüssel verarbeitet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ec -in privkey.pem -noout -text
</span></span></code></pre></div><ul>
<li><code>-in</code> ist eine Eingabedatei</li>
<li>Das <code>-noout</code> weist OpenSSL an, den Schlüssel nicht zu extrahieren, und gibt sinnlos privkey.pem nach stdout aus.</li>
<li><code>-text</code> weist OpenSSL an, Informationen über den Schlüssel im Klartextformat zu schreiben</li>
</ul>
<p>Wenn alles gut geht und der Schlüssel korrekt generiert wurde, zeigt OpenSSL etwa Folgendes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>read EC key
</span></span><span style="display:flex;"><span>Private-Key: (384 bit)
</span></span><span style="display:flex;"><span>priv:
</span></span><span style="display:flex;"><span>    [secret]
</span></span><span style="display:flex;"><span>pub:
</span></span><span style="display:flex;"><span>    [secret]
</span></span><span style="display:flex;"><span>ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>NIST CURVE: P-384
</span></span></code></pre></div><p>Dadurch wird bestätigt, dass der Schlüssel mit der P-384-Kurve erstellt wurde. Wenn Sie sich fragen, warum wir nicht P-512 statt P-384 verwenden, Let&rsquo;s Encrypt signiert nicht, wenn die Ekliptikkurven höher als 384 Bit sind, und moderne Browser wie Google Chrome markieren Websites, die 512-Bit-Ekliptikkurven verwenden, als ungültig . Das ist die kurze Antwort.</p>
<h2 id="erstellen-wir-eine-openssl-konfiguration-für-das-zertifikat">Erstellen wir eine OpenSSL-Konfiguration für das Zertifikat</h2>
<p>Jetzt müssen wir eine OpenSSL-Konfigurationsdatei erstellen, die die domänenspezifischen Parameter enthält, für die wir das TLS-Zertifikat erhalten möchten. In diesem Beispiel tragen wir die folgende Konfiguration in eine <code>openssl.cnf</code>-Datei ein:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>[ req ]
</span></span><span style="display:flex;"><span>prompt = no
</span></span><span style="display:flex;"><span>encrypt_key = no
</span></span><span style="display:flex;"><span>default_md = sha512
</span></span><span style="display:flex;"><span>distinguished_name = dname
</span></span><span style="display:flex;"><span>req_extensions = reqext
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ dname ]
</span></span><span style="display:flex;"><span>CN = example.com
</span></span><span style="display:flex;"><span>emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ reqext ]
</span></span><span style="display:flex;"><span>subjectAltName = DNS:example.com, DNS:www.example.com
</span></span></code></pre></div><p>Hier ist eine kurze Beschreibung dieser Konfigurationsoptionen:</p>
<p>Im erforderlichen <code>[ req ]</code>-Abschnitt:</p>
<ul>
<li><code>prompt=no</code> weist OpenSSL an, so viel Konfiguration wie möglich aus der Konfigurationsdatei zu holen</li>
<li><code>encrypt_key = no</code> weist OpenSSL an, den privaten Schlüssel nicht mit einem Passwort zu verschlüsseln. (Verschlüsselte private Schlüssel werden von Nginx unterstützt, aber ich verwende sie nicht.)</li>
<li><code>default_md=sha512</code> weist OpenSSL an, die CSR mit SHA512 zu signieren. (Soweit ich weiß, unterstützt Let&rsquo;s Encrypt nur RSA mit SHA256 für seine Signaturen, aber das bedeutet nicht, dass wir in CSR keine stärkere Verschlüsselung verwenden können.)</li>
<li><code>distinguished_name=dname</code> weist OpenSSL an, nach einem <code>[ dname ]</code>-Abschnitt für Konfigurationsoptionen für Distinguished Name zu suchen.</li>
<li>„req_extensions=reqext“ weist OpenSSL an, in den Konfigurationsoptionen nach „Subject Alternative Names“ (SANs)-Erweiterungen, die es konfigurieren möchte, nach einem „[ reqext ]“-Abschnitt zu suchen.</li>
</ul>
<p>Im Abschnitt Distinguished Name <code>[ dname ]</code>:</p>
<ul>
<li>„CN = example.com“ gibt den Common Name des Zertifikats an.</li>
<li>Ihre <code>emailAddress = admin@example.com</code> E-Mail-Adresse muss prominent sein.
Gewünschte Erweiterungen Im Abschnitt „[ reqext ]“ stellt subjectAltName die Liste der SANs für das Zertifikat bereit. (Chrome ab v58 erfordert, dass der Common Name in der Liste der SANs enthalten ist).</li>
</ul>
<p>Let&rsquo;s Encrypt v2 unterstützt Platzhalterdomänen, daher können Sie in diesem Beispiel einen einstufigen Platzhalter für Nicht-Apex-Hosts (*.example.com) verwenden.</p>
<h2 id="lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen">Lassen Sie uns eine Zertifikatsignieranforderung erstellen</h2>
<p>Der letzte Schritt auf der Client-Seite besteht darin, die Zertifikatsignieranforderung mit OpenSSL zu generieren, dann leiten wir sie zum Signieren an Let’s Encrypt weiter und rufen das signierte Zertifikat ab.</p>
<p>Der zum Generieren einer CSR erforderliche OpenSSL-Befehl lautet <code>req</code> .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</span></span></code></pre></div><ul>
<li><code>-new</code> teilt OpenSSL mit, dass wir eine CSR erstellt haben (und wir keine bestehende CSR untersuchen)</li>
<li><code>-config</code> openssl.cnf gibt die Konfigurationsdatei an, die wir oben erstellt haben</li>
<li><code>-key privkey.pem</code> gibt den privaten Schlüssel an, den wir oben erstellt haben</li>
<li><code>-out csr.pem</code> weist OpenSSL an, die CSR in eine Ausgabedatei zu schreiben (anstelle von stdout)</li>
</ul>
<p>Wir können überprüfen, ob wir die CSR korrekt erstellt haben:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -in csr.pem -noout -text -verify
</span></span></code></pre></div><ul>
<li><code>-verify</code> fordert OpenSSL auf, die Signatur in der CSR zu verifizieren</li>
</ul>
<p>Dies sollte die folgenden erwarteten Ergebnisse in der Ausgabe erzeugen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>verify OK
</span></span><span style="display:flex;"><span>Certificate Request:
</span></span><span style="display:flex;"><span>    Data:
</span></span><span style="display:flex;"><span>        Version: 1 (0x0)
</span></span><span style="display:flex;"><span>        Subject: CN = example.com, emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>        Subject Public Key Info:
</span></span><span style="display:flex;"><span>            Public Key Algorithm: id-ecPublicKey
</span></span><span style="display:flex;"><span>                Public-Key: (384 bit)
</span></span><span style="display:flex;"><span>                pub:
</span></span><span style="display:flex;"><span>                    [ommited]
</span></span><span style="display:flex;"><span>                ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>                NIST CURVE: P-384
</span></span><span style="display:flex;"><span>        Attributes:
</span></span><span style="display:flex;"><span>        Requested Extensions:
</span></span><span style="display:flex;"><span>            X509v3 Subject Alternative Name:
</span></span><span style="display:flex;"><span>                DNS:example.com, DNS:www.example.com
</span></span><span style="display:flex;"><span>    Signature Algorithm: ecdsa-with-SHA512
</span></span><span style="display:flex;"><span>         [ommited]
</span></span></code></pre></div><h2 id="bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren">Bitten Sie Let&rsquo;s Encrypt, unser Zertifikat zu signieren</h2>
<p>Der letzte Schritt besteht darin, die CSR mit einem ACME-Client zum Signieren an Let&rsquo;s Encrypt zu senden, &ldquo;certbot&rdquo; ist der häufigste Client für diesen Job.</p>
<p>Befehlszeilenoptionen, die an den „Certbot“-Client übergeben werden, hängen von unserem Setup, der Person, für die unsere Domain registriert ist, usw. ab. Normalerweise müssen wir den Befehl &ldquo;certonly&rdquo; verwenden, und wenn Sie Sternchen (*) verwendet haben, müssen Sie eines der certbot-DNS-Plugins verwenden.</p>
<p>Ist beispielsweise die Domain „example.com“ bei Cloudflare registriert, können wir die Verifizierung über das entsprechende Plugin durchführen, was äußerst komfortabel ist und keinen manuellen Eingriff in den Vorgang erfordert. (Das Konfigurieren des Cloudflare-Plugins mit geheimen Token-Informationen würde den Rahmen dieses Artikels sprengen.)</p>
<p>Es wird normalerweise empfohlen, zuerst mit <code>--dry-run</code> sicherzustellen, dass alles in Ordnung ist, um sicherzustellen, dass alles in Ordnung ist.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --dry-run --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><ul>
<li>Anführungszeichen sind um Zeichen herum erforderlich, um fehlerhafte Manipulationen zu vermeiden, und sind im Allgemeinen eine gute Idee.</li>
<li><code>--csr csr.pem</code> teilt certbot mit, dass wir bereits ein Zertifikat haben und Let’s Encrypt benötigen, um es für uns zu signieren.</li>
</ul>
<p>Der Certbot-Client überprüft auf der Befehlszeile, ob die angeforderte Liste der Domänen mit den im Zertifikat aufgeführten Domänen übereinstimmt, und verwendet das Certbot-NGINX-Plug-in, um zu überprüfen, ob die Domäne unsere ist, und teilt uns mit, falls es Probleme gibt.</p>
<p>Wenn nichts falsch ist, wird es Ihnen sagen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>WICHTIGE NOTIZEN:
</span></span><span style="display:flex;"><span> - Der Probelauf war erfolgreich.
</span></span></code></pre></div><p>Der eigentliche Befehl lautet wie folgt:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><p>Nach einer (langen) Verzögerung gibt der Client Folgendes aus:</p>
<ol>
<li>Signiertes Zertifikat: <code>0000_cert.pem</code></li>
<li>Stamm- und Zwischenzertifikate: „0000_chain.pem“.</li>
<li>Zertifikat + Zwischenprodukte: <code>0001_chain.pem</code>
An dieser Stelle kann die CSR <code>csr.pem</code> gelöscht werden.</li>
</ol>
<p>Wenn wir neugierig sind, können wir die vom Client zurückgegebenen Zertifikate mit OpenSSL mit dem Befehl &ldquo;x509&rdquo; überprüfen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl x509 -in 0001_chain.pem -noout -text
</span></span></code></pre></div><p>Leider werden wir feststellen, dass Let’s Encrypt wie oben beschrieben unser Zertifikat mit einer SHA256-Signatur signiert. (SHA512 ist nicht nur sicherer, sondern übertrifft SHA256 auf modernen 64-Bit-CPUs.) Aber unser öffentlicher Schlüssel sollte immer noch ECDSA verwenden.</p>
<p>Diese Dateien sind nicht gewöhnlich, daher müssen wir sie auf informativere Weise verschieben und bearbeiten.</p>
<p>Unter Debian Linux erstelle ich gerne Unterverzeichnisse für meine Domains, indem ich meinen privaten Schlüssel in <code>/home/USER_NAME/SSL/private/example.com/privkey.pem</code> und Zertifikate behalte:</p>
<ul>
<li><code>/home/USER_NAME/SSL/certs/example.com/cert.pem</code></li>
<li><code>/home/USER_NAME/SSL/certs/example.com/chain.pem</code></li>
<li><code>/home/USER_NAME/SSL/certs/example.com/fullchain.pem</code></li>
</ul>
<h1 id="ende">ENDE</h1>
<p>Wenn wir alles richtig gemacht haben, bestätigt die Überprüfung des Zertifikats mit einem Webbrowser wie Chrome, dass es sich um ein EC-Zertifikat handelt:</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/ecc-sll-key-chrome.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/ecc-sll-key-chrome.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/images/ecc-ssl/ecc-sll-key-chrome.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Datum: 08.04.2023)</small></b></center></caption>
</picture></p>
<p>Mozilla Observatory wird uns auch eine A+ Bewertung geben!</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/ecc-ssl-key-mozilla.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/ecc-ssl-key-mozilla.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/images/ecc-ssl/ecc-ssl-key-mozilla.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Datum: 08.04.2023)</small></b></center></caption>
</picture></p>
<p>Darüber hinaus können wir als Ergebnis des SSL Labs-Berichts sehen, dass ein 384-Bit-ECC-Zertifikat verwendet wurde.</p>
<p><picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/ecc-ssl-key-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/images/ecc-ssl/ecc-ssl-key-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/images/ecc-ssl/ecc-ssl-key-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <caption><center><b><small>SSL Labs Test</small></b></center></caption>
</picture></p>
<p>HINWEIS: Dieser Artikel profitiert vom Artikel von <a href="https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc">Benjamin Black</a> zum gleichen Thema.</p>
]]></content:encoded></item></channel></rss>