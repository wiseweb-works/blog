<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Linux on Wise</title><link>https://wiseweb-works.github.io/blog/de/tags/linux/</link><description>Recent content in Linux on Wise</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Tue, 11 Apr 2023 02:43:18 +0200</lastBuildDate><atom:link href="https://wiseweb-works.github.io/blog/de/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Eingehender OpenVPN-Test</title><link>https://wiseweb-works.github.io/blog/de/post/openvpn-full-anlatim/</link><pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/de/post/openvpn-full-anlatim/</guid><description>Einführung und Zusammenfassung Heute werden wir OpenVPN, meiner Meinung nach eine der wichtigsten Software der letzten Zeit, ausführlich überprüfen. In diesem Test werden wir zuerst darüber sprechen, wofür OpenVPN verwendet wird. Dann untersuchen wir, was wir zum Ausführen des Programms benötigen und was vor dem ersten Ausführen zu tun ist. Abschließend werde ich versuchen zu erklären, was vom ersten Moment des Verbindungsaufbaus bis zum letzten Schritt, wenn die Daten entschlüsselt werden, im Hintergrund vor sich geht.</description><content:encoded><![CDATA[<h1 id="einführung-und-zusammenfassung">Einführung und Zusammenfassung</h1>
<p>Heute werden wir OpenVPN, meiner Meinung nach eine der wichtigsten Software der letzten Zeit, ausführlich überprüfen. In diesem Test werden wir zuerst darüber sprechen, wofür OpenVPN verwendet wird. Dann untersuchen wir, was wir zum Ausführen des Programms benötigen und was vor dem ersten Ausführen zu tun ist. Abschließend werde ich versuchen zu erklären, was vom ersten Moment des Verbindungsaufbaus bis zum letzten Schritt, wenn die Daten entschlüsselt werden, im Hintergrund vor sich geht. Daher schätze ich, dass unser Artikel aus 3 Teilen und gegebenenfalls einem Frage-Antwort-Abschnitt bestehen wird. Jetzt schnallen wir uns an und machen einen Ausflug in die tiefe und düstere Welt des Internets.</p>
<h2 id="was-ist-openvpn-und-wofür-wird-es-verwendet">Was ist OpenVPN und wofür wird es verwendet?</h2>
<p>Heutzutage gibt es fast kein Geschäft, das nicht online erledigt werden kann. Sogar unsere Arbeit, die normalerweise nicht online ist, hat sich aufgrund der Pandemie und der neuen Normalität auf die Arbeit von zu Hause aus entwickelt. Es gab jedoch große Probleme, sowohl weil es eine Arbeitsmethode ist, an die wir nicht gewöhnt sind, als auch weil unsere Leute nicht sehr gut mit Technologie umgehen können. Bevor klar wurde, dass die Menschen sich von ihren Heimcomputern mit ihren Bürocomputern verbinden mussten, kamen einige Unternehmen auf frivole Ideen, wie zum Beispiel, Bürocomputer zu den Häusern der Mitarbeiter zu schicken. Sie haben sehr gut verstanden, wie falsch das war, aus dem Feedback, das sie in kurzer Zeit erhalten haben. Kurz gesagt, es wurde endlich akzeptiert, dass elektronische Geräte im Büro bleiben und irgendwie eine sichere und nachhaltige Verbindung aus der Ferne hergestellt werden sollte. Natürlich befanden sich Institutionen auch schon früher in solchen Nöten, aber eine solche Großsituation kam damals nicht in Frage. Vor der Pandemie wurden verschiedene Protokolle wie PPTP, L2TP, IPSec, IKev2, SSTP und schließlich OpenVPN verwendet. Dies sind normalerweise Abkürzungen für bestimmte lange und ausgefallene Wörter, und ihre grundlegende Logik besteht darin, zwei oder mehr Geräte zu verbinden und sie so zu verhalten, als ob sie sich im selben Netzwerk befinden. Ich werde nicht viel sagen, da Protokolle vor OpenVPN gewisse Schwächen, Langsamkeit und technische Schwierigkeiten bei der Implementierung mit sich brachten. OpenVPN ist der Name des Protokolls und Programms, das es mindestens 2 Geräten in der Rolle von Server und Client ermöglicht, sich miteinander zu verbinden, und zwar auf eine Weise, die Industriestandards entspricht. Ich verwende ein Remote-Desktop-Programm. Ich höre Sie anscheinend sagen, was die Notwendigkeit dafür ist. Leider müssen er und alle anderen Programme wie er grundsätzlich dieses Protokoll verwenden. Wenn Sie das Schildsymbol oder die Verbindungsdetails in TeamViewer, einem der bekanntesten, drücken, können Sie das OpenVPN-Protokoll sehen.</p>
<h2 id="was-brauchen-wir-um-eine-openvpn-verbindung-aufzubauen">Was brauchen wir, um eine OpenVPN-Verbindung aufzubauen?</h2>
<p>Zunächst muss OpenVPN sowohl auf der Server- als auch auf der Clientseite (dem zu verbindenden Gerät) installiert werden. Dann sollte eine Einstellungsdatei (Konfigurationsdatei) bearbeitet werden, die die Bedingungen zeigt, unter denen die Geräte kommunizieren. Das Hauptereignis ist, dass diese Konfigurationsdatei vom Client generiert und verwendet wird. Diese Konfigurationsdatei ist unterteilt in server_config, die vom Server verwendet wird, und client_config, die vom Client verwendet wird.</p>
<h3 id="die-vom-server-verwaltete-einstellungsdatei-enthält-die-folgenden-einträge">Die vom Server verwaltete Einstellungsdatei enthält die folgenden Einträge</h3>
<ul>
<li><code>Port 1194</code> gibt an, welcher Port eine Verbindungsanfrage zum Herstellen der OpenVPN-Verbindung erhält.</li>
<li><code>proto tcp</code> Verbindung über TCP oder UDP möglich. Einstellungseintrag zur Auswahl eingetragen.</li>
<li><code>dev tun</code> TAP- oder TUN-Schnittstelle kann verwendet werden. Dies sind virtuelle Schnittstellen. TAP-Schicht 2 stellt eine Verbindung her, während TUN-Schicht 3 eine Verbindung herstellt.</li>
<li><code>user none</code> Ermöglicht das Verbinden von Benutzern mit einem nicht autorisierten Benutzer auf dem Server.</li>
<li><code>group $NOGROUP</code> Ermöglicht es, sich verbindende Benutzer mit einer nicht autorisierten Gruppe auf dem Server als Gruppe zu verknüpfen.</li>
<li><code>persist-key</code> Eine Autorisierungseinstellung für die Erstellung und den Neustart der virtuellen Schnittstelle</li>
<li><code>persist-tun</code> Ebenfalls eine Berechtigungseinstellung für die Erstellung und den Neustart der virtuellen Schnittstelle</li>
<li><code>keepalive 10 120</code> Eine Einstellung dafür, wie viele Verbindungen aktiv gehalten werden und wie lange die aktive Verbindung beendet wird, wenn keine Kommunikation hergestellt wird.</li>
<li><code>ifconfig-pool-persist ipp.txt</code> Eine Einstellung, um die von OpenVPN an Clients im virtuellen Netzwerk vergebenen IP-Adressen beizubehalten und ihnen dieselben Adressen zuzuweisen, wenn sie sich wieder verbinden</li>
<li><code>push &quot;dhcp-option DNS 1.1.1.1&quot;</code> Eine DNS-Einstellung, die der Server beim Verlassen des Netzwerks verwenden soll</li>
<li><code>compress</code> Der Teil, in dem Komprimierungsoptionen festgelegt werden</li>
<li><code>dh none</code> Eine Einstellung zum Ein- oder Ausschalten von Diffie-Hellman</li>
<li><code>ecdh-curve</code> Wenn Sie Elliptic Curve Diffie-Hellman verwenden, wird die Einstellung angepasst, neben der die Kurve ausgewählt werden muss</li>
<li><code>dh dh.pem</code>-Einstellung, die den Speicherort der PEM-Datei angibt, die Sie vorher erstellen müssen, wenn Sie Diffie-Hellman verwenden</li>
<li><code>tls-crypt tls-crypt.key</code> Erforderliche Einstellung, um die TLS-Schicht noch vor dem Pre-Shared Master zu verschlüsseln</li>
<li><code>tls-auth tls-auth.key 0</code>Einstellung, die es ermöglicht, Parteien über die Verschlüsselung hinaus in der Pre-Handshake-Phase der TLS-Schicht zu authentifizieren</li>
<li><code>crl-verify crl.pem</code> Einstellung um zu prüfen, ob die generierten Zertifikate über die CRL-Liste widerrufen werden oder nicht</li>
<li><code>ca ca.crt</code> Eine Einstellung, die den Speicherort des Zertifikats der Zertifizierungsstelle des generierten Zertifikats meldet</li>
<li><code>cert $SERVER_NAME.crt</code> Eine Einstellung, die den Speicherort des Zertifikats des Servers angibt</li>
<li><code>key $SERVER_NAME.key</code> Eine Einstellung, die den Speicherort des erforderlichen asymmetrischen geheimen Schlüssels neben dem Zertifikat des Servers angibt</li>
<li><code>auth $HMAC_ALG</code> Eine Einstellung, die beschreibt, welcher Hash-Algorithmus für den Datenkanal verwendet werden soll, und ggf. <code>tls-auth</code></li>
<li><code>cipher $CIPHER</code> Eine Einstellung, die angibt, welcher Verschlüsselungsalgorithmus für den Datenkanal verwendet werden soll</li>
<li><code>ncp-ciphers $CIPHER</code> Eine Einstellung, die angibt, welche Verschlüsselungsalgorithmen der Server verwenden kann</li>
<li><code>tls-server</code> Eine Einstellung, die den Server anweist, den TLS-Kanal zu verwenden</li>
<li>Eine Einstellung <code>tls-version-min 1.2</code> meldet die niedrigste Version, die auf dem TLS-Kanal verwendet werden soll</li>
<li><code>tls-cipher $CC_CIPHER</code> Die Verschlüsselung wird auch auf der TLS-Schicht verwendet, mit Ausnahme des Datenkanals, der die Einstellung ist, die die Verschlüsselung des Steuerkanals deklariert</li>
<li><code>client-config-dir /etc/openvpn/ccd</code> Einstellung, die angibt, wo Client-Einstellungsdateien aufbewahrt werden</li>
<li><code>status /var/log/openvpn/status.log</code> Einstellung, die angibt, wo Statusberichte geschrieben und wo Protokolldateien aufbewahrt werden</li>
<li><code>verb 3</code> Diese Einstellung, die die Abkürzung des Wortes Verbose ist, ist die Einstellung, wie detailliert der Statusbericht gegeben werden soll.</li>
</ul>
<h3 id="die-clientseitige-einstellungsdatei-enthält-die-folgenden-einträge">Die clientseitige Einstellungsdatei enthält die folgenden Einträge</h3>
<ul>
<li><code>client</code> gibt an, dass sich das Gerät in der Client-Rolle befindet</li>
<li><code>proto tcp-client</code> meldet TCP als Protokoll</li>
<li><code>remote $IP $PORT</code> Der Teil, in dem die IP-Adresse und die Portnummer des/der zu verbindenden Server(s) festgelegt werden</li>
<li><code>dev tun</code> legt fest, welche der TUN/TAP-Schnittstellen verwendet werden sollen</li>
<li><code>resolve-retry infinite</code> Wir sagen Ihnen, wie lange Sie warten müssen, wenn sich die Adressauflösung aufgrund von IP oder DNS verzögert</li>
<li><code>nobind</code>-Einstellung, um keine Verbindung zu einer Adresse im lokalen Netzwerk herzustellen</li>
<li><code>persist-key</code> Ermöglicht das Lesen von Schlüsseldateien ohne zusätzliche Autorisierung beim Neustart</li>
<li><code>persist-tun</code> Es ermöglicht auch, dass die TUN/TAP-Schnittstelle beim Neustart ohne Autorisierung aufgeweckt wird</li>
<li><code>remote-cert-tls server</code> Überprüft das Zertifikat des verbundenen Servers auf TLS-Ebene</li>
<li><code>verify-x509-name $SERVER_NAME name</code> Befehl, der den Namen im Zertifikat angibt, zu dem der Server zurückkehren wird, und wie der Name des Servers lauten soll</li>
<li><code>auth $HMAC_ALG</code> Befehl, der angibt, welcher Algorithmus für die Validierung verwendet werden soll</li>
<li><code>auth-nocache</code> Speichert das für die Anmeldung erforderliche Passwort nicht</li>
<li><code>cipher $CIPHER</code> Befehl zur Auswahl des für die Verschlüsselung zu verwendenden Algorithmus</li>
<li><code>tls-client</code> aktiviert TLS während der TLS-Kommunikation und übernimmt die Client-Rolle</li>
<li><code>tls-version-min 1.2</code> Legt die niedrigste TLS-Version fest</li>
<li><code>tls-cipher $CC_CIPHER</code> wählt den Verschlüsselungsalgorithmus aus, der im TLS-Steuerkanal verwendet werden soll</li>
<li><code>ignore-unknown-option block-outside-dns</code> Verhindert, dass unbekannte DNS-Adressen verwendet werden</li>
<li><code>setenv opt block-outside-dns</code> blockiert DNS-Leaks für Windows 10</li>
<li><code>Verb 3</code> Bestimmt den Grad der Berichterstattung</li>
<li><code>compress</code> Hier werden die Einstellungen des Komprimierungsalgorithmus gemeldet</li>
<li><code>&quot;&lt;ca&gt;/etc/openvpn/easy-rsa/pki/ca.crt&lt;/ca&gt;&quot;</code> Hartcodierte Einbettung der erwarteten Server-Zertifizierungsstellendatei</li>
<li><code>&quot;&lt;cert&gt;/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt&lt;/cert&gt;&quot;</code> Hartcodierte Einbettung der Client-Zertifikatsdatei</li>
<li><code>&quot;&lt;key&gt;/etc/openvpn/easy-rsa/pki/private/$CLIENT.key&lt;/key&gt;&quot;</code> Hartcodierte Einbettung des asymmetrischen geheimen Schlüssels des Clients</li>
<li><code>&quot;&lt;tls-crypt&gt;/etc/openvpn/tls-crypt.key&lt;/tls-crypt&gt;&quot;</code> Angabe der Schlüsseldatei für TLS-Crypt</li>
<li><code>&quot;&lt;tls-auth&gt;/etc/openvpn/tls-auth.key&lt;/tls-auth&gt;&quot;</code> Angabe der Schlüsseldatei für die TLS-Authentifizierung</li>
<li><code>key-direction 1</code> weist Client und Server Rollen für die TLS-Layer-Verschlüsselung zu (0 und 1)</li>
</ul>
<p>Eine ausführliche Dokumentation dieser Einstellungen und mehr finden Sie auf der Webseite <a href="https://openvpn.net/community-resources/reference-manual-for-openvpn-2-4/">OpenVPN</a>.</p>
<h2 id="was-passiert-beim-aufbau-einer-openvpn-verbindung">Was passiert beim Aufbau einer OpenVPN-Verbindung?</h2>
<p>Jedes Mal, wenn ich mich mit OpenVPN verbinde, fühle ich mich, als würde R2-D2 ihre Pläne der Sternenflotte entführen. Die Leute wollen sich nicht immer einer genauen Prüfung unterziehen und bitten vielleicht jemanden, ihnen zu erklären, was und wie. In meiner Absicht, diesen Artikel zu schreiben, habe ich mir diese Frage tatsächlich gestellt und mich sehr bemüht, die Antwort zu bekommen. Ich möchte nicht, dass Sie sich so viel Mühe geben, aber ich kann nicht sagen, dass Sie es sofort hochladen sollen, denken Sie nicht an den Rest, es ist mein Job. Wie eingangs versprochen, werde ich Ihnen diesen Vorgang ausführlich erläutern und Ihnen die Entscheidung überlassen. So funktioniert der Prozess in einer OpenVPN-Verbindung, Vor- und Nachteile (wie ich es bisher herausfinden konnte). Sie bauen zunächst eine TCP/UDP-Verbindung auf. Sie führen einen Prozess wie jede Anwendung aus, die TCP verwendet, und wechseln dann zur TLS-Schicht. Sie führen einen Handshake und eine Authentifizierung auf der TLS-Schicht durch. Diese Schicht wird auch Steuerkanal genannt. Dann wird eine bestimmte Kommunikation festgelegt und der Datenkanal weitergegeben. Der Prozess der Ver- und Entschlüsselung der diesmal zu versendenden Datenpakete im Daten- bzw. Datenkanal beginnt. Dazu sprechen Geräte miteinander und Daten werden unter bestimmten gemeinsamen Bedingungen gesendet. Kurz gesagt, am Ende des von mir so beschriebenen Prozesses endet die von uns bei 0 begonnene Kommunikation mit dem sicheren und erwünschten Datenzugriff auf uns, oder es werden erneut Anfragen gesendet, diesmal auf umgekehrtem Weg, über die Verbindung that offen gehalten wird. So entsteht ein System wie ineinander verschachtelte Rohre. Wenn Sie hier das einzig Wichtige für den Artikel schreiben müssen:</p>
<ul>
<li>Es wird <code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512</code> sein.
<ul>
<li>Hier gibt die Eingabe <code>TLS</code> an, dass der Kontrollkanal über die TLS-Schicht ausgeführt wird. Andere Alternativen sind <code>SSL</code> oder <code>NULL</code>.</li>
<li>Die Eingabe <code>ECDHE</code> gibt an, dass der erste Vorschlüssel unter Verwendung des elliptischen Diffie-Hellman-Algorithmus generiert wird. Andere Alternativen sind die Verwendung von <code>DHE</code>, <code>DH</code> oder nicht.</li>
<li>Die <code>ECDSA</code>-Daten geben an, dass der Elliptic Digital Signature Certificate Algorithm für die gegenseitige Authentifizierung und den asymmetrischen Schlüssel verwendet wird. Eine weitere verfügbare Alternative ist <code>RSA</code>. Die anderen braucht man nicht zu zählen.</li>
<li>Gibt den Verschlüsselungsalgorithmus an, der auf dem Datenkanal <code>AES_256_GCM</code> verwendet werden soll. Andere Alternativen sind <code>AES-128-CBC</code>, <code>AES-128-GCM</code> und <code>AES-256-CBC</code>.</li>
<li><code>SHA384</code> gibt den zu verwendenden Hash-Algorithmus an. Die andere Alternative ist <code>SHA256</code>.</li>
<li><code>P512</code> ermöglicht die Auswahl der elliptischen Kurve als Prime-512. Andere Alternativen sind <code>P-256</code> und <code>P-384</code>.</li>
</ul>
</li>
</ul>
<h3 id="der-prozess-des-aufbaus-der-tcp-verbindung">Der Prozess des Aufbaus der TCP-Verbindung</h3>
<p>Wenn Sie nun ein ungefähres Bild des Prozesses im Kopf haben, beginne ich mit der Erklärung des TCP-Prozesses. Nehmen wir an, wir haben in unserem Fall einen Client und einen Server, und die Verbindung besteht nur aus diesen beiden. Der Client sendet ein SYN (m)-Paket an den Server, mit dem er sich verbinden möchte. Als Antwort sendet der Server ein SYN (n)-Paket und ein ACK (m+1)-Paket über denselben Port. Der Client, der dies empfängt, gibt ebenfalls als Antwort ACK (n+1) zurück, und es findet ein 3-Wege-TCP-Handshake oder ein 3-Wege-TCP-Handshake statt. Somit haben wir einen offenen Kanal zwischen Client und Server über den angegebenen Port.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://blog.shiftasia.com/what-happen-when-access-website (Datum: 08.04.2023)</b></small></center>
</picture></p>
<hr>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Datum: 08.04.2023)</b></small></center>
</picture></p>
<p>Wie auf den Fotos zu sehen, kann bei reibungslosem Ablauf die Kommunikation in 3 Schritten erfolgen. Aber wenn Sie fragen, warum wir das in 3 Schritten machen, geht das nicht auch kürzer? Ich würde (vorerst) nein sagen, nein, für eine Vollduplex-Kommunikation müssen beide Parteien SYN- und ACK-Pakete senden. Vielleicht erzähle ich Ihnen in Zukunft andere Wege, aber im Moment ist es so. Wie auch immer, der TCP/UDP-Teil ist immer kurz und einfach.</p>
<h3 id="prozess-der-in-der-tls-schicht-ausgeführt-wird">Prozess, der in der TLS-Schicht ausgeführt wird</h3>
<p>Nach dem Aufbau einer Kommunikation über TCP ist der Client die Person, die die Konversation auf eine andere Ebene bringt. Clients fordern immer etwas vom Server an oder fordern eine Antwort an. Im Allgemeinen reagieren Server nicht auf eine Anfrage, die nicht bei ihnen angekommen ist. Der Prozess läuft nach dem Prinzip <code>Erst Nachfrage, dann Angebot</code> ab. Ja, die Parteien befinden sich jetzt auf der TLS-Schicht. Der Client begrüßt zuerst den Server. Kein Scherz, es ist echt. Das erste vom Client gesendete Paket wird als <code>Client-Hello</code>-Paket bezeichnet. Neben diesem Paket (um den Vorgang zu beschleunigen) das Paket <code>Supported-Chipers</code>, das die unterstützten Verschlüsselungsalgorithmen angibt, eine vom Client zufällig generierte Nummer, ein <code>SNI</code>-Servernamensindikator, wenn mehr als ein Dienst vorhanden ist die auf derselben IP-Adresse ausgeführt werden, und ggf. die Sitzungs-ID. . Die Antwort des Servers darauf ist zunächst einmal ein höfliches Hallo. Denn das erste Paket, das der Server als Antwort sendet, heißt <code>Server-Hello</code>-Paket. Neben diesem Paket sendet das <code>Selected-Chiper</code>-Paket, das das Serverzertifikat, die unterstützten Verschlüsselungsalgorithmen und den ausgewählten Algorithmus angibt, eine von ihm generierte Zufallszahl, gegebenenfalls die Sitzungs-ID und eine SNI-ähnliche ID wenn sich mehr als ein Client über dieselbe IP verbindet. . Der Client verifiziert zunächst anhand des Serverzertifikats, ob es sich wirklich um die Person handelt, auf die er wartet, indem er die Kommunikation startet. Außerdem prüft der Server in manchen Fällen mit einem Zertifikat, ob der Client einer der Clients ist, die er erwartet. Wenn dieser gegenseitige Authentifizierungsprozess positiv ist, wird die nächste Stufe bestanden. Der Schlüsselerzeugungs- und Austauschprozess wird ausgelöst. In dieser Phase greift der Client erneut ein und sagt, dass er den Schlüssel mit dem Algorithmus ändern möchte, den er während dieser Kommunikation festgelegt hat, was als unsicher gilt. Die Parteien beginnen mit der Generierung eines Prekeys mit Diffie-Hellman oder ECDHE. Dazu werden Pre-Secrets von Client und Server geteilt. Die Antworten, die durch Ausführen einer Reihe mathematischer Operationen gefunden wurden, werden nach oben gesendet, und das gleiche Ergebnis wird durch erneutes Ausführen mathematischer Operationen erreicht. Das Ergebnis ist der erste Fore-Key, den sie sicher zwischen ihnen erstellt haben. Danach, mit dem von ihnen bestimmten Verschlüsselungsalgorithmus, Ein anderer Datenkanal als der Steuerkanal wird zur Kommunikation erstellt, und der Prozess wird von dort aus fortgesetzt.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Datum: 08.04.2023)</b></small></center>
</picture></p>
<hr>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></p>
<p>Wie auf den Fotos zu sehen ist, ist der Vorgang fast derselbe wie beim Herstellen einer Verbindung zu einer Webseite. Je nach Bedarf werden nur bestimmte Stufen hinzugefügt, entfernt oder geändert. Beispielsweise übermitteln die Parteien gemäß PFS, was für Advanced Privacy steht, den Front-Key nicht mit dem asymmetrischen Schlüssel des Servers. Da in diesem Fall für jede Sitzung derselbe Schlüssel verwendet wird, werden die Daten gespeichert und sind dann rückwirkend lesbar, indem auf einen Tag gewartet wird, an dem der Schlüssel enthüllt wird. Deshalb wurde diese Änderung vorgenommen. Auch hier möchte ich gemäß dem Zero-Trust-Bedrohungsmodell, dass jede Schicht und jeder Prozess den Prozess vorantreibt, ohne darauf zu vertrauen, dass die andere ihre Arbeit korrekt erledigt. Aus diesem Grund wollen wir, dass die Pakete gemäß der Funktion <code>tls-auth</code> verschlüsselt werden und die Integrität der ein- und ausgehenden Daten bereits im ersten Kommunikationsmoment in der TLS-Schicht überprüft wird. Vom ersten Moment an, in dem Sie Hallo sagen, können Dritte nicht verstehen, wovon Sie sprechen und in welcher Phase Sie sich befinden. Dazu wird die erste Kommunikation mit einem oder mehreren vorgegebenen Schlüsseln gestartet und bei Bedarf werden diese Schlüssel in regelmäßigen Abständen erneuert. So wird auch bis zur Erstellung des ersten Pre-Keys in der TLS-Schicht die Vertraulichkeit nicht kompromittiert und Unbefugte nicht umsonst erstellt.</p>
<h3 id="prozess-der-in-der-datenschicht-ausgeführt-wird">Prozess, der in der Datenschicht ausgeführt wird</h3>
<p>Wenn dieser gesamte Vorgang erfolgreich abgeschlossen und der Datenkanal bestanden wurde, sind Sie nun beim besten Teil der Arbeit angelangt. Die Daten werden mit der AES-Verschlüsselungsmethode verschlüsselt. Während der Verschlüsselung werden die Tabellen gemäß dem CBC-GCM-Zählermodus gemäß Ihrer Auswahl gemischt, und bei diesem Vorgang wird gemäß Ihrer Auswahl ein 128- oder 256-Bit-Verschlüsselungsschlüssel verwendet. Unabhängig von Ihrer Wahl beträgt die Verschlüsselungsblocklänge natürlich 128 Bit. Nur die Länge des Verschlüsselungsschlüssels ändert sich. AES-256-GCM, das ich für diese Erklärung ausgewählt habe, ist ein AEAD-Verschlüsselungstyp. Es fasst die von ihm gesendeten Daten unabhängig von anderen Kanälen und Prozessen zu einem bestimmten Zeitpunkt zusammen und versendet sie zusammen mit der Zusammenfassung. Somit werden Authentifizierungs- und Verschlüsselungsfunktionen in AEAD erfüllt, was für <code>Authentication Encryption with Associated Data</code> steht. Es gibt ein Problem, das hier eine Unterscheidung erfordert. In welcher Phase und in welcher Reihenfolge werden wir die Verschlüsselungs- und Hash-Algorithmen verwenden?</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Encrypt-then-MAC (EtM)</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Encrypt-and-MAC (E-and-M)</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>MAC-then-Encrypt (MtE)</b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Authenticated_encryption">https://en.wikipedia.org/wiki/Authenticated_encryption</a> (Datum: 08.04.2023)</p>
</blockquote>
<ul>
<li>
<p>Laut EtM, dem ersten Ansatz, werden die Daten zuerst verschlüsselt, dann als Ergebnis des Digests mit einem anderen Schlüssel verschlüsselt und das resultierende Ergebnis in Blöcken zusammen gesendet. Wenn wir uns reale Lösungen ansehen, die es verwenden, fällt uns zuerst das IPSec-Protokoll ein. Dies ist die einzige Methode, die die höchste Sicherheitsdefinition in AE erreichen kann, dies kann jedoch nur erreicht werden, wenn der verwendete MAC-Algorithmus frei von Korruption ist oder noch nicht geknackt wurde. Für SSHv2 sind auch verschiedene EtM-Cipher-Suites verfügbar. Beachten Sie jedoch, dass für Daten und Digest eine Schlüsseltrennung zwingend erforderlich ist (für Verschlüsselung und Schlüssel-Hashing müssen unterschiedliche Schlüssel verwendet werden), da Sie sonst je nach verwendeter Verschlüsselungsmethode und Hash-Funktion möglicherweise ein unsicheres Ergebnis erhalten.</p>
</li>
<li>
<p>Gemäß dem zweiten Ansatz, E&amp;M, werden Klartextdaten verschlüsselt und daneben wird eine Zusammenfassung des Verschlüsselungszustands der Klartextdaten hinzugefügt. Obwohl hier nur ein Schlüssel verwendet wird, zeigt die Tatsache, dass zwei unterschiedliche Ergebnisse (Verschlüsselungsergebnis und Digest-Ergebnis) für dieselben Daten vorliegen, deutlich, dass die Sicherheit nicht gut genug ist. Als reale Lösung mit diesem System können wir die ersten Versionen von SSH als Beispiel anführen. Um dies zu verbessern, wurden Methoden wie das Verschlüsseln der gesendeten Zusammenfassungsdatei mit demselben Schlüssel ausprobiert.</p>
</li>
<li>
<p>Laut MtE, dem dritten und letzten mir bekannten Ansatz, wird eine Zusammenfassungsdatei auf Basis von Klartext generiert. Dann werden der Klartext und die Digest-Datei zusammen mit dem Schlüssel verschlüsselt. Der Chiffretext und die Chiffretextdatei werden zusammen gesendet. Wenn wir uns reale Lösungen ansehen, die es verwenden, sind das in erster Linie SSL/TLS-Implementierungen. Wir alle wissen, wie zuverlässig und nachhaltig SSL/TLS-Anwendungen an sich sind. Darüber hinaus wurden im Laufe der Jahre Verbesserungen wie <code>MAC-then-pad-then-encrypt</code> vorgenommen, um die Sicherheit zu erhöhen. Gemäß dieser Verbesserung wird zuerst der Klartext verdaut, dann auf die Blockgröße aufgefüllt und dann die Verschlüsselung durchgeführt. Dies führt zu einem noch zuverlässigeren Verschlüsselungsergebnis. Aber es gibt Fälle, in denen der Padding-Mechanismus Angriffe wie Padding Oracle verursacht, wenn er bestimmte Fehler macht.</p>
</li>
</ul>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Datum: 08.04.2023)</b></small></center>
</picture></p>
<p>Nach der Auswahl des zu verwendenden AEAD-Ansatzes wird je nach Verwendung von TAP oder TUN der in der obigen Grafik dargestellte Weg beschritten. Gemäß diesem Pfad geht die im Benutzerbereich ausgeführte/gewünschte Aktion zu den TAP/TUN-Adaptern auf Kernel-Ebene. Da sich diese Adapter auf der Kernel-Ebene befinden, arbeiten sie sehr schnell. Dann führen die virtuellen Adapter die notwendige Verschlüsselung mit der entsprechenden Bibliothek durch, fügen ggf. den Digest hinzu und stellen die Paketgröße ein. Dann sendet der Server Pakete sequentiell über die Ethernet-Schnittstelle an die Ethernet-Schnittstelle des Clients. Der Client, der es erhält, konfiguriert die Pakete neu, organisiert sie, kombiniert sie bei Bedarf und entschlüsselt sie mit den erforderlichen Bibliotheken. Nach der Entschlüsselung überträgt es den Client über den virtuellen Adapter an den Endbenutzer. Als Ergebnis all dieser mathematischen Operationen und Bemühungen erreichte der Benutzer also nach einigen Zyklen den gewünschten Inhalt. Es ist ziemlich lang zu erklären, aber sehr einfach zu bedienen, liebe Leser. Sie müssen nur die entsprechende <a href="https://github.com/wiseweb-works/openvpn-most-secure-install/">Skriptseite</a> auf meiner GitHub-Seite besuchen. Das zugehörige Skript nimmt all diese Anpassungen interaktiv für Sie vor. Alles, was Sie tun müssen, ist sich zurückzulehnen und zu genießen.</p>
<h1 id="faq-und-ende">FAQ und Ende</h1>
<p>Erhielt mich per <a href="mailto:wisewebworks@outlook.com">Mail</a>, <a href="https://fosstodon.org/@wise">Fosstodon</a> oder <a href="https://github.com/wiseweb-works">GitHub</a> I werde versuchen, hier von Zeit zu Zeit Fragen hinzuzufügen. So kommen Sie historisch gesehen direkt zum Ergebnis, ohne darüber nachzudenken, welche Art von Fragen zu welchem ​​Zeitpunkt aufgetreten sind oder ob es eine Lösung gibt. Abgesehen davon, wenn es Fragen gibt, die einer zusätzlichen Erklärung bedürfen, ohne das technische Dokument zu ändern, denke ich, sie in diesen Abschnitt aufzunehmen.</p>
]]></content:encoded></item><item><title>Generieren eines ECC-SSL-Zertifikats auf einem Linux-Server</title><link>https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikasi/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/de/post/ecc-ssl-sertifikasi/</guid><description>Einführung und Zusammenfassung Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen.</description><content:encoded><![CDATA[<h1 id="einführung-und-zusammenfassung">Einführung und Zusammenfassung</h1>
<p>Heute lernen wir, wie man SSL-Zertifikate generiert, um sicherzustellen, dass der Datenverkehr zwischen einer von Ihnen verwalteten Website oder einem Anwendungsserver und Ihren Besuchern vertraulich / zuverlässig und überprüfbar ist. In meinen vorherigen Artikeln habe ich erklärt, wie und mit welcher Konfiguration Sie das von Ihnen erstellte Zertifikat bereitstellen würden. In diesem Artikel zeige ich Ihnen, wie Sie die Gleichung „weniger Brot, mehr Frikadellen“ aufstellen, also ein schnelleres und sichereres SSL-Zertifikat erstellen. Wenn Sie mit dem ACME-Protokoll von Let’s Encrypt vertraut sind (zum Zeitpunkt des Schreibens), ist es normalerweise möglich, ein 1024-4098 (wenn Sie sich zu sehr anstrengen, vielleicht 8196) Bit-Zertifikat mit einer asymmetrischen RSA-Schlüsselstruktur zu generieren und es für zu verwenden 90 Tage relativ. Das Generieren eines so großen Schlüssels, dessen Verwendung während des TLS-Handshakes nach der Generierung und die Kompatibilität mit den von den Besuchern verwendeten Geräten verursachen jedoch in den meisten Szenarien Probleme. Wenn beispielsweise 4096 Bit anstelle von 2048 Bit verwendet werden, bin ich bei einigen meiner Versuche mit 0,4-0,8 Sekunden längeren Handshake-Zeiten konfrontiert. Als ob es in Ordnung wäre, dass der Handshake so lange dauert, wird der Server dadurch zusätzlich belastet. Aber wenn Sie ein 384-Bit-ECC-Zertifikat anstelle von 4096-Bit-RSA generieren, erhalten Sie ein viel schnelleres Zertifikat und gleichzeitig eine Sicherheit, die 7680-Bit-RSA entspricht (wenn es diese Größe hätte).</p>
<p>Nun, Sie haben es gut erklärt, aber wo ist der Sinn dieser Arbeit, scheine ich Sie sagen zu hören. Ich werde Sie verärgern, aber dieses Geschäft hat keinen Sinn. Der Grund, warum dies nicht der Fall ist, ist in der Hintergrundmathematik verborgen. Ich werde kurz auf die kleinen Unterschiede in der Herstellung und Verwendung beider Zertifikate eingehen, erklären, wie und warum sie große Unterschiede verursachen, und im letzten Teil werde ich über etwas sprechen, das nicht als Bonus im Titel steht. (Für den Bonus musst du bis zum Ende lesen :D)</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.globalsign.com/en/blog/elliptic-curve-cryptography (Datum: 08.04.2023)</b></small></center>
</picture></p>
<h2 id="produktionsprozess-des-ecc-zertifikats">Produktionsprozess des ECC-Zertifikats</h2>
<p>Zuerst müssen wir (wie immer) die neuesten Updates über die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx-Dienstes (das ist der Dienst, der es Ihnen ermöglicht, externe HTTP/HTTPS-Verbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Zunächst einmal sollte angemerkt werden, dass es sich aufgrund der Verwirrung bei Apache-, Nginx- und Litespeed-Diensten um unterschiedliche Dienste handelt, die die gleiche Aufgabe erfüllen. Ich habe mich für NGINX entschieden, weil es einfacher zu verwalten ist und mehr Community-Unterstützung bietet.</p>
<h2 id="lassen-sie-uns-den-privaten-schlüssel-generieren">Lassen Sie uns den privaten Schlüssel generieren</h2>
<p>Zuerst generieren wir den privaten Schlüssel mit OpenSSL. Der OpenSSL-Befehl, den wir verwenden werden, ist „ecparam“ (EC-Parametermanipulation) und um die Konfigurationsparameter an diesen Befehl zu übergeben:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</span></span></code></pre></div><ul>
<li>Die Option <code>-genkey</code> weist OpenSSL an, einen EC-Schlüssel zu generieren.</li>
<li>Der Parameter <code>-name</code> teilt OpenSSL mit, welche Kurve verwendet werden soll.</li>
<li>Der Parameter <code>-out</code> weist OpenSSL an, die Ausgabe in eine Datei zu schreiben.</li>
</ul>
<p>Beachten Sie, dass OpenSSL seine Ausgabe standardmäßig im PEM-Format schreibt. Wir können überprüfen, ob OpenSSL das Richtige tut, mit dem Befehl <code>ec</code>, der EC-Schlüssel verarbeitet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ec -in privkey.pem -noout -text
</span></span></code></pre></div><ul>
<li><code>-in</code> ist eine Eingabedatei</li>
<li>Das <code>-noout</code> weist OpenSSL an, den Schlüssel nicht zu extrahieren, und gibt sinnlos privkey.pem nach stdout aus.</li>
<li><code>-text</code> weist OpenSSL an, Informationen über den Schlüssel im Klartextformat zu schreiben</li>
</ul>
<p>Wenn alles gut geht und der Schlüssel korrekt generiert wurde, zeigt OpenSSL etwa Folgendes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>read EC key
</span></span><span style="display:flex;"><span>Private-Key: (384 bit)
</span></span><span style="display:flex;"><span>priv:
</span></span><span style="display:flex;"><span>    [secret]
</span></span><span style="display:flex;"><span>pub:
</span></span><span style="display:flex;"><span>    [secret]
</span></span><span style="display:flex;"><span>ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>NIST CURVE: P-384
</span></span></code></pre></div><p>Dadurch wird bestätigt, dass der Schlüssel mit der P-384-Kurve erstellt wurde. Wenn Sie sich fragen, warum wir nicht P-512 statt P-384 verwenden, Let&rsquo;s Encrypt signiert nicht, wenn die Ekliptikkurven höher als 384 Bit sind, und moderne Browser wie Google Chrome markieren Websites, die 512-Bit-Ekliptikkurven verwenden, als ungültig . Das ist die kurze Antwort.</p>
<h2 id="erstellen-wir-eine-openssl-konfiguration-für-das-zertifikat">Erstellen wir eine OpenSSL-Konfiguration für das Zertifikat</h2>
<p>Jetzt müssen wir eine OpenSSL-Konfigurationsdatei erstellen, die die domänenspezifischen Parameter enthält, für die wir das TLS-Zertifikat erhalten möchten. In diesem Beispiel tragen wir die folgende Konfiguration in eine <code>openssl.cnf</code>-Datei ein:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>[ req ]
</span></span><span style="display:flex;"><span>prompt = no
</span></span><span style="display:flex;"><span>encrypt_key = no
</span></span><span style="display:flex;"><span>default_md = sha512
</span></span><span style="display:flex;"><span>distinguished_name = dname
</span></span><span style="display:flex;"><span>req_extensions = reqext
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ dname ]
</span></span><span style="display:flex;"><span>CN = example.com
</span></span><span style="display:flex;"><span>emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ reqext ]
</span></span><span style="display:flex;"><span>subjectAltName = DNS:example.com, DNS:www.example.com
</span></span></code></pre></div><p>Hier ist eine kurze Beschreibung dieser Konfigurationsoptionen:</p>
<p>Im erforderlichen <code>[ req ]</code>-Abschnitt:</p>
<ul>
<li><code>prompt=no</code> weist OpenSSL an, so viel Konfiguration wie möglich aus der Konfigurationsdatei zu holen</li>
<li><code>encrypt_key = no</code> weist OpenSSL an, den privaten Schlüssel nicht mit einem Passwort zu verschlüsseln. (Verschlüsselte private Schlüssel werden von Nginx unterstützt, aber ich verwende sie nicht.)</li>
<li><code>default_md=sha512</code> weist OpenSSL an, die CSR mit SHA512 zu signieren. (Soweit ich weiß, unterstützt Let&rsquo;s Encrypt nur RSA mit SHA256 für seine Signaturen, aber das bedeutet nicht, dass wir in CSR keine stärkere Verschlüsselung verwenden können.)</li>
<li><code>distinguished_name=dname</code> weist OpenSSL an, nach einem <code>[ dname ]</code>-Abschnitt für Konfigurationsoptionen für Distinguished Name zu suchen.</li>
<li>„req_extensions=reqext“ weist OpenSSL an, in den Konfigurationsoptionen nach „Subject Alternative Names“ (SANs)-Erweiterungen, die es konfigurieren möchte, nach einem „[ reqext ]“-Abschnitt zu suchen.</li>
</ul>
<p>Im Abschnitt Distinguished Name <code>[ dname ]</code>:</p>
<ul>
<li>„CN = example.com“ gibt den Common Name des Zertifikats an.</li>
<li>Ihre <code>emailAddress = admin@example.com</code> E-Mail-Adresse muss prominent sein.
Gewünschte Erweiterungen Im Abschnitt „[ reqext ]“ stellt subjectAltName die Liste der SANs für das Zertifikat bereit. (Chrome ab v58 erfordert, dass der Common Name in der Liste der SANs enthalten ist).</li>
</ul>
<p>Let&rsquo;s Encrypt v2 unterstützt Platzhalterdomänen, daher können Sie in diesem Beispiel einen einstufigen Platzhalter für Nicht-Apex-Hosts (*.example.com) verwenden.</p>
<h2 id="lassen-sie-uns-eine-zertifikatsignieranforderung-erstellen">Lassen Sie uns eine Zertifikatsignieranforderung erstellen</h2>
<p>Der letzte Schritt auf der Client-Seite besteht darin, die Zertifikatsignieranforderung mit OpenSSL zu generieren, dann leiten wir sie zum Signieren an Let’s Encrypt weiter und rufen das signierte Zertifikat ab.</p>
<p>Der zum Generieren einer CSR erforderliche OpenSSL-Befehl lautet <code>req</code> .</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</span></span></code></pre></div><ul>
<li><code>-new</code> teilt OpenSSL mit, dass wir eine CSR erstellt haben (und wir keine bestehende CSR untersuchen)</li>
<li><code>-config</code> openssl.cnf gibt die Konfigurationsdatei an, die wir oben erstellt haben</li>
<li><code>-key privkey.pem</code> gibt den privaten Schlüssel an, den wir oben erstellt haben</li>
<li><code>-out csr.pem</code> weist OpenSSL an, die CSR in eine Ausgabedatei zu schreiben (anstelle von stdout)</li>
</ul>
<p>Wir können überprüfen, ob wir die CSR korrekt erstellt haben:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -in csr.pem -noout -text -verify
</span></span></code></pre></div><ul>
<li><code>-verify</code> fordert OpenSSL auf, die Signatur in der CSR zu verifizieren</li>
</ul>
<p>Dies sollte die folgenden erwarteten Ergebnisse in der Ausgabe erzeugen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>verify OK
</span></span><span style="display:flex;"><span>Certificate Request:
</span></span><span style="display:flex;"><span>    Data:
</span></span><span style="display:flex;"><span>        Version: 1 (0x0)
</span></span><span style="display:flex;"><span>        Subject: CN = example.com, emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>        Subject Public Key Info:
</span></span><span style="display:flex;"><span>            Public Key Algorithm: id-ecPublicKey
</span></span><span style="display:flex;"><span>                Public-Key: (384 bit)
</span></span><span style="display:flex;"><span>                pub:
</span></span><span style="display:flex;"><span>                    [ommited]
</span></span><span style="display:flex;"><span>                ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>                NIST CURVE: P-384
</span></span><span style="display:flex;"><span>        Attributes:
</span></span><span style="display:flex;"><span>        Requested Extensions:
</span></span><span style="display:flex;"><span>            X509v3 Subject Alternative Name:
</span></span><span style="display:flex;"><span>                DNS:example.com, DNS:www.example.com
</span></span><span style="display:flex;"><span>    Signature Algorithm: ecdsa-with-SHA512
</span></span><span style="display:flex;"><span>         [ommited]
</span></span></code></pre></div><h2 id="bitten-sie-lets-encrypt-unser-zertifikat-zu-signieren">Bitten Sie Let&rsquo;s Encrypt, unser Zertifikat zu signieren</h2>
<p>Der letzte Schritt besteht darin, die CSR mit einem ACME-Client zum Signieren an Let&rsquo;s Encrypt zu senden, &ldquo;certbot&rdquo; ist der häufigste Client für diesen Job.</p>
<p>Befehlszeilenoptionen, die an den „Certbot“-Client übergeben werden, hängen von unserem Setup, der Person, für die unsere Domain registriert ist, usw. ab. Normalerweise müssen wir den Befehl &ldquo;certonly&rdquo; verwenden, und wenn Sie Sternchen (*) verwendet haben, müssen Sie eines der certbot-DNS-Plugins verwenden.</p>
<p>Ist beispielsweise die Domain „example.com“ bei Cloudflare registriert, können wir die Verifizierung über das entsprechende Plugin durchführen, was äußerst komfortabel ist und keinen manuellen Eingriff in den Vorgang erfordert. (Das Konfigurieren des Cloudflare-Plugins mit geheimen Token-Informationen würde den Rahmen dieses Artikels sprengen.)</p>
<p>Es wird normalerweise empfohlen, zuerst mit <code>--dry-run</code> sicherzustellen, dass alles in Ordnung ist, um sicherzustellen, dass alles in Ordnung ist.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --dry-run --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><ul>
<li>Anführungszeichen sind um Zeichen herum erforderlich, um fehlerhafte Manipulationen zu vermeiden, und sind im Allgemeinen eine gute Idee.</li>
<li><code>--csr csr.pem</code> teilt certbot mit, dass wir bereits ein Zertifikat haben und Let’s Encrypt benötigen, um es für uns zu signieren.</li>
</ul>
<p>Der Certbot-Client überprüft auf der Befehlszeile, ob die angeforderte Liste der Domänen mit den im Zertifikat aufgeführten Domänen übereinstimmt, und verwendet das Certbot-NGINX-Plug-in, um zu überprüfen, ob die Domäne unsere ist, und teilt uns mit, falls es Probleme gibt.</p>
<p>Wenn nichts falsch ist, wird es Ihnen sagen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>WICHTIGE NOTIZEN:
</span></span><span style="display:flex;"><span> - Der Probelauf war erfolgreich.
</span></span></code></pre></div><p>Der eigentliche Befehl lautet wie folgt:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><p>Nach einer (langen) Verzögerung gibt der Client Folgendes aus:</p>
<ol>
<li>Signiertes Zertifikat: <code>0000_cert.pem</code></li>
<li>Stamm- und Zwischenzertifikate: „0000_chain.pem“.</li>
<li>Zertifikat + Zwischenprodukte: <code>0001_chain.pem</code>
An dieser Stelle kann die CSR <code>csr.pem</code> gelöscht werden.</li>
</ol>
<p>Wenn wir neugierig sind, können wir die vom Client zurückgegebenen Zertifikate mit OpenSSL mit dem Befehl &ldquo;x509&rdquo; überprüfen:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl x509 -in 0001_chain.pem -noout -text
</span></span></code></pre></div><p>Leider werden wir feststellen, dass Let’s Encrypt wie oben beschrieben unser Zertifikat mit einer SHA256-Signatur signiert. (SHA512 ist nicht nur sicherer, sondern übertrifft SHA256 auf modernen 64-Bit-CPUs.) Aber unser öffentlicher Schlüssel sollte immer noch ECDSA verwenden.</p>
<p>Diese Dateien sind nicht gewöhnlich, daher müssen wir sie auf informativere Weise verschieben und bearbeiten.</p>
<p>Unter Debian Linux erstelle ich gerne Unterverzeichnisse für meine Domains, indem ich meinen privaten Schlüssel in <code>/home/USER_NAME/SSL/private/example.com/privkey.pem</code> und Zertifikate behalte:</p>
<ul>
<li><code>/home/USER_NAME/SSL/certs/example.com/cert.pem</code></li>
<li><code>/home/USER_NAME/SSL/certs/example.com/chain.pem</code></li>
<li><code>/home/USER_NAME/SSL/certs/example.com/fullchain.pem</code></li>
</ul>
<h1 id="ende">ENDE</h1>
<p>Wenn wir alles richtig gemacht haben, bestätigt die Überprüfung des Zertifikats mit einem Webbrowser wie Chrome, dass es sich um ein EC-Zertifikat handelt:</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Datum: 08.04.2023)</b></small></center>
</picture></p>
<p>Mozilla Observatory wird uns auch eine A+ Bewertung geben!</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Datum: 08.04.2023)</b></small></center>
</picture></p>
<p>Darüber hinaus können wir als Ergebnis des SSL Labs-Berichts sehen, dass ein 384-Bit-ECC-Zertifikat verwendet wurde.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>SSL Labs Test</b></small></center>
</picture></p>
<p>HINWEIS: Dieser Artikel profitiert vom Artikel von <a href="https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc">Benjamin Black</a> zum gleichen Thema.</p>
]]></content:encoded></item><item><title>Erhöhung der SSL-Sicherheit auf Linux-Servern</title><link>https://wiseweb-works.github.io/blog/de/post/ssl-konfigurasyonu/</link><pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/de/post/ssl-konfigurasyonu/</guid><description>Erhöhung der SSL-Sicherheit auf Linux-Servern Wenn Sie heute eine Website und/oder App auf Ihrem aktuellen Server betreiben, werde ich über die benötigte SSL-Verbindung und die damit verbundene openssl-Bibliothek sprechen. SSL (Secure Socket Layer) und TLS (Transport Layer Security) sind eine Form der Verbindung, die es Personen, die sich mit Ihrem Server verbinden möchten, ermöglicht, sicher mit Ihrer Website zu kommunizieren. In der Vergangenheit gab es Versionen von SSL v1 bis v3, und während Websites im Allgemeinen diese SSL-Versionen verwenden, wurde SSL jetzt von den Websites aufgegeben und durch das sicherere TLS ersetzt.</description><content:encoded><![CDATA[<h1 id="erhöhung-der-ssl-sicherheit-auf-linux-servern">Erhöhung der SSL-Sicherheit auf Linux-Servern</h1>
<p>Wenn Sie heute eine Website und/oder App auf Ihrem aktuellen Server betreiben, werde ich über die benötigte SSL-Verbindung und die damit verbundene openssl-Bibliothek sprechen. SSL (Secure Socket Layer) und TLS (Transport Layer Security) sind eine Form der Verbindung, die es Personen, die sich mit Ihrem Server verbinden möchten, ermöglicht, sicher mit Ihrer Website zu kommunizieren. In der Vergangenheit gab es Versionen von SSL v1 bis v3, und während Websites im Allgemeinen diese SSL-Versionen verwenden, wurde SSL jetzt von den Websites aufgegeben und durch das sicherere TLS ersetzt. Wir müssen jedoch weiterhin das Wort &ldquo;ssl&rdquo; im erläuternden Teil und beim Bearbeiten der Konfigurationsdateien verwenden. Um Ihnen das mit ein wenig Humor zu sagen, haben Sie jemals darüber nachgedacht, warum, wenn Sie die 64-Bit-Version einer Anwendung herunterladen möchten, warum sie &ldquo;amd_64&rdquo; heißt? Da AMD als erster auf 64 Bit umgestiegen ist, blieb diese Namensgebung als Zeichen des Respekts und/oder der Gewohnheit bei amd_64. Auch wenn wir derzeit TLS verwenden, bleiben die Benennungs- und Konfigurationsparameter „SSL“.</p>
<p>Wie in unserem vorherigen Artikel werde ich den Prozess noch einmal unter drei verschiedenen Überschriften als einfach, empfohlen und fortgeschritten erklären. Titelinhalte werden sukzessive nach persönlichen Anforderungen berücksichtigt. Obwohl die Titel miteinander verknüpft sind, ist es kein Problem, sie in einem gewünschten Stadium zu belassen.</p>
<h2 id="einfache-konfiguration">Einfache Konfiguration</h2>
<p>Zuerst müssen wir die Updates über die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des nginx/Apache-Dienstes (das ist der Dienst, der es Ihnen ermöglicht, externe Webverbindungen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Die Datei, in der die Nginx-Diensteinstellungen gespeichert sind, befindet sich im Allgemeinen unter „/etc/nginx/nginx.conf“. Wir müssen es mit einem der von uns verwendeten Texteditoren öffnen, jedoch mit einem Benutzer mit sudo-Rechten (dh Administratorrechten).</p>
<p>Wenn wir mit Ubuntu fortfahren (Single IP for Single Server Configuration)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/nginx/nginx.config <span style="color:#75715e"># Befehl zum Öffnen der Einstellungsdatei</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Zu ergänzende Titel (gegebenenfalls geändert)
</span></span><span style="display:flex;"><span>hören 443 ssl http2; &gt;&gt; Es dient dazu, die Anfragen zu erfüllen, die über IPv4 mit dem http2-Protokoll an Port 443 kommen, und eine SSL-Verbindung aufzubauen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hören [::]:443 ssl http2; &gt;&gt; Es dient dazu, die an Port 443 eingehenden Anfragen über IPv6 mit http2-Protokoll zu erfüllen und eine SSL-Verbindung herzustellen. (Wenn Sie keine IPv6-Unterstützung haben oder sie nicht nativ unterstützen möchten, können Sie sie entfernen.)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>server_name IHR SERVER_NAME; &gt;&gt; Wenn Sie Ihren Servernamen nicht als Standard festlegen möchten, können Sie einen Servernamensindikator angeben. Dies dient nur dazu, die an Ihren Servernamen eingehenden Anforderungen zu erfüllen, anstatt alle eingehenden Anforderungen zu erfüllen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_certificate /etc/letsencrypt/live/YOURSERVER_NAME/fullchain.pem; &gt;&gt; Wenn Sie Let&#39;s Encrypt für kostenloses SSL verwenden, ist dies der Standardspeicherort für das Zertifikat. Andernfalls ersetzen Sie es durch Ihre eigene Zertifikatsdatei.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_certificate_key /etc/letsencrypt/live/YOURSERVER_NAME/privkey.pem; &gt;&gt; Wenn Sie Let&#39;s Encrypt für kostenloses SSL verwenden, ist dies der Standardspeicherort für private Schlüssel. Ersetzen Sie es andernfalls durch Ihren eigenen Speicherort der privaten Schlüsseldatei.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_protocols TLSv1.3 TLSv1.2; &gt;&gt; Erforderlicher Befehl, um nur die neuesten und zuverlässigsten TLS-Protokolle zu akzeptieren.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_prefer_server_ciphers on; &gt;&gt; Während des Gesprächs zwischen dem Server und dem Client, schätze ich, dass sie über &#34;ok, mal sehen, was wir haben&#34; gesprochen haben. Kurz gesagt, wenn es für Sie funktioniert, wenn es für Sie nicht funktioniert, rede ich nicht.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_ecdh_curve secp521r1:secp384r1; &gt;&gt; Es ist der Befehl, der uns sagt, welche Kurven wir bevorzugen, wenn wir Ekliptikkurven verwenden müssen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_chiffren DH-RSA-AES256-SHA:DH-RSA-AES256-SHA256:DHE-RSA-AES256-GCM-SHA384:DH-RSA-AES256-GCM-SHA384:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_PODSADHESA:25_SHA256 -ECDSA-AES256 -RSA-AES256-SHA:AECDH-AES256-SHA:ECDHE-ECDSA-AES256-SHA384:ECDH-ECDSA-AES256-SHA384:ECDH-RSA-AES256-SHA384:ECDHE-ECDSA-AES256 -GCM-SHA384:ECDH-ECDSA -AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDH-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-CCM:DHE-RSA-AES256-CCM8 :ECDHE-ECDSA-AES256-CCM :ECDHE-ECDSA-AES256-CCM8:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305; &gt;&gt; Der Code, der den Server anweist, nur die SSL-Algorithmen zu verwenden, die ich am zuverlässigsten finde.
</span></span></code></pre></div><p>Alle Chiffren für diejenigen, die einzeln recherchieren wollen: &ldquo;<a href="https://testssl.sh/openssl-iana.mapping.html%22">https://testssl.sh/openssl-iana.mapping.html"</a></p>
<p>Wenn Sie nach dem Vornehmen der Einstellungen überprüfen möchten: Sie können den Befehl „sudo nginx -t“ verwenden. Wenn Sie keine Fehlermeldung sehen, können Sie die Einstellungen übernehmen und den Dienst mit dem Befehl &ldquo;sudo systemctl restart nginx&rdquo; oder &ldquo;sudo service nginx restart&rdquo; neu starten.</p>
<h2 id="empfohlene-einstellungen">Empfohlene Einstellungen</h2>
<p>Zusätzlich zu den vorherigen Einstellungen werden wir einige Leistungsverbesserungen sowie einige zusätzliche Konfigurationen vornehmen, die es Ihrer Website ermöglichen, auf SSL-Testseiten einen höheren Rang einzunehmen. Danach werden wir einige Verbesserungen vornehmen, um sicherzustellen, dass einige Header und Ressourcen Ihrer Website nicht von Websites Dritter ausgenutzt werden, was für den Benutzerzugriff Ihrer Website von Vorteil ist.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Zu ergänzende Titel (gegebenenfalls geändert)
</span></span><span style="display:flex;"><span>ssl_session_cache freigegeben:TLS:2m; &gt;&gt; Code, der angibt, wie TLS-Verbindungen auf Worker (nginx-Worker) verteilt werden und wie lange die Verbindungen geteilt werden
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_buffer_size 4k; &gt;&gt; Der Code, der angibt, in wie viele Container die Pakete aufgeteilt werden, wenn auf SSL-Anfragen geantwortet und Pakete nach dem Handshake gesendet werden. Ein niedrigerer Wert bedeutet, dass mehr Pakete gesendet werden, aber weniger Overhead.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_stapling an; &gt;&gt; Aktiviert die OCSP-Heftfunktion
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_stapling_verify an; Aktiviert die Möglichkeit, das OCSP-Heften zu überprüfen, einschließlich auf übergeordneten und Stammservern.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Resolver 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001; &gt;&gt; Aktiviert die OCSP-Stapling-Überprüfung mit Cloudlfare. Wenn Sie IPv6 nicht verwenden oder es nicht nativ unterstützen möchten, können Sie die IPv6-Adressen löschen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Content-Type-Options &#34;nosniff&#34; immer; &gt;&gt; Es ist der Header-Wert, der Browser daran hindert, MIME-Inhalte zu verstehen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Xss-Protection &#34;1; mode=block&#34; immer; &gt;&gt; Es handelt sich um einen Titel, der die Schwachstelle bis zu einem gewissen Grad verhindert, indem er Benutzern ermöglicht, einen weißen Bildschirm in einer möglichen XSS-Schwachstelle zu sehen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Frame-Optionen &#34;SAMEORIGIN&#34; immer; &gt;&gt; Es verhindert in irgendeiner Weise, dass eine Seite Ihres Servers auf einer anderen Seite angezeigt und/oder nacheinander mit einem i-Frame-Code usw. veröffentlicht wird. Nur Sie können ein Fenster von Ihrer eigenen Site innerhalb Ihrer eigenen Site veröffentlichen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Referrer-Policy &#34;no-referrer-when-downgrade&#34; immer; &gt;&gt; Wenn Sie auf eine Website mit geringeren Sicherheitsmaßnahmen umleiten oder verlinken, wird nicht automatisch ein Referrer-Header hinzugefügt und es ist nicht klar, dass der Datenverkehr von Ihrer Website kommt.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Content-Security-Policy &#34;default-src &#39;self&#39; https: data: &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;&#34; immer; &gt;&gt; Der Titel, der die Bedingungen regelt, unter denen Anfragen, die Sie und andere Benutzer von außen anrufen können, aufgerufen werden können. Standardmäßig vertraue ich einigen Quellen, die über https kommen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Berechtigungsrichtlinie &#34;Kamera=(), Vollbild=(self), Geolocation=(), Mikrofon=(), Zahlung=()&#34; immer; &gt;&gt; Es verhindert das Sammeln von Informationen auf Ihrer Website mit verschiedenen Arten von Vergiftung (Cache-Vergiftung oder js-Vergiftung), indem es angibt, welche Berechtigungen Sie für den Browser wünschen oder welche Sie überhaupt nicht benötigen.
</span></span></code></pre></div><p>Wenn Sie nach dem Vornehmen der Einstellungen überprüfen möchten: Sie können den Befehl „sudo nginx -t“ verwenden. Wenn Sie keine Fehlermeldung sehen, können Sie die Einstellungen übernehmen und den Dienst mit dem Befehl „sudo systemctl restart nginx“ oder „sudo service nginx restart“ neu starten.</p>
<h2 id="erweiterte-einstellungen">Erweiterte Einstellungen</h2>
<p>Zunächst fügen wir Ihrer Website einen Header hinzu, um anzuzeigen, dass sie nur über SSL verbunden werden soll. Auf diese Weise können diejenigen, die Ihre Website zuvor aufgerufen haben, und diejenigen, die diesen Titel bereits in ihrem Browser haben, nicht ohne SSL auf Ihre Website zugreifen, selbst wenn sie dies wünschen. Dann werden wir die SSL-Zertifikate heften, die in HTTP-Sitzungen verwendet werden sollen, und wir werden im Voraus angeben, welche Zertifikate neben der vorherigen Methode verbunden werden müssen. Selbst wenn Sie ein autorisierter Top-Zertifikatsmanager oder Root-Manager sind, können diese auf diese Weise keine Verbindung zu Ihrer Site mit dem in Ihrem Namen signierten Zertifikat herstellen. E-Tugra-Stammzertifikatanbieter mit Wohnsitz in der Türkei zu diesem Zeitpunkt unterzeichnete ein Zertifikat für *.google.com. Wenn Sie ein wenig recherchieren, werden Sie herausfinden, wann es passiert ist und warum (wie schlimm es sein könnte). Beginnen wir nun mit dem letzten Konfigurationsteil.</p>
<p>Stellen Sie zunächst sicher, dass Ihre Website problemlos über SSL aufgerufen werden kann. Fügen Sie dann gemäß Ihrer Anfrage einen der folgenden Header zur nginx-Konfigurationsdatei hinzu. Aber Achtung, nur einer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=2592000;&#34; immer; &gt;&gt; Header, der besagt, dass auf Ihre Website 30 Tage lang nur über HTTPS zugegriffen werden kann. (ohne Subdomains)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=2592000; includeSubDomains;&#34; immer; &gt;&gt; Header, der besagt, dass Ihre Website 30 Tage lang nur über HTTPS aufgerufen werden kann, einschließlich Subdomains.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains;&#34; immer; &gt;&gt; Header, der besagt, dass auf Ihre Website 1 Jahr lang nur über HTTPS zugegriffen werden kann, einschließlich Subdomains.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains; preload&#34; immer; &gt;&gt; Der Header, der angibt, dass auf Ihre Website 1 Jahr lang nur über HTTPS zugegriffen werden kann, einschließlich Subdomains, und dass dieser Header von Browsern zwischengespeichert wird. Darüber hinaus werden neue Browser diesen Titel erkennen, auch wenn sie Ihre Website noch nie zuvor besucht haben.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=0; includeSubDomains&#34;; &gt;&gt; Titel für das vollständige Entfernen der HSTS-Funktion und der Mitgliedschaft in der Preload-Liste.
</span></span></code></pre></div><p>Nachdem Sie den oben erwähnten Header hinzugefügt haben, ist es jetzt an der Zeit, den Hash des verwendeten SSL-Zertifikats an die HTTP-Sitzung anzuheften. In diesem Stadium müssen wir einen Hash Ihres aktuellen Zertifikats extrahieren, das Zertifikat der obersten Unterzeichnungsstelle hashen und diesen Hash-Prozess fortsetzen, bis wir die gesamte Kette einschließlich der obersten Stammzertifizierungsstelle abgeschlossen haben. Aus diesem Grund führen wir die folgenden Befehle jeweils mit einem Root-Benutzer oder einem Benutzer mit sudo-Berechtigung aus. (Der Vortrag wurde speziell für Let&rsquo;s Encrypt gemacht.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1<span style="color:#f92672">]</span> cat /etc/letsencrypt/live/IHR SERVERNAME/cert.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binär | base64 &gt;&gt; Dieser Befehl extrahiert den Hash des Zertifikats Ihrer Website. Kopieren Sie den Ergebniswert irgendwo hin.
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">]</span> curl -s https://letsencrypt.org/certs/lets-encrypt-x4-cross-signed.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binär | base64 &gt;&gt; Dieser Befehl extrahiert eines der mehrfach signierten Zertifikate von letsencrypt.
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">]</span> curl -s https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binär | base64 &gt;&gt; Dieser Befehl extrahiert eines der mehrfach signierten Zertifikate von letsencrypt.
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">]</span> curl -s https://letsencrypt.org/certs/isrgrootx1.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binär | base64 &gt;&gt; Dieser Befehl extrahiert das Stammzertifikat <span style="color:#f92672">(</span>oberstes Zertifikat<span style="color:#f92672">)</span> von letsencrypt.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Der folgende Wert wird der Nginx-Konfigurationsdatei hinzugefügt
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">]</span> add_header Public-Key-Pins <span style="color:#e6db74">&#39;pin-sha256=&#34;ERSTE_ERGEBNIS&#34;; Pin-sha256 = &#34;ZWEITES_ERGEBNIS&#34;; pin-sha256=&#34;TIP_END&#34;; pin-sha256=&#34;FINISH_RESULT&#34;; Maximalalter = 2592000; includeSubDomains&#39;</span> immer; &gt;&gt; Sie können sich nur mit dem angegebenen Zertifikat <span style="color:#ae81ff">30</span> Tage lang mit Ihrer Website verbinden. Sie können den max-age-Wert optional erhöhen. Bevor die Gültigkeitsdauer Ihres Zertifikats weniger als <span style="color:#ae81ff">30</span> Tage beträgt, müssen Sie die Kopfzeile deaktivieren oder ein neues Zertifikat anfordern und es als fünften Wert hinzufügen.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Als Bonus möchte ich Ihnen einen weiteren Befehl zeigen, dessen Ausführung lange dauert, aber sehr nützlich ist.
</span></span><span style="display:flex;"><span>6<span style="color:#f92672">]</span> openssl dhparam -out /etc/nginx/dhparams.pem <span style="color:#ae81ff">4096</span> &gt;&gt; Die Ausführung dieses Befehls kann zwischen <span style="color:#ae81ff">15</span> Minuten und <span style="color:#ae81ff">1</span> Stunde dauern.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Nachdem der Vorgang abgeschlossen ist, müssen Sie den folgenden Befehl zur nginx-Konfigurationsdatei hinzufügen.
</span></span><span style="display:flex;"><span>ssl_dhparam /etc/nginx/dhparam.pem; &gt;&gt; Der Befehl zum Ändern der während des Diffie-Hellman-Schlüsselaustauschalgorithmus zu verwendenden Werte mit den gerade erstellten geheimen Werten, abgesehen von den Standardwerten.
</span></span></code></pre></div><p>Nachdem Sie die Einstellungen vorgenommen haben, übernehmen Sie die Einstellungen mit dem Befehl „sudo nginx -t“ und dann, wenn Sie keine Fehlermeldung sehen, „sudo service nginx restart“ und starten Sie den Dienst neu. Nun wird die Verbindung mit der von Ihnen festgelegten Konfiguration und Bedingungen bereitgestellt. Wenn Sie den Vorher/Nachher-Bewertungsunterschied sehen möchten, können Sie sich die Bilder unten ansehen oder Ihre eigene Website unter „<a href="https://www.ssllabs.com/ssltest/index.html%E2%80%9C">https://www.ssllabs.com/ssltest/index.html“</a> testen.</p>
<p>VOR

<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-ilk-hali-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-ilk-hali-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-ilk-hali-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>SSL Labs test</b></small></center>
</picture></p>
<p>NACH

<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-son-hali-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-son-hali-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-son-hali-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>SSL Labs test</b></small></center>
</picture></p>
<p>Wenn Sie fragen, warum die Cipher-Stärke nicht 100 % beträgt, ist es derzeit nicht möglich, 100 % zu erreichen, da „TLS_AES_128_GCM_SHA256 (0x1301)“ automatisch mit TLS 1.3 geliefert wird und hinzugefügt wird, auch wenn wir es nicht möchten. Wenn Sie denken, dass ich TLS 1.3 abschalte, dann wird es nicht kommen, dann sind Ihre Punkte leider woanders weg.</p>
<h1 id="ende">Ende</h1>
<p>Dieser Artikel wurde zuvor unter <a href="https://teknolojirehberleri.xyz">https://teknolojirehberleri.xyz</a> veröffentlicht. Um ein persönliches Portfolio zu erstellen, hatte ich das Bedürfnis, es auf meiner persönlichen Website erneut zu veröffentlichen.</p>
]]></content:encoded></item><item><title>Erhöhung der SSH-Sicherheit auf Linux-Servern</title><link>https://wiseweb-works.github.io/blog/de/post/ssh-guvenligi/</link><pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/de/post/ssh-guvenligi/</guid><description>Erhöhung der SSH-Sicherheit auf Linux-Servern Heute werde ich darüber sprechen, wie wir den SSH-Dienst, der es uns ermöglicht, eine sichere Verbindung herzustellen, wenn Sie einen Server mieten, sicherer und fern von böswilligen Anfragen von außen halten können. In erster Linie werde ich den Prozess unter drei verschiedenen Überschriften beschreiben: einfach, empfohlen und fortgeschritten. Titelinhalte werden sukzessive nach persönlichen Anforderungen berücksichtigt. Obwohl die Titel miteinander verknüpft sind, ist es kein Problem, sie in einem gewünschten Stadium zu belassen.</description><content:encoded><![CDATA[<h1 id="erhöhung-der-ssh-sicherheit-auf-linux-servern">Erhöhung der SSH-Sicherheit auf Linux-Servern</h1>
<p>Heute werde ich darüber sprechen, wie wir den SSH-Dienst, der es uns ermöglicht, eine sichere Verbindung herzustellen, wenn Sie einen Server mieten, sicherer und fern von böswilligen Anfragen von außen halten können. In erster Linie werde ich den Prozess unter drei verschiedenen Überschriften beschreiben: einfach, empfohlen und fortgeschritten. Titelinhalte werden sukzessive nach persönlichen Anforderungen berücksichtigt. Obwohl die Titel miteinander verknüpft sind, ist es kein Problem, sie in einem gewünschten Stadium zu belassen.</p>
<h2 id="einfache-sicherheitsvorkehrungen">Einfache Sicherheitsvorkehrungen</h2>
<p>Zuerst müssen wir die Updates über die Konsole mit dem Paketmanager der Linux-Version installieren, in der wir uns befinden.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch-Linux: sudo pacman -Syyu
</span></span></code></pre></div><p>Nachdem die Updates installiert sind, beginnen wir mit der Konfiguration des SSHD-Dienstes (das ist der Dienst, der es Ihnen ermöglicht, SSH-Verbindungen von außen zu empfangen) auf Ihrem Server (in meinem Fall Ubuntu). Vor allem sei aufgrund der Verwirrung angemerkt, dass es sich bei dem ssh-Dienst und dem SSHD-Dienst um unterschiedliche Dienste handelt. Während der SSH-Dienst der Dienst ist, der den Server mit anderen Computern oder Servern verbindet, ist der SSHD-Dienst der Dienst, der es anderen Computern ermöglicht, sich mit Ihrem Server zu verbinden, d. h. eingehende Verbindungen.</p>
<p>Die Datei, die die Einstellungen des SSHD-Dienstes enthält, befindet sich im Allgemeinen unter „/etc/ssh/sshd_config“. Wir müssen es mit einem der von uns verwendeten Texteditoren öffnen, jedoch mit einem Benutzer mit sudo-Rechten (dh Administratorrechten).</p>
<p>Wenn wir weitermachen, Ubuntu</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config <span style="color:#75715e"># Befehl zum Öffnen der Einstellungsdatei</span>
</span></span></code></pre></div><p>Titel werden wir finden und ersetzen</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#ClientAliveInterval 0 &gt;&gt; Wir entfernen den Hashtag am Anfang und ändern den Wert von „0“ auf 300. Dieser Befehl regelt das automatische Schließen der Verbindung nach wie vielen Sekunden, wenn die Verbindung nicht genutzt wird (sie bleibt im Ruhezustand) .
</span></span><span style="display:flex;"><span>#PermitEmptyPasswords nein &gt;&gt; Wir entfernen das Hashtag am Anfang und ändern den &#34;nein&#34;-Wert nicht. Dieser Befehl verhindert, dass leere oder unverschlüsselte Benutzer eine Verbindung herstellen. Es erlaubt also keine leeren Passwörter.
</span></span><span style="display:flex;"><span>X11Forwarding yes &gt;&gt; Wenn am Anfang ein Hashtag steht, entfernen wir es, andernfalls ändern wir den „yes“-Wert auf no. Obwohl dieser Befehl das Ausführen von Anwendungen mit GUI-Schnittstelle auf dem Server erleichtert, schließen wir ihn, da er missbraucht werden kann.
</span></span><span style="display:flex;"><span>#MaxAuthTries 6 &gt;&gt; Wir entfernen den Hashtag am Anfang und ändern den Wert von „6“ auf 3. Dieser Befehl regelt, wie oft sie Ihr Passwort versuchen dürfen. Die Zahl 6 ist ein unnötig hoher Wert und die allgemeine Akzeptanz liegt bei 3 oder 4.
</span></span><span style="display:flex;"><span>#Protokol 2 &gt;&gt; Wenn am Anfang ein Hashtag steht, entfernen wir es, wenn es keinen solchen Eintrag gibt, fügen wir den Wert in Form von „Protokol 2“ an das erste Leerzeichen an, das wir finden. Dieser Befehl stellt sicher, dass Verbindungen nur mit dem neuesten SSH-Protokoll hergestellt werden, und schützt Sie so vor Schwachstellen des alten Protokolls.
</span></span></code></pre></div><p>Wenn Sie nach dem Vornehmen der Einstellungen überprüfen möchten: Sie können den Befehl „sudo sshd -t“ verwenden. Wenn Sie keine Fehlermeldung sehen, können Sie die Einstellungen übernehmen und den Dienst mit dem Befehl &ldquo;sudo systemctl restart sshd&rdquo; oder &ldquo;sudo service sshd restart&rdquo; neu starten.</p>
<h2 id="empfohlene-einstellungen">Empfohlene Einstellungen</h2>
<p>Zusätzlich zu den vorherigen Einstellungen werden wir zusätzliche Einstellungen vornehmen, wie z. B. benutzerbasierte Anmeldung, Anmeldung nur mit sicherem Schlüssel und Einschränkung der Anmeldung mit Root-Benutzer. Zuerst müssen Sie einen geheimen Schlüssel für Ihren Benutzer auf Ihrem lokalen Computer generieren. Dazu, wenn Sie ein Linux-basiertes Betriebssystem verwenden</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Nachdem Sie ssh-keygen -t rsa -b 4096 # eingegeben haben, geben Sie das gewünschte Passwort als Antwort auf die folgenden Fragen ein
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Passphrase eingeben (leer für keine Passphrase): [Entertaste drücken]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Gleiche Passphrase erneut eingeben: [Entertaste drücken]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>oder
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssh-keygen -t ecdsa -b 521 # Erzeugt einen sichereren und schnelleren Ekliptikschlüssel. Geben Sie das gewünschte Passwort als Antwort auf die folgenden Fragen ein
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Passphrase eingeben (leer für keine Passphrase): [Entertaste drücken]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Gleiche Passphrase erneut eingeben: [Entertaste drücken]
</span></span></code></pre></div><p>Wenn Sie andere Fragen mit der Eingabetaste beantwortet und keinen bestimmten Speicherort für den Schlüssel eingegeben haben, wird Ihr Schlüsselpaar (.pub=öffentlicher Schlüssel) / privater Schlüssel ohne Erweiterung) im Ordner /home/USER_NAME/.ssh gespeichert. Sie können den folgenden Code verwenden, um den von Ihnen generierten Schlüssel auf Ihrem Server einzuführen.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ssh-copy-id -i ~/.ssh/KEY_NAME.pub Nachdem Sie USER_NAME@SERVER_IP_ADRESS # auf dem SERVER eingegeben haben, werden Sie nach dem Passwort Ihres Benutzers gefragt und wenn Sie es richtig eingeben, sehen Sie eine Bestätigungsnachricht.
</span></span></code></pre></div><p>Nachdem Sie Ihren eigenen Schlüssel generiert haben, greifen Sie nur mit dem Schlüssel auf den Server zu;
Titel werden wir finden und ersetzen</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#PasswordAuthentication no &gt;&gt; Wir entfernen den Hashtag am Anfang und belassen den „no“-Wert auf no. Dieser Befehl verhindert, dass eine Verbindung zum Server mit einem Kennwort hergestellt wird. Benutzer können sich nur mit ssh_keys verbinden.
</span></span><span style="display:flex;"><span>PubkeyAuthentication yes &gt;&gt; Falls ja, entfernen wir das Rautezeichen am Anfang und setzen den Wert auf yes. Dieser Befehl ist der Befehl, mit dem Sie sich mit dem gerade erstellten geheimen Schlüssel anmelden können.
</span></span><span style="display:flex;"><span>#PermitRootLogin no &gt;&gt; Wir entfernen den Hashtag am Anfang und belassen den „no“-Wert auf no. Dieser Befehl verhindert, dass der ROOT-Benutzer, der am stärksten autorisierte Benutzer ist, auf den Server zugreift. Sie können jedoch mit einem anderen Benutzer darauf zugreifen und dann zum ROOT-Benutzer wechseln.
</span></span><span style="display:flex;"><span>AllowUsers IHR BENUTZERNAME &gt;&gt; Falls noch nicht vorhanden, fügen wir einen solchen Eintrag hinzu. Es hindert andere Benutzer daran, sich mit dem Server zu verbinden und/oder einen Benutzernamen zu versuchen.
</span></span><span style="display:flex;"><span>LoginGraceTime 20 &gt;&gt; Wenn nicht, fügen wir einen solchen Datensatz hinzu und setzen den Wert auf 20. Bestimmt die für die Anmeldung erforderliche Zeit in Sekunden. Wir verhindern, dass sie den Server mit einer langen Anmeldeanfrage beschäftigen.
</span></span><span style="display:flex;"><span>ChallengeResponseAuthentication no &gt;&gt; Falls ja, entfernen wir das Rautezeichen am Anfang und setzen den Wert auf no. Dieser Befehl deaktiviert andere Anmeldemethoden.
</span></span><span style="display:flex;"><span>KerberosAuthentication no &gt;&gt; Falls ja, entfernen wir das Rautezeichen am Anfang und setzen den Wert auf no. Dieser Befehl deaktiviert andere Anmeldemethoden.
</span></span><span style="display:flex;"><span>GSSAPIAuthentication no &gt;&gt; Falls ja, entfernen wir das Rautezeichen am Anfang und setzen den Wert auf no. Dieser Befehl deaktiviert andere Anmeldemethoden.
</span></span></code></pre></div><p>Wenn Sie nach dem Vornehmen der Einstellungen überprüfen möchten: Sie können den Befehl „sudo sshd -t“ verwenden. Wenn Sie keine Fehlermeldung sehen, können Sie die Einstellungen übernehmen und den Dienst mit dem Befehl &ldquo;sudo systemctl restart sshd&rdquo; oder &ldquo;sudo service sshd restart&rdquo; neu starten.</p>
<h2 id="erweiterte-einstellungen">Erweiterte Einstellungen</h2>
<p>Zunächst werden wir den Standard-SSH-Verbindungsport 22 ändern und dann die während der SSH-Verbindung verwendeten Verschlüsselungstools noch stärker machen. Anschließend legen wir fest, wie die Protokolle (Registrierungsdatensätze) des Server-SSH-Dienstes geführt werden.</p>
<p>Titel werden wir finden und ersetzen</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#Port 22 &gt;&gt; Wir finden das und entfernen das Rautezeichen am Anfang und schreiben dort eine Portnummer, die von keinem anderen Dienst verwendet wird und offen ist. Zum Beispiel könnte es 2992 sein.
</span></span><span style="display:flex;"><span>LogLevel INFO &gt;&gt; Wir finden diese Einstellung und ändern sie, wenn nicht, fügen wir sie hinzu. Es hilft uns, den Aufnahmepegel einzustellen.
</span></span><span style="display:flex;"><span>AllowAgentForwarding no &gt;&gt; Wir finden diese Einstellung und ändern sie, wenn nicht, fügen wir sie hinzu. Deaktiviert alternative Routing-Methoden.
</span></span><span style="display:flex;"><span>AllowTcpForwarding no &gt;&gt; Wir finden diese Einstellung und ändern sie, wenn nicht, fügen wir sie hinzu. Deaktiviert alternative Routing-Methoden.
</span></span><span style="display:flex;"><span>PrintMotd nein &gt;&gt; Wir finden diese Einstellung und ändern sie, wenn nicht, fügen wir sie hinzu. Um zu verhindern, dass sie etwas über den Server erfahren, bevor die Verbindung hergestellt wird.
</span></span><span style="display:flex;"><span>PermitUserEnvironment nein &gt;&gt; Wir finden diese Einstellung und ändern sie, wenn nicht, fügen wir sie hinzu.
</span></span><span style="display:flex;"><span>PermitTunnel no &gt;&gt; Wir finden diese Einstellung und ändern sie, wenn nicht, fügen wir sie hinzu.
</span></span></code></pre></div><p>Wir gehen noch weiter und bestimmen, welcher der Verschlüsselungsalgorithmen, Authentifizierungsalgorithmen, Schlüsselaustauschalgorithmen und anderen Algorithmen, die während der SSH-Verbindung verwendet werden, der Standard sein sollte.</p>
<p>Wir führen die folgenden Befehle jeweils mit einem Root-Benutzer oder einem Benutzer mit sudo-Berechtigung aus.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1<span style="color:#f92672">]</span> rm /etc/ssh/ssh_host_*
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">]</span> ssh-keygen -t rsa -b <span style="color:#ae81ff">4096</span> -f /etc/ssh/ssh_host_rsa_key -N <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">]</span> ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">]</span> awk <span style="color:#e6db74">&#39;$5 &gt;= 3072&#39;</span> /etc/ssh/moduli &gt; /etc/ssh/moduli.tmp
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">]</span> mv /etc/ssh/moduli.tmp /etc/ssh/moduli
</span></span><span style="display:flex;"><span>6<span style="color:#f92672">]</span> sed -i <span style="color:#e6db74">&#39;s/^\#HostKey \/etc\/ssh\/ssh_host_\(rsa\|ed25519\)_key$/HostKey \/etc\/ssh\/ssh_host_\1_key/g&#39;</span> /etc/ ssh/sshd_config
</span></span><span style="display:flex;"><span>7<span style="color:#f92672">]</span> echo -e <span style="color:#e6db74">&#34;KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256\nCiphers chacha20-poly1305@ openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\nMACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512 -etm@openssh.com,umac-128-etm@openssh.com\nHostKeyAlgorithms ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,sk-ssh-ed25519@openssh.com,sk-ssh-ed25519- cert-v01@openssh.com,rsa-sha2-256,rsa-sha2-512,rsa-sha2-256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com&#34;</span> &gt; / etc/ssh/sshd_config.d/ssh-hardening.conf
</span></span></code></pre></div><p>Nachdem Sie die Einstellungen vorgenommen haben, übernehmen Sie die Einstellungen mit dem Befehl „sudo sshd -t“ und dann, wenn Sie keine Fehlermeldung sehen, „sudo service sshd restart“ und starten Sie den Dienst neu. Jetzt können Sie sich über den gerade definierten Port und nur mit Ihrem privaten Schlüssel mit dem Server verbinden. Verbinden;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Sie können den Befehl ssh -i ~/.ssh/KEY_NAME USER_NAME@SERVER_IP_ADRESS -p PORT_NUMBER # verwenden. Sie können fortfahren, indem Sie bei den eingehenden Benachrichtigungen die Eingabetaste sagen.
</span></span></code></pre></div><h1 id="ende">Ende</h1>
<p>Dieser Artikel wurde zuvor unter <a href="https://teknolojirehberleri.xyz">https://teknolojirehberleri.xyz</a> veröffentlicht. Um ein persönliches Portfolio zu erstellen, hatte ich das Bedürfnis, es auf meiner persönlichen Website erneut zu veröffentlichen.</p>
]]></content:encoded></item></channel></rss>