<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Wise</title><link>https://wiseweb-works.github.io/blog/</link><description>Recent content on Wise</description><generator>Hugo -- 0.125.7</generator><language>tr</language><lastBuildDate>Wed, 08 May 2024 22:14:33 +0200</lastBuildDate><atom:link href="https://wiseweb-works.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Test</title><link>https://wiseweb-works.github.io/blog/post/test/</link><pubDate>Wed, 08 May 2024 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/test/</guid><description>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua.</description><content:encoded>&lt;p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted --></content:encoded></item><item><title>FFmpeg ile video çevirmek için en uygun ayarı kolayca bulmak</title><link>https://wiseweb-works.github.io/blog/post/ffmpeg-abav1/</link><pubDate>Mon, 15 Jan 2024 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/ffmpeg-abav1/</guid><description>Giriş Günümüzde video ve ses (genel olarak medya diyebiliriz) dosyalarını işlemek (kesme, yeniden boyutlandırma ve filtre uygulama) ve dönüştürmek için birçok araç bulunmaktadır. Ancak, bu araçlardan biri diğerlerinden daha çok öne çıkmakta ve belki de birçoğunun arka planında (Yusuf İpek Videosu) kullanılmaktadır. FFMPEG adlı bu araç/yazılım ücretsiz ve açık kaynaklı olup LGPL, GPL2 ve GPL3 (farklı kısım ve tarihler açısından kullanılan diğer lisanlar da mevcut) lisanları altında geliştirilmektedir.
Lisansla ilgili orjinal dilinde açıklama:</description><content:encoded><![CDATA[<h1 id="giriş">Giriş</h1>
<p>Günümüzde video ve ses (genel olarak medya diyebiliriz) dosyalarını işlemek (kesme, yeniden boyutlandırma ve filtre uygulama) ve dönüştürmek için birçok araç bulunmaktadır. Ancak, bu araçlardan biri diğerlerinden daha çok öne çıkmakta ve belki de birçoğunun arka planında (<a href="https://www.youtube.com/watch?v=clrVhDx_A-s">Yusuf İpek Videosu</a>) kullanılmaktadır. FFMPEG adlı bu araç/yazılım ücretsiz ve <a href="https://github.com/FFmpeg/FFmpeg">açık kaynaklı</a> olup LGPL, GPL2 ve GPL3 (farklı kısım ve tarihler açısından kullanılan diğer lisanlar da mevcut) lisanları altında geliştirilmektedir.</p>
<p>Lisansla ilgili orjinal dilinde açıklama:</p>
<blockquote>
<p>Most files in FFmpeg are under the GNU Lesser General Public License version 2.1 or later (LGPL v2.1+). Read the file COPYING.LGPLv2.1 for details. Some other files have MIT/X11/BSD-style licenses. In combination the LGPL v2.1+ applies to FFmpeg.</p>
</blockquote>
<blockquote>
<p>Some optional parts of FFmpeg are licensed under the GNU General Public License version 2 or later GPL v2+). See the file COPYING.GPLv2 for details. None of these parts are used by default, you have to explicitly pass &ndash;enable-gpl to configure to activate them. In this case, FFmpeg&rsquo;s license changes to GPL v2+.</p>
</blockquote>
<p>Bu rehberde sizlerle birlikte FFMPEG yazılımın kullanımından ve kendimiz için en uygun/optimize ayarı;</p>
<ol>
<li>Hız,</li>
<li>Dosya Boyutu,</li>
<li>Görüntü Kalitesi ve</li>
<li>(Opsiyonel) Uyumluluk</li>
</ol>
<p>başlıklarını da dikkate alarak nasıl bulabileceğimizi anlatacağım.</p>
<h2 id="teknik-açıklama-kısmı">Teknik açıklama kısmı</h2>
<p>Sürecin tamamına hakim olmak veya arka planında neler olduğunu anlamak isteyenler için işin teknik kısmını açıklayarak başlayacağım. Bu kısmı isterseniz atlayıp direk yandan &ldquo;AB-AV1 Yazılımı&rdquo; ile ilgili başlığa tıklayabilirsiniz.</p>
<h3 id="videoses-codecleri-nelerdir">Video/Ses Codecleri Nelerdir?</h3>
<p><a href="https://ffmpeg.org/ffmpeg-codecs.html">Video/Ses codecleri</a> video ve ses dosyalarını sıkıştırmak ve/veya yeniden kodlamak için kullanılan algoritmalardır. Bu işlem (encode/decode) daha küçük dosya boyutları elde etmek ve iletim ile depolama sırasında bant genişliğini azaltmak için önemlidir. Eğer bir video/ses dosyasını sıkıştırmadan saklamak isteseydik ihtiyacımız olacak alan gerçekten çok fazla olurdu. Örnek olarak 1 dk&rsquo;lık 1080p 30fps bir video uncompress şekilde (<a href="https://dvsgroup.com/tools/BitRateCalculator.php">Kaynak</a>) yaklaşık 10,5 GB yer kaplamaktadır. Bu miktar 4K 10 bit HDR dünyasına giriş yaptığımızda 1 dk için 55,6 GB gibi aşırı uçuk bir rakama çıkmaktadır.</p>
<p>Bu boyutların ne kadar büyük olduğunu şu örnek ile farkedebiliriz. 4K UHD Blu-ray bir diskin içerisine bu 1dk&rsquo;lık sıkıştırılmamış video yerine 3:30 Saat civarı süren <a href="https://www.imdb.com/title/tt1302006/">The Irishman Filmini</a> farklı dillerde seslendirme, altyazı ve ekstra içeriklerle sığdırabiliyorlar.</p>
<h4 id="x264-h264-video-encoder">x264: H.264 Video Encoder</h4>
<p>x264, H.264/MPEG-4 AVC (Advanced Video Codec) standardını uygulayan bir video encoder&rsquo;dır. Bu codec, yüksek kaliteli (zamanına göre) video sağlamak için optimize edilmiştir ve geniş bir cihaz yelpazesinde desteklenir. x264 çıktığı dönem için yüksek sıkıştırma oranları sağlayarak düşük bant genişliği kullanımı yani kaliteli videolara erişmemizi mümkün kıldı. Halen daha kullandığımız birçok elektronik cihaz tarafından gerek yazılımsal gerek de donanımsal boyutta destekleniyor. Fakat günümüzün yüksek kalite ve düşük dosya boyutu isteklerine uyum sağlamakta güçlük çekmektedir. Zamanına göre yüksek sıkıştırma ve yüksek kalite verdiği düşünülen sonuçları artık bazı çevrelerce yeterli görülmemektedir.</p>
<h4 id="x265-h265hevc-video-encoder">x265: H.265/HEVC Video Encoder</h4>
<p>x265, H.265/HEVC (High-Efficiency Video Coding) standardını uygulayan ve H264&rsquo;ün ardılı olan bir video encoder&rsquo;dır. x265, x264&rsquo;e kıyasla daha iyi sıkıştırma performansı sunar. Bu, daha düşük bant genişliği kullanımı ve aynı kalitede daha küçük dosya boyutları anlamına gelir. H265&rsquo;de kendinden önce gelen video codec&rsquo;i gibi birçok cihaz tarafından yazılımsal ve bazı cihazlar tarafından donanımsal hızlandırma ile kullanılabilmektedir. Her iki codec arasındaki sıkıştırma farkı aynı kalite için yaklaşık %25 ile %50 civarında farketmektedir.</p>
<h4 id="av1-video-encoder">AV1 Video Encoder</h4>
<p>Geleceğin standartlarından biri olması beklenen AV1 özellikle yüksek verimli video sağlamak için tasarlanmıştır. x264 ve x265&rsquo;e alternatif olarak geliştirilen AV1, özellikle diğerlerinin aksine açık kaynaklı ve tescilli olmayan bir codec olarak dikkat çeker. AV1, çok daha yüksek kalitede videoyu (her zaman için ana hedef bu olmuştur) sağlaması ve çok daha düşük bant genişliği kullanımıyla bilinir. Diğer codeclerle asıl ayrıldığı nokta da zaten gerçekten çok düşük bant genişliklerinde verdiği yüksek kaliteden kaynaklıdır. Canlı yayın yapan oyuncular için çok büyük gelecek vaadetmekte ve 3,5 MBps gibi bir değerde dahi güzel bir deneyim sunabilmektedir.</p>
<h4 id="karşılaştırma-x264-x265-ve-av1">Karşılaştırma: x264, x265 ve AV1</h4>
<ul>
<li><strong>Sıkıştırma Oranları:</strong> x265 ve AV1, genellikle daha iyi sıkıştırma oranları sunar.</li>
<li><strong>Performans:</strong> x264, genellikle düşük kaynak tüketimi (CPU/GPU) ve hızlı oynatma performansı ile bilinir; ancak x265 ve AV1, yüksek performans ve daha iyi sıkıştırma sağlayabilir.</li>
<li><strong>Uyumluluk:</strong> AV1 diğerlerinin aksine henüz çok geniş bir cihaz desteğine (sıkıştırma ve oynatma açısından) ulaşamadı. En yüksek cihaz/oynatıcı uyumluluğunu arayanlar için x264 en iyi sonucu verecektir.</li>
</ul>
<h4 id="kısa-sonuç">Kısa Sonuç</h4>
<p>Her video encoder, belirli senaryolarda daha iyi performans gösterir ve seçim, kullanım amaçlarına ve gereksinimlere bağlıdır. x264, x265 ve AV1, farklı avantajlara sahip olabilir ve FFmpeg, bu encoder&rsquo;ları kullanarak geniş bir video işleme yelpazesi sunar. Ben şahsen AV1&rsquo;in henüz ev kullanıcıları özelinde kullanılabilir bir seviyede olmaması nedeniyle H265&rsquo;i tercih ediyorum. Yazının geri kalanında da bunun üzerinden anlatımıma devam edeceğim.</p>
<h3 id="preset-nedir">Preset Nedir?</h3>
<p>FFmpeg&rsquo;deki presetler, bir video veya ses dosyasını belirli bir kalite ve boyutta kodlamak için kullanılan <a href="https://x265.readthedocs.io/en/stable/presets.html">önceden tanımlanmış ayarlardır</a> Bu ayarlar, codec tarafından kullanılan bir dizi parametre grubunu (komut) içerir ve genellikle kalite ile dosya boyutu arasındaki dengeyi sağlamak için tasarlanmıştır.</p>
<p>Presetlerde daha hızlı bir kodlama süreci genellikle daha düşük kalite ile sonuçlanır, bu nedenle kullanıcılar ihtiyacına bağlı olarak farklı presetleri seçebilirler. X265 için tanımlanmış olan presetler aşağıdaki gibidir:</p>
<ol>
<li><code>ultrafast</code>: En hızlı kodlama, ancak düşük kalite.</li>
<li><code>superfast</code>: ultrafast&rsquo;ten biraz daha yavaş, daha iyi kalite.</li>
<li><code>veryfast</code>: Daha dengeli bir hız ve kalite.</li>
<li><code>faster</code>: Daha yüksek kalite, biraz daha uzun süren kodlama.</li>
<li><code>fast</code>: Standart ayar, genel kullanım için iyi bir denge.</li>
<li><code>medium</code>: Kalite ve hız arasında bir denge.</li>
<li><code>slow</code>: Daha iyi kalite, ancak daha uzun süren kodlama.</li>
<li><code>slower</code>: slow&rsquo;dan daha yüksek kalite, daha uzun süre.</li>
<li><code>veryslow</code>: En yüksek kalite, ancak en uzun kodlama süresi.</li>
<li><code>placebo</code>: Adından da anlaşılacağı üzere çok önerilen (veya dikkate alınan) bir preset değil</li>
</ol>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/1.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/1.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/1.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>X265 Encoding</b></small></center>
</picture></p>
<p>Şahsen genelde veryfast veya slow presetlerini kullanıyorum. Farklı ihtiyaçlarıma bu ikisi (genelde) en iyi cevap veriyor. Fakat girdi olarak hangi videonun dikkate alınacağı ve her video özelinde verecekleri sonuç her zaman için aynı olmayabiliyor. Bknz: <a href="https://www.youtube.com/watch?v=mntswiXuvfI">Anime videolarının sıkıştırılmasındaki problemler</a></p>
<h3 id="crfvbr-ve-cbr-nedir">CRF/VBR ve CBR Nedir?</h3>
<p><strong>CRF (Constant Rate Factor)</strong>, bir video dosyasının kalitesini kontrol etmek için kullanılan bir parametredir. Bu yöntemde, belirli bir hedef kalite seviyesine ulaşılması için codec, bitrate&rsquo;i otomatik olarak ayarlar. Yani, kullanıcı belirli bir bitrate&rsquo;i elle belirtmez, sadece kalite seviyesini seçer. Daha düşük bir CRF değeri, daha yüksek bir kalite anlamına gelir, ancak dosya boyutu artar.</p>
<p><strong>CBR (Constant Bitrate)</strong>, videonun belirli bir sabit bitrate ile kodlanmasını sağlar. Bu, dosya boyutunu önceden belirlemenizi sağlar, ancak kalite değişkenlik gösterebilir. CBR, özellikle belirli bir bant genişliği sınırlaması varsa veya bir iletim ortamı belirli bir bitrate&rsquo;i destekliyorsa kullanışlıdır. Her saniye için harcanacak değer belirli olduğundan hareketli ve sabit sahneler arasında belirgin bir kalite farkı oluşacaktır. Bunu kendinize daha önce &ldquo;Neden konfeti atıldığında videonun kalitesi bozuluyor?&rdquo; diyerek sormuş olabilirsiniz. Eğer sormadıysanız da <a href="https://www.youtube.com/watch?v=r6Rp-uo6HmI">Tom Scott&rsquo;un</a> bununla ilgili eğitici bir videosu bulunuyor.</p>
<p><strong>VBR (Variable Bitrate)</strong>, videonun her bir çerçevesi için farklı bit oranlarını kullanarak kodlanmasını sağlar. Bu, sahnede daha fazla ayrıntı olduğunda daha yüksek bir bitrate sağlayarak kaliteyi artırabilir. Ancak, dosya boyutu daha değişken olacaktır. Bu ayar aslında CRF ile aynı olarak düşünülebilir. Fakat farklı mecralarda ayrı ayrı ve bazen de birlikte anılmaları nedeniyle ekstradan açıklama gereği duydum.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>CRF-VMAF</b></small></center>
</picture></p>
<p>Şahsi olarak bazen 22 bazen de 24 olan CRF değerini kullanıyorum. Eğer biraz daha hızlı bir şekilde sonuçlandırmak istiyorsam 26 veya 28&rsquo;i de kullanabiliyorum. CRF değerleri 1-1 artmamaktadır. İsterseniz 22,03 gibi bir ayar dahi kullanabilirsiniz. Ama bu derece ince ayarın pek mantığı olmayacaktır. Genel kullanımda 2&rsquo;şer adım farklarla değişiklikler yapılmaktadır.</p>
<h3 id="profil-türü-ve-seviyeleri-nelerdir">Profil Türü ve Seviyeleri Nelerdir?</h3>
<p>Video kodlamada profil, bir codec&rsquo;in belirli bir uygulama senaryosu (film, video, animasyon ve resim gösterisi :smiley: ) için optimize edilmiş ayarları içeren bir grup parametreyi tanımlar. Her profil, belirli bir kullanım durumu veya cihaz için uygun olan farklı sıkıştırma ve kalite ayarlarına sahiptir.</p>
<p>Profile seviyeleri ise bir codec tarafından desteklenen en yüksek çözünürlük, en yüksek bit hızı ve diğer teknik özellikleri belirleyen bir dizi sınırlamadır. Belirli bir seviye, belirli bir profil ile birleşerek bir codec&rsquo;in kapasitesini tanımlar.</p>
<p>x265 için öntanımlı profiller olarak <code>auto, main, main10, main448, main448-intra, high</code> ve <code>mainstillpicture</code> gibi profilleri sayılabilir. Her profil, belirli bir uygulama senaryosuna yönelik optimize edilmiş ayarlar içerir. Bunlarla ilgili ayrıntılı teknik bilgi için <a href="https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding_tiers_and_levels">Wiki sayfasına</a> göz atabilirsiniz. Ben aksine bir gereklilik olmadıkça main profili ve 5.1 seviyesini kullanıyorum.</p>
<h3 id="vmaf-nedir-ve-neden-kullanıyoruz">VMAF Nedir ve Neden Kullanıyoruz?</h3>
<p>VMAF, Netflix tarafından <a href="https://github.com/Netflix/vmaf">geliştirilen</a> ve 2014 yılında ortaya çıkan bir video kalite metriğidir. Bu metrik, izleyici deneyimini daha iyi anlamak ve video içeriğinin kalitesini değerlendirmek için tasarlanmıştır. Eğer Netflix&rsquo;in güzel içeriklerinin yüksek görüntü kalitesine aşina iseniz ve bu sizi tatmin ediyorsa o zaman görüntü kalitesi ölçütü olarak VMAF&rsquo;ya da güvenebilirsiniz.</p>
<p>FFmpeg ise bu metriği kullanarak video kodlama ayarlarını optimize etme konusunda bize yardımcı olur. Belirli bir kalite aşıldıktan sonra insan gözüyle daha iyi/kötü ayrımı yapmamız veya bunu saatlerce süren bir video özelinde aynı özenle devam ettirmemiz mümkün değil. Rehberin önceki kısımlarında paylaştığım sıkıştırma teknolojileri yanlış veya bilinçsiz kullanımda izleyici deneyimini önemli ölçüde etkilemektedir. Bu bağlamda, Video Multimodal Assessment Fusion (VMAF) gibi teknolojiler (SSIM veya PSNR), video kalitesini artırmak ve daha verimli bir sıkıştırmayı tercih etmemiz konusunda bize yardımcı olmaktadır. Kaldı ki her zaman için daha yüksek dosya boyutu daha çok kalite anlamına gelmeyecektir. Bu nedenle kalitenin matematiksel ölçümünde VMAF ölçütünü kullanıyoruz.</p>
<p>VMAF değeri 0-100 aralığında bir değer olup orjinal video ile dönüştürülmüş (kendileri bozulmuş da der aslında) video arasındaki benzerliği göstermektedir. 90 ve üzeri bir değeri neredeyse aynı kalite (bizi rahatsız etmeyecek kadar) olarak kabul etmemiz mümkün iken 95 ve üstünü artık en dikaktli gözlerin dahi farkedemeyeceği şekilde aynı olarak düşünebiliriz.</p>
<p>Şahsi olarak min 90 değerini tutturabildiğim zaman video çevirimini başarılı olarak değerlendiriyorum.</p>
<h2 id="otomatikleştirilmiş-hali-ab-av1-yazılımı">Otomatikleştirilmiş hali: AB-AV1 yazılımı</h2>
<p>AB-AV1 gönüllüler tarafından MIT lisansı altında geliştirilen ve <a href="https://github.com/alexheretic/ab-av1">açık kaynaklı</a> bir yazılımdır. Yazılımın odaklandığı ve çözmek istediği sorun video dönüştürürken ve ffmpeg yazılımını kullanırken teknik bilgilerle çok boğuşmadan istediğimiz sonuca bizi ulaştıracak değer veya değerleri hızlı bir şekilde elde etmektir. Yazılım rehberin paylaşıldığı tarih itibariyle şu yöntemi izlemektedir. Öncelik her 12 dk&rsquo;lık video kısmı için bir örnek kısım alıyor. Bu örnek kısım/lar video çok kısa olmadığı sürece 20&rsquo;şer sn&rsquo;ye kadar çıkabilmektedir. Sonrasında bu örnek videoları farklı CRF ve Preset değerleri ile kombine edip ortaya çıkan sonuçların VMAF değerlerini de hesaplıyor. Bunu yaparken de kaba kuvvet saldırısı yapar gibi 1 den başlayıp 50 ye doğru gitmiyor. Her iki ayar içinde ortadan başlayıp (CRF 25, preset medium gibi) uçlara doğru giden bir yol izliyor. Eğer istenilen şartlara uyan 4-5 adet sonuç bulur ise aramayı durduruyor bu da çok hızlı bir şekilde sonuca ulaşmamızı sağlıyor.</p>
<p>Bu yazılımı bulmadan önce kendim tüm 20-30 arasındaki tüm CRF değerleri ve tüm presetler için topluca komut çalıştırıp sonra gene elle hepsinin VMAF değerlerine bakıyor, bir excel tablosu yapıyordum. Bu da gerçekten çok uzun süren ve teknik bilgi olmadan yapılması kolay olmayan bir yola götürüyordu beni. İlgili eski çalışmalarımdan birkaç ekran görüntüsünü sizlerle paylaşmak istiyorum ki ne büyük bir dertten kurtulduğum daha ne anlaşılsın.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/3.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>1</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/ffmpeg-abav1/4.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>2</b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<p>İki adet test videosu ile yapmış olduğum bu testler yaklaşık 1 gün sürmüştü. Ben cihazı kullanırken arka planda sistem de bu testleri yapıyordu.</p>
<h3 id="yazılımın-indirilmesi-veveya-kurulması">Yazılımın indirilmesi ve/veya kurulması</h3>
<p>Yazılım Linux ve Windows işletim sistemlerini desteklemektedir. Windows için exe uzantılı dosyayı indirip kullanabilirsiniz. Arch Linux kullanıyorsanız <a href="https://aur.archlinux.org/packages/ab-av1">Aur&rsquo;da</a> paketi mevcut. Diğer linux dağıtımı kullanıcıları ise binary dosyası olarak indirebilir veya kendisi derleyebilir. Yükleme ile ilgili <a href="https://github.com/alexheretic/ab-av1?tab=readme-ov-file#install">talimatlara</a> Github sayfasından ulaşabilirsiniz.</p>
<h3 id="yazılımın-ayarları">Yazılımın ayarları</h3>
<p>Yazılımı kurduktan sonra <code>ab-av1 -h</code> komutu ile yardım kısmına veya ayrıntılı bilgiye ulaşabilirsiniz. Sizi yaklaşık olarak şöyle bir ekran karşılayacaktır.</p>
<pre tabindex="0"><code>AV1 encoding with fast VMAF sampling

Usage: ab-av1 &lt;COMMAND&gt;

Commands:
  sample-encode      Encode &amp; analyse input samples to predict how a full encode would go.
                         This is much quicker than a full encode/vmaf run.
  vmaf               Full VMAF score calculation, distorted file vs reference file.
                         Works with videos and images.
  encode             Invoke ffmpeg to encode a video or image
  crf-search         Interpolated binary search using sample-encode to find the best crf
                         value delivering min-vmaf &amp; max-encoded-percent.
  auto-encode        Automatically determine the best crf to deliver the min-vmaf and use it to encode a video
                         or image.
  print-completions  Print shell completions
  help               Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version
</code></pre><p>En basit kullanım senaryosu olarak aşağıdaki gibi yapabilirsiniz:</p>
<pre tabindex="0"><code>ab-av1 crf-search --encoder libx265 -i dosyanız.uzantısı
</code></pre><p>bu şekilde yazılımın öntanımlı olarak dikkate aldığı değer aralıklarında ve x265 için uygun olacak sonuçları size verecektir. Biraz ince ayar yapmak isterseniz eğer istediğiniz kalite miktarını VMAF değeri olarak aşağıdaki gibi belirtebilirsiniz:</p>
<pre tabindex="0"><code>ab-av1 crf-search --encoder libx265 --min-vmaf 95 -i dosyanız.uzantısı (veya 90 artık size kalmış)
</code></pre><p>Ben nasıl kullanıyorum diye soracak olursanız eğer:</p>
<pre tabindex="0"><code>ab-av1 crf-search --encoder libx265 --min-vmaf 90 --min-crf 20 --max-crf 30 --crf-increment 2 --preset veryfast --enc x265-params=level=5.1:high-tier=1 -i dosyanız.uzantısı
</code></pre><p>Örnek olarak çok bilinen bir video olan <a href="https://mango.blender.org/download/">Tears of Steel</a> üzerinde bir deneme yapmak gerekirse eğer:</p>
<pre tabindex="0"><code>- crf 25 VMAF 94.40 (33%) (cache)
- crf 27 VMAF 92.30 (26%) (cache)
- crf 30 VMAF 87.55 (17%) (cache)
- crf 28 VMAF 90.94 (22%) (cache)
- crf 29 VMAF 89.36 (20%) (cache)
00:00:00 ################################################(sampling crf 29, eta 0s)
Encode with: ab-av1 encode -e libx265 -i tears_of_steel_1080p.mov --crf 28 --preset veryfast --enc x265-params=level=5.1:high-tier=1

crf 28 VMAF 90.94 predicted video stream size 124.37 MiB (22%) taking 18 minutes
</code></pre><p>çıktısını verecektir. Ben daha önce denemek için kullandığımdan bende cache&rsquo;den verileri hemen getirdi.</p>
<p>Bize önerdiği ayar <strong>CRF: 28 Preset: Veryfast</strong> şeklinde olup tahmini olarak çevirinin 18 dk süreceğini ve sonuç dosya boyutunun %22&rsquo;si kadar olacağını (neredeyse 5&rsquo;te bir) öngörüyor. Özellikle öngörüyor dememim sebebi videonun tamamı özelinde bir kontrol değil de aldığı örnekler özelinde bir tahmin yürütttüğü için ufak da olsa bir hata payı mümkün. Bu bilgileri aldıktan sonra ister ffmpeg üzerinden siz ilgili komutları yazıp çeviriye başlayabilirsiniz ister de size verdiği ve <code>Encode with: ab-av1 ....</code> diye başlayan komutu direk yapıştırarak aynı araç içerisinden çeviriyi de yapabilirsiniz. Yani size komutu dahi veriyor :D</p>
<h3 id="gerçek-dünya-testleri">Gerçek dünya testleri</h3>
<p>Evdeki hesap her zaman pazara uymadığı için ve bunca yazının da gerçekten işe yarayıp yaramadığından emin olmak için test etmek iyi olacaktır. Videonun &ldquo;Full Movie – First version (HD rendered) - HD 1080p (mov)&rdquo; olan versiyonunu indirdim. İlgili video 12dk 14sn uzunluğunda ve 557M (583774083) boyutunda olup çeviri işlemi ffmpeg ile yapıldığında aşağıdaki:</p>
<pre tabindex="0"><code>x265 [info]: HEVC encoder version 3.5
x265 [info]: build info [Linux][GCC 11.2.0][64 bit] 8bit+10bit+12bit
x265 [info]: using cpu capabilities: MMX2 SSE2Fast LZCNT SSSE3 SSE4.2 AVX FMA3 BMI2 AVX2
x265 [warning]: Specifying a decoder level with constant rate factor rate-control requires
x265 [warning]: enabling VBV with vbv-bufsize=160000kb vbv-maxrate=160000kbps. VBV outputs are non-deterministic!
x265 [info]: Main profile, Level-5.1 (High tier)
x265 [info]: Thread pool created using 4 threads
x265 [info]: Slices                              : 1
x265 [info]: frame threads / pool features       : 2 / wpp(13 rows)
x265 [info]: Coding QT: max CU size, min CU size : 64 / 8
x265 [info]: Residual QT: max TU size, max depth : 32 / 1 inter / 1 intra
x265 [info]: ME / range / subpel / merge         : hex / 57 / 1 / 2
x265 [info]: Keyframe min / max / scenecut / bias  : 24 / 250 / 40 / 5.00 
x265 [info]: Lookahead / bframes / badapt        : 15 / 4 / 0
x265 [info]: b-pyramid / weightp / weightb       : 1 / 1 / 0
x265 [info]: References / ref-limit  cu / depth  : 2 / on / on
x265 [info]: AQ: mode / str / qg-size / cu-tree  : 2 / 1.0 / 32 / 1
x265 [info]: Rate Control / qCompress            : CRF-28.0 / 0.60
x265 [info]: VBV/HRD buffer / max-rate / init    : 160000 / 160000 / 0.900
x265 [info]: tools: rd=2 psy-rd=2.00 early-skip rskip mode=1 signhide tmvp
x265 [info]: tools: fast-intra strong-intra-smoothing lslices=5 deblock sao
frame=17620 fps= 22 q=32.8 Lsize=  124521kB time=00:12:14.07 bitrate=1389.6kbits/s speed=0.909x    
x265 [info]: frame I:    172, Avg QP:26.60  kb/s: 9754.63 
x265 [info]: frame P:   3528, Avg QP:28.30  kb/s: 3513.82 
x265 [info]: frame B:  13920, Avg QP:34.37  kb/s: 577.41  
x265 [info]: Weighted P-Frames: Y:4.1% UV:2.5%
x265 [info]: consecutive B-frames: 4.8% 0.6% 0.8% 1.0% 92.8% 

encoded 17620 frames in **807.69s (21.82 fps)**, 1254.95 kb/s, Avg QP:33.08
</code></pre><p>çıktıyı verdi ve neticeten benim cihazımda (CPU i5-7300U) yaklaşık (807sn) 13,5 dk sürdü. Sonuç dosya boyutu ise 122 M (127509197) oldu. Ardından FFMPEG ile bu sefer de VMAF değerini hesaplatmak ve tüm sonuçları bir araya getirip değerlendirmek istedim. VMAF değerini hesaplamak için aşağıdaki komutu kullandım.</p>
<pre tabindex="0"><code>ffmpeg -i output.mkv -i tears_of_steel_1080p.mov -lavfi libvmaf -f null –
</code></pre><p>ve bana sonuç olarak aşağıdaki çıktıyı verdi:</p>
<pre tabindex="0"><code>[out#0/null @ 0x558d1bc41180] video:8259kB audio:126464kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: unknown
frame=17620 fps= 12 q=-0.0 Lsize=N/A time=00:12:14.16 bitrate=N/A speed=0.492x    
[Parsed_libvmaf_0 @ 0x558d1a9b2880] **VMAF score: 91.112250**
</code></pre><table>
<thead>
<tr>
<th>#</th>
<th>Orjinal Dosya</th>
<th>AB-AV1 in Vaadi</th>
<th>Gerçek Dünya Testi</th>
<th>Fark</th>
</tr>
</thead>
<tbody>
<tr>
<td>VMAF</td>
<td>% 100</td>
<td>% 90,94</td>
<td>% 91.11</td>
<td>%+ 0,17</td>
</tr>
<tr>
<td>Dosya Boyutu</td>
<td>557 MB</td>
<td>124,37 MB (%22)</td>
<td>122 MB (%21.84)</td>
<td>2,4 MB %-1,94</td>
</tr>
<tr>
<td>Uzunluk/Çevirirken geçen süre</td>
<td>12dk 14sn</td>
<td>18 dk</td>
<td>13dk  27 sn</td>
<td>4 dk 33 sn %-25,28</td>
</tr>
</tbody>
</table>
<p>Sonuç olarak hepsini bir araya getirdiğimizde gerçekten iç açıcı ve vaat edilenden daha iyi sonuçlar elde etmiş olduk. Bütün bu süreçler devam ederken PC&rsquo;yi kullanmaya ve bu yazıyı yazmaya devam ettiğim de düşünülürse çok güzel sonuçlar verdiğini söyleyebiliriz.</p>
<h2 id="anlatım-dışı-bırakılan-kısımlar">Anlatım dışı bırakılan kısımlar</h2>
<p>Bu rehberde ses dosyalarının yeniden sıkıştırılması veya dönüştürülmesi konusuna hiç girmedim. Eğer böyle bir istek gelir ise bu kısma ekleme yapabilirim. Fakat 192 kb/s gibi bir bitrate bile kullansanız sonuç dosyayı çok farkettirmeyeceği için bu nedenle dikkate almadım. Odyofil olarak da adlandırılan kişilerden biri iseniz ve 5.1 veya 7.1 bir ses sistemine sahipseniz eğer işte o zaman bu kısım bir anlam ifade edebilir. Onun haricinde ses dosyalarını direk olduğu gibi alabilirsiniz ki ek bir ayar yapmazsanız zaten böyle olmaktadır.</p>
<h1 id="son-söz-ve-kaynakça">Son Söz ve Kaynakça</h1>
<p>Artık siz de profesyoneller gibi neredeyse hiç kalite kaybı yaşamadan videolarınızı sıkıştırabilir ve alandan tasarruf edebilirsiniz. Elinizdeki Blu-ray ve UltraHD Blu-ray&rsquo;leri daha az yer kaplayacak şekilde hard diskinize kaydetmek veya Plex gibi bir ev sinema sistemi kurmak istiyorsanız artık bunu gönül rahatlığı ile yapabilirsiniz. Bir sonraki rehbere kadar iyi seyirler ve esenlikler dileğiyle.</p>
<p>Kaynaklar:</p>
<ul>
<li><a href="https://github.com/FFmpeg/FFmpeg">https://github.com/FFmpeg/FFmpeg</a></li>
<li><a href="https://ffmpeg.org/ffmpeg-codecs.html">https://ffmpeg.org/ffmpeg-codecs.html</a></li>
<li><a href="https://dvsgroup.com/tools/BitRateCalculator.php">https://dvsgroup.com/tools/BitRateCalculator.php</a></li>
<li><a href="https://www.imdb.com/title/tt1302006/">https://www.imdb.com/title/tt1302006/</a></li>
<li><a href="https://x265.readthedocs.io/en/stable/presets.html">https://x265.readthedocs.io/en/stable/presets.html</a></li>
<li><a href="https://streaminglearningcenter.com">https://streaminglearningcenter.com</a> (Grafik)</li>
<li><a href="https://goughlui.com">https://goughlui.com</a> (Grafik)</li>
<li><a href="https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding_tiers_and_levels">https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding_tiers_and_levels</a></li>
<li><a href="https://github.com/Netflix/vmaf">https://github.com/Netflix/vmaf</a></li>
<li><a href="https://github.com/alexheretic/ab-av1">https://github.com/alexheretic/ab-av1</a></li>
<li><a href="https://aur.archlinux.org/packages/ab-av1">https://aur.archlinux.org/packages/ab-av1</a></li>
<li><a href="https://github.com/alexheretic/ab-av1">https://github.com/alexheretic/ab-av1</a></li>
<li><a href="https://mango.blender.org/">https://mango.blender.org/</a></li>
<li><a href="https://ottverse.com/analysis-of-svt-av1-presets-and-crf-values/">https://ottverse.com/analysis-of-svt-av1-presets-and-crf-values/</a></li>
<li><a href="https://superuser.com/questions/1556953/why-does-preset-veryfast-in-ffmpeg-generate-the-most-compressed-file-compared">https://superuser.com/questions/1556953/why-does-preset-veryfast-in-ffmpeg-generate-the-most-compressed-file-compared</a></li>
<li><a href="https://codecalamity.com/encoding-uhd-4k-hdr10-videos-with-ffmpeg/">https://codecalamity.com/encoding-uhd-4k-hdr10-videos-with-ffmpeg/</a></li>
<li>İlk Yayım: <a href="https://btt.community/t/ffmpeg-ile-video-cevirmek-icin-en-uygun-ayari-kolayca-bulmak/4443">BTT</a></li>
</ul>
]]></content:encoded></item><item><title>Eski Maclere OpenCore ile Desteklenmeyen Sürümlerin Kurulumu</title><link>https://wiseweb-works.github.io/blog/post/opencore-legacy-eski-macbook/</link><pubDate>Sun, 08 Oct 2023 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/opencore-legacy-eski-macbook/</guid><description>OpenCore Legacy Mac Yama Aracı OpenCore Logosu Rehber son güncellenme: 08.10.2023 (Sonoma desteği dahil)
Bu rehber, OpenCore Legacy Patcher (bundan sonra OCLP olarak anılacaktır) programını kullanma konusunda size yol gösterecektir. Geliştirici katkıları ve kullanıcı raporlarının yanı sıra kişisel deneyimlerdeki araştırmalara dayanmaktadır. OCLP kullanılarak macOS 14 Sonoma ilginç bir şekilde 12 yıllık bir Mac&amp;rsquo;e başarıyla yüklendi. Söz konusu Mac, desteği 2017&amp;rsquo;de macOS 10.13 High Sierra ile sonlanan 2011 ortası iMac 27 inçtir.</description><content:encoded><![CDATA[<h1 id="opencore-legacy-mac-yama-aracı">OpenCore Legacy Mac Yama Aracı</h1>
<p>
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/1.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>OpenCore Logosu</b></small></center>
</picture>
<strong>Rehber son güncellenme: 08.10.2023 (Sonoma desteği dahil)</strong></p>
<p>Bu rehber, OpenCore Legacy Patcher (bundan sonra OCLP olarak anılacaktır) programını kullanma konusunda size yol gösterecektir. Geliştirici katkıları ve kullanıcı raporlarının yanı sıra kişisel deneyimlerdeki araştırmalara dayanmaktadır. OCLP kullanılarak macOS 14 Sonoma ilginç bir şekilde 12 yıllık bir Mac&rsquo;e başarıyla yüklendi. Söz konusu Mac, desteği 2017&rsquo;de macOS 10.13 High Sierra ile sonlanan <a href="https://support.apple.com/kb/SP689?locale=en_US&viewlocale=en_US">2011 ortası iMac</a> 27 inçtir.</p>
<p>
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/2.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Kaynak: macsofa.net</b></small></center>
</picture></p>
<h2 id="oclp-ne-yapabilir">OCLP ne yapabilir?</h2>
<p>OCLP 2021 yılında ilk defa geliştirilmeye başlanmış olup bu programın yardımıyla, 2006&rsquo;dan itibaren artık Apple tarafından desteklenmeyen eski Mac&rsquo;lere (an itibariyle 83 tane cihaz) Apple’ın sunduğu daha yeni işletim sistemi versiyonlarını yükleyebilirsiniz. Bunlar <a href="https://support.apple.com/tr-tr/HT211238">macOS 11 Big Sur</a>, <a href="https://support.apple.com/tr-tr/HT212551">macOS 12 Monterey</a>, <a href="https://support.apple.com/tr-tr/HT213264">macOS 13 Ventura</a>, <a href="https://www.apple.com/tr/macos/sonoma/">macOS 14 Sonoma</a> ve <a href="https://semver.org/lang/tr/">semantik sürüm numaralandırması sistemine göre</a> alt sürüm güncellemeleridir. Kural olarak, başarıyla OCLP ile yamalanmış bir sistem ile yerel olarak çalışan (yani Apple’ın resmi olarak desteklediği) bir sistem arasında herhangi bir fark görmezsiniz.</p>
<p>OCLP web sitesine <a href="https://dortania.github.io/OpenCore-Legacy-Patcher">buradan</a> ulaşabilirsiniz ve rehber süresince ihtiyacımız olan programı <a href="https://github.com/dortania/OpenCore-Legacy-Patcher">bu web sitesinden</a> ücretsiz olarak indirebilirsiniz. Yeni sistemi Mac&rsquo;inizin dahili sabit sürücüsüne veya harici bir sabit sürücüye kurabilirsiniz.</p>
<h2 id="oclp-nasıl-çalışır">OCLP nasıl çalışır?</h2>
<p>Basitçe açıklamak gerekirse, OCLP değiştirilmiş bir önyükleme bölümü oluşturur ve Mac&rsquo;i sisteme karşı simule ederek (desteklenen bir Mac&rsquo;miş gibi davranarak) sistemin başlatılmasını sağlar. OCLP kendi işletim sistemini değil, orijinal macOS&rsquo;u başlatır. Bu amaçla OCLP, macOS önyükleyicisine açık kaynaklı bir alternatif olan OpenCore önyükleyicisini kullanır. Eğer Hackintosh/Ryzentosh terimlerini daha önce duyduysanız OpenCore önyükleyicisine aşinasınızdır.</p>
<p>Bunu yapmak için OCLP, OpenCore yapılandırmasındaki belirli bileşenleri değiştirir ve karşılık gelen bir yapılandırma dosyası (OpenCore config) oluşturur. Değiştirilen bileşenler RAM&rsquo;deki bir referans dosyasında saklanır. İlgili bir config dosyası kullanılarak bu referans dosyası, Mac&rsquo;in her başlatılışında oluşturulur.</p>
<p>İlgili bileşenlere erişmek için bu referanslardan bazıları kök ayrıcalıklarına (root yetkisine) ihtiyaç duyar. Bu nedenle yazının ilerleyen safalarında belirtilen kök yaması (root patch), bileşenler veya donanım değiştiğinde referans dosyasını yeniler. Bu, gerekli bileşenlerin doğru şekilde adreslemesini ve sistemin hatasız çalışmasını sağlar.</p>
<p>Tüm bu işlemler yama yapıldıktan sonra arka planda otomatik olarak çalışır.</p>
<h2 id="oclpyi-kim-geliştirir">OCLP&rsquo;yi kim geliştirir?</h2>
<p>OCLP, Hackintosh topluluğundan bir grup özel programcı olan <a href="https://github.com/dortania">Dortania</a> tarafından geliştirilmekte ve <a href="https://khronokernel.github.io/about-me">Mykola Grymalyuk</a> yani Khronokernel tarafından yönetilmektedir.</p>
<p>Amaçları erken eskime veya <a href="https://tr.wikipedia.org/wiki/Planl%C4%B1_eskime">planlı eskitme</a> yerine eski Mac&rsquo;lerin mümkün olduğu kadar uzun süre kullanılabilmesini sağlamaktır. Yamalı yeni sistem sayesinde veri güvenliği ve programlar güncel tutulmaya devam edilebilmektedir.</p>
<p>Bu sürdürülebilirliğin yanı sıra OCLP&rsquo;nin güvenilirliği de geliştiriciler için önemlidir, bu nedenle kaynak kodu Github üzerinden kullanıcılara açıktır. Buna göre programda tespit edilecek güvenlik açıkları topluluk kullanıcıları tarafından hemen fark edilebilecek ve gerekli düzeltmeler yine kullanıcılar/proje yöneticileri tarafından yayımlanacaktır. Fakat şimdiye kadar o ölçekte büyük bir açık söz konusu olmamıştır.</p>
<p>OCLP&rsquo;nin teknolojik kökleri <a href="https://www.youtube.com/@dosdude1/videos">Collin Mistr&rsquo;a</a> dayanmaktadır. Yama aracı macOS 10.12 Sierra&rsquo;nın yüklenmesine olanak tanıyan <a href="https://dosdude1.com/software.html">dosdude1</a> adlı projesi temel alınarak geliştirildi.</p>
<h2 id="oclp-karmaşık-mı">OCLP karmaşık mı?</h2>
<p>OCLP&rsquo;yi kullanmak bu talimatlarda göründüğünden çok daha az karmaşıktır. Olası sorunları önlemek için rehberin uzun versiyonunu okumanızı öneririm. Burada açıklanan adımları takip ettiğiniz takdirde, derinlemesine teknik bilgiye sahip olmayan bir kullanıcı bile başarılı olacaktır. Daha kolay yönlendirme için kısa ve uzun versiyonların yapısı aynıdır.</p>
<h3 id="kisa-versiyon">KISA VERSİYON</h3>
<p>Aşağıdaki süreç macOS 11 Big Sur, macOS 12 Monterey ve macOS 13 Ventura sistemlerine yama uygulanması için geçerlidir. MacOS 14 Sonoma&rsquo;ya yama uygulanması uzun versiyonun IV. Bölümünde anlatılmaktadır.</p>
<h4 id="i-araştirma">I. ARAŞTIRMA</h4>
<p>Mac&rsquo;inizin OCLP ile uyumluluğunu <a href="https://dortania.github.io/OpenCore-Legacy-Patcher/MODELS.html">buradan</a> kontrol edin. Ayrıca oradaki cihaz listesinin yorum sütununda yer alan kısıtlamalara ve önerilere de dikkat edin.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/3.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/3.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/3.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Destek</b></small></center>
</picture></p>
<h4 id="ii-veri-güvenliği">II. VERİ GÜVENLİĞİ</h4>
<p>Daha sonra oluşabilecek sistem veya program sorunlarına karşı önerim en az iki güncel yedek bulunmalıdır. Biri Time Machine yöntemi kullanılarak alınacak olan yedek olup diğeri ise dosyalarınızın harici bir hard diske sürükle bırak yöntemi ile yedeklenmesi şeklindedir.</p>
<h4 id="iii-gereklilikler">III. GEREKLİLİKLER</h4>
<p>İstediğiniz sistemin yükleyicisine, yani <a href="https://github.com/dortania/OpenCore-Legacy-Patcher/releases/latest">güncel OCLP sürümüne</a> ihtiyacınız var. OCLP destekli bir Mac, fare, klavye, en az 16 GB belleğe sahip bir yardımcı sürücü (usb disk yeterlidir) veya harici sabit disk, gerekirse yeni sisteminizin hedef sürücüsü olmalıdır. Tüm cihazları USB üzerinden bağlamanız gerekir. Güvenli tarafta olmak için, güç kaynağını kullanarak dizüstü bilgisayar çalıştırmalısınız.</p>
<h4 id="iv-kurulum">IV. KURULUM</h4>
<p>Aşağıdaki bölümlerde yeni sistemin kurulumu adım adım anlatılmaktadır.</p>
<p>1. Yardımcı cihazın hazırlanması

<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/4.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Disk İzlencesi</b></small></center>
</picture></p>
<p>➝ Yardımcı cihazı (örn. USB çubuğu) Mac&rsquo;e bağlayın.</p>
<p>➝ Disk İzlencesi Programını açın.</p>
<p>➝ “Görüntüle”ye ve ardından “Tüm cihazları göster”e tıklayın.</p>
<p>➝ Yardımcı cihaz simgesini seçin; simgesi sola hizalanmıştır.

<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/5.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Usb Formatlama</b></small></center>
</picture></p>
<p>➝ “Sil”e tıklayın.</p>
<p>➝ İsim aynı kalabilir.</p>
<p>➝ Format olarak “Mac OS Genişletilmiş (Günlüklü)” seçeneğini seçin.</p>
<p>➝ Şema olarak “GUID Bölümleme Tablosu”nu seçin.</p>
<p>➝ “Sil”e tıklayın; komut tüm verileri siler.</p>
<p>➝ “Bitti”ye tıklayın.</p>
<p>2. Sistem kurucunun yardımcı cihaza kurulması</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/6.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/6.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/6.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>OCLP 1.0.1</b></small></center>
</picture></p>
<p>➝ “MacOS Yükleyici Oluştur”a tıklayın.</p>
<p>➝ “MacOS Installer&rsquo;ı İndir” seçeneğine tıklayın.</p>
<p>➝ macOS&rsquo;u seçin.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/7.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/7.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/7.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>1</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/8.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/8.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/8.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>2</b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<p>➝ İndirdikten sonra otomatik doğrulamayı bekleyin.</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “MacOS Yükleyici Oluşturulsun mu?” penceresinde “Evet”e tıklayın.</p>
<p>➝ “Yerel macOS Yükleyiciyi Seç” penceresinde yükleyiciyi seçin.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/9.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/9.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/9.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>3</b></small></center>
</picture></p>
<p>➝ Yardımcı sürücüyü seçin (Mac&rsquo;inizin dahili HD&rsquo;si olarak disk0&rsquo;ı değil).</p>
<p>➝ “Onay” penceresinde “Evet”e tıklayın; komut tüm verileri siler.</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “MacOS yükleyici başarıyla oluşturuldu!” penceresinde “Evet”e tıklayın.</p>
<p>➝ “OpenCore yapılandırmanızın oluşturulması tamamlandı!” penceresinde “Diske yükle” seçeneğine tıklayın.</p>
<p>➝ Yardımcı cihazı seçin (disk0&rsquo;ı değil).</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “Uygulamak için yeniden başlatılsın mı?” penceresinde alt tuşunu basılı tutarak “Yeniden Başlat”a tıklayın.</p>
<p>➝ “Yeniden Başlat”a tıklayın ve alt tuşunu basılı tutmaya devam edin.</p>
<p>➝ Başlangıç yöneticisinde “EFI boot”u seçin ve alt tuşunu basılı tutmaya devam edin.</p>
<p>➝ Bir sonraki başlangıç ekranında alt tuşunu basılı tutarken “MacOS xyz&rsquo;yi yükle” seçeneğini seçin ve alt tuşunu bırakın.</p>
<p>➝ Kurtarma bölümü (macOS Recovery) görüntülenir.</p>
<p>3. Sistemin kurulumu</p>
<p>“MacOS Recovery” kurtarma bölümünde yükseltme veya temiz kurulum gerçekleştirebilirsiniz. Ancak başka bir program zaten bir sistem yaması oluşturduysa temiz kurulum yapmanız gerekir. Harici bir HD&rsquo;ye kurulum yaparken lütfen uzun versiyondaki açıklama bölümlerine de dikkat edin.</p>
<p>a) Yükseltme</p>
<p>➝ Aşağıdaki düğmelere tıklayın:</p>
<p>➝ “MacOS xyz&rsquo;yi (hangi sürümü indirdiyseniz) yükle”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Kabul et”</p>
<p>➝ “Kabul et”</p>
<p>➝ Hedef sürücüyü seçin.</p>
<p>➝ “Devam Et”e tıklayın.</p>
<p>➝ Kurulum birkaç yeniden başlatmayla başlar (30 dk kadar ve daha uzun).
Bu süre zarfında herhangi bir şekilde Usb&rsquo;yi çıkarmayın ve yeniden başlatıldığı zaman çıkan önyükleme seçeneklerine karışmayın. Her şey otomatik olarak ilerleyecektir. Siz sadece sizden bir bilgi girmeniz gerektiği takdirde kuruluma müdahale etmelisiniz.</p>
<p>b) Temiz Kurulum</p>
<p>➝ “Disk Yardımcı Programı”na tıklayın.</p>
<p>➝ “Devam Et”e tıklayın.</p>
<p>➝ Hedef sürücüyü seçin.</p>
<p>➝ “Sil”e tıklayın.</p>
<p>➝ Bir isim verin.</p>
<p>➝ Format olarak APFS&rsquo;yi seçin.</p>
<p>➝ Şema olarak GUID bölümleme tablosunu seçin.</p>
<p>➝ “Sil”e tıklayın; komut tüm verileri siler.</p>
<p>➝ “Bitti”ye tıklayın.</p>
<p>➝ Aşağıdaki düğmelere tıklayın:</p>
<p>➝ “MacOS xyz&rsquo;yi yükle”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Kabul et”</p>
<p>➝ “Kabul et”</p>
<p>➝ Hedef sürücüyü seçin.</p>
<p>➝ “Devam Et”e tıklayın.</p>
<p>➝ Kurulum birkaç yeniden başlatmayla başlar (30 dk kadar ve daha uzun).</p>
<p>➝ Bu süre zarfında herhangi bir şekilde Usb&rsquo;yi çıkarmayın ve yeniden başlatıldığı zaman çıkan önyükleme seçeneklerine karışmayın. Her şey otomatik olarak ilerleyecektir.</p>
<h4 id="v-kurulumdan-sonra">V. KURULUMDAN SONRA</h4>
<p>
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/10.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Post-Install</b></small></center>
</picture></p>
<p>➝ Sürücülerin güncel olup olmadığını kontrol edin ve OCLP&rsquo;yi açın.</p>
<p>➝ “Yükleme Sonrası Kök Yaması”na tıklayın.</p>
<p>
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/11.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Root Patch</b></small></center>
</picture></p>
<p>➝ “Tüm geçerli yamalar zaten yüklü” mesajını görürseniz başka bir şey yapmanıza gerek yoktur.</p>
<p>➝ “Sistem için mevcut yamalar” mesajında “Kök Yamalamayı Başlat” seçeneğine tıklayın.</p>
<p>➝ “Evet”e tıklayın.</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>➝ Yeniden başlattıktan sonra tekrar “Post-Install Root Patch” seçeneğine tıklayın.</p>
<p>➝ Şimdi “Tüm geçerli yamalar zaten yüklü” mesajı görüntülenmelidir.</p>
<h4 id="vi-sorun-çözümleri">VI. SORUN ÇÖZÜMLERİ</h4>
<p>Önerilen çözümler için <a href="https://dortania.github.io/OpenCore-Legacy-Patcher/TROUBLESHOOTING.html">Github</a> sayfasını ziyaret edebilirsiniz.</p>
<h3 id="uzun-versiyon">UZUN VERSİYON</h3>
<p>Aşağıdaki süreç macOS 11 Big Sur, macOS 12 Monterey, macOS 13 Ventura ve MacOS 14 Sonoma sistemlerine yama uygulanması için geçerlidir. Kısa bölümde anlatılan şeylerin daha ayrıntılı ve geniş bir şekilde anlatıldığı bir bölüm olacaktır.</p>
<h4 id="i-araştirma-1">I. ARAŞTIRMA</h4>
<p>1. Mac&rsquo;inizin OCLP ile uyumluluğunu <a href="https://dortania.github.io/OpenCore-Legacy-Patcher/MODELS.html">buradan</a> kontrol edin. Ayrıca oradaki cihaz listesinin yorum sütununda yer alan kısıtlamalara ve önerilere de dikkat edin. Model adını (örn. iMac 12.2) eski sistemlerde şu şekilde bulabilirsiniz: Sol üstte Apple simgesi ➝ “Bu Mac Hakkında” ➝ “Sistem raporu” ➝ “Model tanımlama”.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/12.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/12.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/12.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Sistem Raporu</b></small></center>
</picture></p>
<p>2. Ayrıca OCLP cihaz listesinin yorum sütunundaki kısıtlamalara veya önerilere de dikkat edin.</p>
<h4 id="ii-veri-güvenliği-1">II. VERİ GÜVENLİĞİ</h4>
<p>1. OCLP&rsquo;yi kullanmadan önce en az iki güncel yedeğin mevcut olması gerekir çünkü geliştiricilerin gösterdiği tüm özene rağmen sistem veya program sorunları ortaya çıkabilir. Asıl yedekleme Time Machine yöntemi kullanılarak alınacak olan yedek olup diğeri ise dosyalarınızın harici bir hard diske sürükle bırak yöntemi ile yedeklenmesi şeklindedir.</p>
<p>2. Mac&rsquo;inizin dahili sabit sürücüsüyle herhangi bir risk almak istemiyorsanız yamayı boş bir harici sabit sürücüde de gerçekleştirebilirsiniz.</p>
<p>3. OCLP, Mac&rsquo;inizin dahili HD&rsquo;sinin ilk bölümünü &ldquo;disk0&rdquo; olarak ve diğer tüm bölüm ve sürücüleri &ldquo;disk1&rdquo;, &ldquo;disk2&rdquo; vb. olarak ifade eder. Bu nedenle, bunları OCLP&rsquo;leriyle tanımlayarak karışıklığı önleyin.</p>
<h4 id="iii-gereklilikler-1">III. GEREKLİLİKLER</h4>
<p>1. USB fare ve USB klavye</p>
<p>2. Talimatları okumak için çıktı veya cihaz</p>
<p>3. OCLP destekli bir Mac (dizüstü bilgisayar Güvenli tarafta olmak için güç kaynağını kullanmalısınız.)</p>
<p>4. En az 16 GB kapasiteli USB sürücüsü (çubuk yeterlidir)</p>
<p>Aşağıda ve yazının devamında <em>yardımcı cihaz</em> olarak anılacaktır.</p>
<p>5. USB bağlantı noktasına sahip harici sürücü (hedef sürücü ise)</p>
<p>6. <a href="https://github.com/dortania/OpenCore-Legacy-Patcher/releases/latest">OCLP&rsquo;nin son sürümü</a></p>
<p>7. Yeni işletim sistemi kurulum sihirbazı (InstallAssistant.pkg)</p>
<p>İndirme işlemi OCLP aracılığıyla, App Store&rsquo;dan veya</p>
<p>İndirme bağlantıları Apple sunucusuna yönlendirilen aşağıdaki web siteleri:
<a href="https://support.apple.com/tr-tr/HT211238">MacOS 11 Big Sur</a>, <a href="https://support.apple.com/tr-tr/HT212551">macOS 12 Monterey</a>, <a href="https://support.apple.com/tr-tr/HT213264">macOS 13 Ventura</a>, <a href="https://www.apple.com/tr/macos/sonoma/">macOS 14 Sonoma</a> aracılığı ile yapılabilir.</p>
<h4 id="iv-kurulum-1">IV. KURULUM</h4>
<p>Aşağıdaki süreç macOS 11 Big Sur, macOS 12 Monterey ve macOS 13 Ventura sistemlerine yama uygulanması için geçerlidir. MacOS 14 Sonoma&rsquo;ya yama uygulanması <strong>4. maddede</strong> açıklanacaktır.</p>
<p>1. Yardımcı cihazın hazırlanması</p>
<p>Yeni sisteminize yama yapmadan önce, sistem yükleyiciyi yardımcı bir cihaza (örn. USB bellek) yüklemelisiniz. Bunu şu şekilde hazırlayın:</p>
<p>➝ Yardımcı cihazı Mac&rsquo;e bağlayın.</p>
<p>➝ Disk İzlencesi Programını açın.</p>
<p>➝ “Görüntüle”ye ve ardından “Tüm cihazları göster”e tıklayın.</p>
<p>➝ Yardımcı cihazın sürücü sembolünü seçin (simge sola hizalanmıştır).</p>
<p>
<picture>
  
  
  

  

  

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/13.jpeg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Usb Formatlama</b></small></center>
</picture></p>
<p>➝ “Sil”e tıklayın.</p>
<p>➝ İsim kalabilir.</p>
<p>➝ Format olarak “Mac OS Genişletilmiş (Günlüklü)” seçeneğini seçin.</p>
<p>➝ Şema olarak “GUID Bölümleme Tablosu”nu seçin.</p>
<p>➝ “Sil”e tıklayın (komut tüm verileri siler).</p>
<p>➝ “Bitti”ye tıklayın.</p>
<p>➝ Önerilen Time Machine yedeklemesini reddedin.</p>
<p>2. Sistem kurucunun yardımcı cihaza kurulması</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/14.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/14.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/14.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>OCLP 1.0.1</b></small></center>
</picture></p>
<p>Yardımcı cihazı hazırladıktan sonra artık sistem kurulumunu ona kurabilirsiniz. Bunu yapmak için OCLP&rsquo;de “MacOS Yükleyici Oluştur” seçeneğine tıklayın. Yükleyiciye zaten sahipseniz “Mevcut macOS Yükleyiciyi Kullan” seçeneğini seçin. Aksi takdirde “MacOS Installer&rsquo;ı İndir” seçeneğini ve istediğiniz macOS&rsquo;u seçin. Daha sonra indirme işlemi başlayacaktır.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/7.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/7.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/7.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>1</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/8.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/8.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/8.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>2</b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<p>İndirme işleminden sonra otomatik doğrulama gerçekleşir. Daha sonra yönetici şifresini girin ve “InstallAssistant.pkg” kurulum sihirbazından çıkartılan “install MacOS xyz.app” isimli sistem yükleyicisinin dahili sürücünüzün Uygulamalar klasöründe olduğundan emin olun. OCLP yalnızca orada sistem kurulumunu tanır.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/9.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/opencore-legacy/9.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/opencore-legacy/9.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>3</b></small></center>
</picture></p>
<p>Ardından “MacOS Yükleyici Oluşturulsun mu?” penceresinde “Evet”e tıklayın, “Yerel macOS Yükleyiciyi Seçin” penceresinde yükleyiciyi seçin, yardımcı sürücüyü seçin (Mac&rsquo;inizin dahili HD&rsquo;si olduğu için disk0 değil), “Evet”e tıklayın “Onay” penceresinde ” (komut tüm verileri siler), yönetici şifresini girin ve önerilen Time Machine yedeklemesini reddedin.</p>
<p>Kurulum tamamlanana kadar “Yükleyici Oluşturuluyor: MacOS xyz’yi Yükle” penceresini açık bırakın. Yardımcı cihazın hızına bağlı olarak yaklaşık 30 dakika veya daha uzun sürebilir. Yardımcı cihaz otomatik olarak yeni adı “MacOS xyz&rsquo;yi yükle” alır.</p>
<p>Bundan sonra, “macOS yükleyicisi başarıyla oluşturuldu!” penceresinde “Evet”e tıklayın, “OpenCore yapılandırmanızı oluşturma tamamlandı!” penceresinde “Diske yükle”ye tıklayın, yardımcı cihazı seçin (disk0 değil), birimi seçin ve Yönetici-Şifresini girin.</p>
<p>Ardından, “Uygulamak için yeniden başlatılsın mı?” penceresinde alt tuşunu basılı tutarak “Yeniden Başlat” seçeneğine tıklayın, ardından “Yeniden Başlat” seçeneğine tıklayın (alt tuşuna basmaya devam edin), başlangıç yöneticisinde “EFI önyükleme” seçeneğini seçin (alt tuşuna basmaya devam edin) tuşuna basın), bir sonraki başlangıç ekranında “MacOS xyz&rsquo;yi yükle”yi seçin (Alt tuşuna basmaya devam edin) ve ardından Alt tuşunu bırakın. Artık “macOS Recovery” kurtarma bölümü görüntülenecektir.</p>
<p>3. Sistemin kurulması</p>
<p>“MacOS Recovery” kurtarma bölümüne ulaştığınızda, yeni sistemin asıl kurulumu burada başlar. Bu nedenle güncel yedeklemelerin önemini son kez hatırlatmak istiyoruz.</p>
<p>Kurulum süresi, ilgili sürücülerin hızına bağlı olarak değişebilir ve bu nedenle bazen sabır gerektirir. Örneğin, &ldquo;Bir dakikadan az kaldı&hellip;&rdquo; mesajı uzun süre görüntüleniyorsa, bu mutlaka bir sorun olduğu anlamına gelmez, çünkü kurulum bir saate kadar veya daha uzun sürebilir.</p>
<p>Mevcut sistemi güncelleyebilir veya yeni bir kurulum gerçekleştirebilirsiniz. Deneyim raporlarına göre temiz kurulumlarda başarı oranı daha yüksektir. Ancak bu, yama yapmadan önce yeni sistemin hedef birimini silmenizi gerektirir. Son olarak, kullanıcılarınızı, ayarlarınızı, programlarınızı vb. bir yedekten hedef birime kopyalamak için geçiş yardımcısını kullanabilirsiniz.</p>
<p>Ancak yükseltme yaparken yeni sistemin hedef birimini silmeniz gerekmez, çünkü bu yalnızca sistemdeki sistemi günceller. Ancak başka bir program zaten bir sistem yaması oluşturduysa temiz kurulum yapmanız gerekir. Yabancı yama silinir ve OCLP yaması ile değiştirilir.</p>
<p>Yeni sistemin kurulum konumu, Mac&rsquo;inizin dahili sürücüsü veya harici bir sürücü olabilir. Kurulumun ilgili sürücünün ilk bölümünde yapılması tavsiye edilir.</p>
<p>a) Yükseltme</p>
<p>Adım IV.2. sonunda macOS Recovery bölümüne ulaştıktan sonra yükseltme yapmak için şu adımları izleyin:</p>
<p>➝ Aşağıdaki düğmelere tıklayın:</p>
<p>➝ “MacOS xyz&rsquo;yi yükle”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Kabul et”</p>
<p>➝ “Kabul et”</p>
<p>➝ Yeni sistemin hedef hacmini seçin.</p>
<p>➝ “Devam Et”e tıklayın.</p>
<p>➝ Hedef sürücüye bağlı olarak c) veya d) noktasından okumaya devam edin.</p>
<p>Not: OCLP geliştiricileri, Big Sur veya Monterey&rsquo;den Ventura&rsquo;ya daha sonraki bir yükseltme için yazılım güncelleme sistemi ayarını değil, harici bir kurulum ortamı kullanılmasını önerir.</p>
<p>b) Temiz Kurulum</p>
<p>Temiz bir kurulum için “macOS Recovery” kurtarma bölümünde şu yolu izleyin:</p>
<p>➝ Disk Yardımcı Programını açın.</p>
<p>➝ “Devam Et”e tıklayın.</p>
<p>➝ Yeni sistemin hedef sürücüsünü seçin.</p>
<p>➝ “Sil”e tıklayın.</p>
<p>➝ Bir isim verin.</p>
<p>➝ APFS formatını seçin.</p>
<p>➝ Şema olarak GUID bölümleme tablosunu seçin.</p>
<p>➝ “Sil”e tıklayın; komut tüm verileri siler.</p>
<p>➝ “Bitti”ye tıklayın.</p>
<p>➝ Disk Yardımcı Programından çıkın.</p>
<p>➝ Aşağıdaki düğmelere tıklayın:</p>
<p>➝ “MacOS xyz&rsquo;yi yükle”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Devam Et”</p>
<p>➝ “Kabul et”</p>
<p>➝ “Kabul et”</p>
<p>➝ Yeni sistemin hedef hacmini seçin.</p>
<p>➝ “Devam Et”e tıklayın.</p>
<p>➝ Hedef sürücüye bağlı olarak c) veya d) noktasından okumaya devam edin.</p>
<p>Not: APFS biçimindeki bir birim, eski HFS+ biçimindeki bir birimi okuyabilir ve yazabilir. Ancak bir HFS+ birimi yalnızca HFS+ biriminde en az macOS 10.12.6 Sierra yüklüyse APFS birimini okuyabilir ve yazabilir. Maalesef hâlâ önemli kısıtlamalar mevcut.</p>
<p>c) Dahili sürücüye kurulum</p>
<p>a) veya b) noktasından sonra &ldquo;Yaklaşık xy dakika kaldı&rdquo; ilerleme çubuğu görünür ve bunu daha fazla yeniden başlatma izler (hiçbir şeye tıklamayın) ve &ldquo;xy % tamamlandı&rdquo; ilerleme çubuğunun bulunduğu siyah bir ekran gelir.</p>
<p>Kurulum sırasında kurtarma bölümü ikinci kez görünürse sol üstteki Apple simgesinin altındaki &ldquo;Yeniden Başlat&quot;a tıklayın, ardından Alt tuşunu basılı tutun, Başlangıç Yöneticisi&rsquo;nde &ldquo;EFI Boot&quot;u seçin ve Alt tuşunu basılı tutmaya devam edin ve &quot; Bir sonraki başlangıç ekranında macOS Installer”. Kurtarma bölümü yeniden görünürse bu işlemi tekrarlayın.</p>
<p>d) Harici sürücüye kurulum</p>
<p>Harici bir sürücüye kurulum yaparken aşağıdaki noktalar dikkate alınmalıdır: MacOS 10.15 Catalina&rsquo;dan bu yana harici sürücüler artık Firewire aracılığıyla başlatılamadığından, sürücüyü Mac&rsquo;teki USB bağlantı noktasına bağlamanız gerekir. Ancak yama yaptıktan sonra OCLP&rsquo;de harici sürücünüzün Firewire aracılığıyla yeniden başlatılabileceğini ayarlayabilirsiniz. Harici bir HD&rsquo;nin yalnızca Bilgi penceresinde &ldquo;Bu birimdeki sahipliği yoksay&rdquo; seçeneği işaretlenmemişse önyüklenebilir olacağını unutmayın.</p>
<p>MacOS 13 Ventura&rsquo;nın harici bir sabit sürücüye temiz kurulumu 0.6.4 sürümünden bu yana yeni OCLP sürümlerinde daha kısadır:</p>
<p>➝ “Yükle: “Yaklaşık xy dakika kaldı” ilerleme çubuğu görünür.</p>
<p>➝ Başlangıç yöneticisinde “macOS Installer”ı seçin.</p>
<p>➝ Apple simgesinin bulunduğu siyah bir ekran ve “Yaklaşık xx dakika kaldı” ilerleme çubuğunu görebilirsiniz.</p>
<p>➝ Başlangıç Yöneticisi görünür (hiçbir şeye tıklamayın).</p>
<p>➝ Bunu, Apple simgesinin bulunduğu siyah bir ekranla ve 15 dakika boyunca tam bir ilerleme göstergesiyle yeniden başlatma izler.</p>
<p>➝ Yeniden başlatma gerçekleşir.</p>
<p>➝ Başlangıç yöneticisinde yeni sistemin hedef birimini seçin.</p>
<p>➝ Başka bir yeniden başlatma olacak.</p>
<p>➝ Başlangıç yöneticisinde yeni sistemin hedef hacmini tekrar seçin.</p>
<p>➝ %98&rsquo;de uzun bir bekleme süresiyle birlikte “%xy tamamlandı” ilerleme göstergesinin yer aldığı siyah bir ekran görüntülenir.</p>
<p>➝ Başka bir yeniden başlatma olacak.</p>
<p>➝ Startup Manager&rsquo;da aşağıdaki hiçbir şeyi seçmeyin.</p>
<p>➝ Kurtarma bölümü (macOS Recovery) görünür.</p>
<p>➝ Sol üstteki Apple simgesine tıklayın.</p>
<p>➝ Alt tuşunu basılı tutarken “Yeniden Başlat”a tıklayın.</p>
<p>➝ Başlangıç yöneticisinde yeni sistemin yüklendiği diski seçin.</p>
<p>Kurulum sırasında kurtarma bölümünün ikinci kez görüntülenmesi gerekiyorsa: Sol üstteki Apple simgesinin altındaki &ldquo;Yeniden Başlat&rdquo; seçeneğine tıklayın ve ardından alt tuşunu basılı tutun, başlangıç yöneticisinde &ldquo;EFI Boot&rdquo; seçeneğini seçin ve alt tuşunu basılı tutmaya devam edin. tuşuna basın ve bir sonraki başlangıç ekranında “macOS Installer”ı seçin. Kurtarma bölümü yeniden görünürse bu işlemi tekrarlayın.</p>
<p>Temiz kurulumu tamamlamak için, normal sistem kurulumunda olduğu gibi kurulum sihirbazında ülkeyi, dili, ağı (şifrenizi hazır bulundurun) vb. seçersiniz. Kullanıcı adını atarken, lütfen kullanıcı adını kullanmamanın daha iyi olacağını unutmayın. Daha sonra taşınacak kullanıcının adını seçin.</p>
<h4 id="v-kurulumdan-sonra-1">V. KURULUMDAN SONRA</h4>
<p>1. Yazılım Güncelleme sistem ayarlarında otomatik güncellemeleri devre dışı bırakmalısınız. Bu, Apple yazılım güncellemesinin bir sonucu olarak olası sistem sorunlarını önlemek için tavsiye edilir. İlk lansmanından sonra yeni sistem, öncelikle Spotlight endeksini yeniden oluşturması gerektiğinden genellikle biraz daha yavaş olacaktır.</p>
<p>2. İlk sistem önyüklemesinden hemen sonra OCLP, OpenCore&rsquo;u dahili sabit sürücüye yüklemek isteyip istemediğinizi soracaktır. Bu, gelecekte yardımcı cihaz olmadan sistemi başlatmanıza olanak sağlayacaktır. Yeni sistem harici bir sürücüye kurulmuşsa, bu iletişim kutusundaki &ldquo;dahili sabit sürücüye&rdquo; ifadesi yanıltıcı olabilir. Bu durumda harici sürücüye OpenCore&rsquo;un da kurulması gerekir.</p>
<p>OpenCore kurulumu şu şekilde çalışır: “Tamam”a tıklayın, ardından “Diske yükle”ye tıklayın, yeni sistemin sürücüsünü ve ardından birimi seçin. Daha sonra alt tuşunu basılı tutarak “EFI Boot”un başlangıç yöneticisini başlatın ve alt tuşunu basılı tutmaya devam edin. Bir sonraki önyükleme ekranında yeni sistemin biriminden önyükleme yapın.</p>
<p>Yukarıdaki &ldquo;Tamam&rdquo; seçeneğine tıkladıktan sonra, aşağıdaki günlük penceresi OpenCore kurulumunun ayrı ayrı adımlarını gösterir. Daha sonra OpenCore kurmaya karar verirseniz “Build and Install OpenCore” komutunu kullanarak yukarıda anlatılan işlemi başlatabilirsiniz.</p>
<p>3. Yeni sisteminizi harici bir birime kurduysanız:</p>
<p>a) 0.6.7 sürümünden itibaren OCLP&rsquo;yi artık harici birimin programlar klasörüne değil, Library/Application Support/Dortania klasörüne yerleştirmeniz gerekiyor. Ancak OCLP&rsquo;den bir takma ad oluşturabilir ve bunu Uygulamalar klasörüne koyabilirsiniz.</p>
<p>b) Adım V.2.&lsquo;yi tamamladıysanız, gelecekte yeni sisteminizi yardımcı cihaz olmadan başlatabileceksiniz. Şu şekilde çalışır: Mac&rsquo;i açtığınızda Alt tuşunu basılı tutun, ilk başlangıç ekranında &ldquo;EFI Boot&quot;u seçin. “EFI Boot” tanınmazsa, harici HD&rsquo;yi Mac&rsquo;in USB bağlantı noktasından kısa süreliğine çıkarabilir (başlangıç ekranını olduğu gibi bırakarak) ve tekrar takabilirsiniz. Kural olarak “EFI önyüklemesi”nin tanınması gerekir.</p>
<p>c) Yama sonrasında harici sürücünüzü Firewire aracılığıyla yeniden başlatmak istiyorsanız bunu aşağıdaki şekilde yapabilirsiniz:</p>
<p>➝ OCLP&rsquo;yi açın.</p>
<p>➝ “Ayarlar”a tıklayın.</p>
<p>➝ “Hedef Model” altında Mac türünü seçin.</p>
<p>➝ “Oluştur”a tıklayın.</p>
<p>➝ “FireWire Önyükleme” seçeneğini etkinleştirin.</p>
<p>➝ “Geri Dön”e tıklayın.</p>
<p>➝ “OpenCore Oluştur ve Kur” seçeneğine tıklayın.</p>
<p>➝ “Diske yükle”ye tıklayın.</p>
<p>➝ Yeni sistemin sürücüsünü seçin.</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>4. “Ayarlar” altında OpenCore ayarlarını bulacaksınız. Ancak bunları yalnızca etkisini biliyorsanız değiştirin; aksi halde bilgisayarın bir sonraki başlatılması başarısız olabilir. Ayrıca, Hedef Model ayarlarını değiştirmeden önce her Mac modelinin farklı ayarları olduğundan öncelikle bilgisayar modelinizi seçmelisiniz.</p>
<p>Ayarları düzenlemek ve kaydetmek için şu adımları izleyin:</p>
<p>➝ OCLP&rsquo;yi açın.</p>
<p>➝ “Ayarlar”a tıklayın.</p>
<p>➝ “Hedef Model” altında Mac&rsquo;i seçin.</p>
<p>➝ Daha sonra OCLP&rsquo;yi kapatmadan ayarlara girin. Aksi halde önceki ayarlar kalır.</p>
<p>➝ “Geri Dön”e tıklayın.</p>
<p>➝ “OpenCore Oluştur ve Kur” seçeneğine tıklayın.</p>
<p>➝ “Diske yükle”ye tıklayın.</p>
<p>➝ Yeni sistemin sürücüsünü seçin.</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>5. Yeni sistemi dahili bir sabit sürücüye kurduysanız ve artık Başlangıç Yöneticisinin gelecekte görüntülenmesini istemiyorsanız, aşağıdaki şekilde ilerleyin:</p>
<p>➝ OCLP&rsquo;yi açın.</p>
<p>➝ “Ayarlar”a tıklayın.</p>
<p>➝ “Açık Çekirdek Önyükleme Seçicisini Göster” seçeneğinin işaretini kaldırın.</p>
<p>➝ Aşağıdaki “Ana Menüye Dön” seçeneğine tıklayın.</p>
<p>➝ “OpenCore Oluştur ve Kur” seçeneğine tıklayın.</p>
<p>➝ “Diske yükle”ye tıklayın.</p>
<p>➝ disk0&rsquo;ı seçin (= dahili sürücü).</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>6. &ldquo;Önyükleme Seçici Zaman Aşımı&rdquo; ayarı, başlangıç yöneticisinin (önyükleme seçicinin) ne kadar süreyle görüntüleneceğini belirtmenize olanak tanır. Bu süre zarfında yamalı ya da başka bir başlangıç diskinizi seçebilirsiniz. Bu süre dolduktan sonra standart işletim sistemi başlatılır.</p>
<p>7. Metal olmayan bir Mac&rsquo;te menü çubuğunun yazı tipi rengini beyazdan siyaha değiştirmek istiyorsanız OCLP&rsquo;yi açın, Ayarlar&rsquo;a tıklayın, Metal Olmayan Ayarlar&rsquo;a tıklayın, Koyu Menü Çubuğu&rsquo;nu seçin ve “ Ayarlar&rsquo;a dönün”. Son olarak kullanıcıyı yeniden kaydetmeniz yeterlidir; “OpenCore&rsquo;u Oluştur ve Kur” komutu gerekli değildir</p>
<p>8. Sistem ile donanım arasındaki iletişim için gereken tüm sürücülerin güncel olup olmadığını kontrol edin. Bu şu şekilde çalışır:</p>
<p>➝ OCLP&rsquo;yi açın.</p>
<p>➝ “Yükleme Sonrası Kök Yaması”na tıklayın.</p>
<p>➝ “Tüm geçerli yamalar zaten yüklü” mesajını görürseniz başka bir şey yapmanıza gerek yoktur.</p>
<p>➝ “Sistem için mevcut yamalar” mesajında “Kök Yamalamayı Başlat” seçeneğine tıklayın.</p>
<p>➝ “Evet”e tıklayın.</p>
<p>➝ Yönetici şifresini girin.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>➝ “Yeniden Başlat”a tıklayın.</p>
<p>➝ Başlangıç yöneticisinde hiçbir şey seçmeyin.</p>
<p>➝ Yeniden başlattıktan sonra tekrar “Post-Install Root Patch” seçeneğine tıklayın.</p>
<p>➝ Şimdi “Tüm geçerli yamalar zaten yüklü” mesajı görüntülenmelidir.</p>
<p>9. Yamalı bir birimi başka bir Mac&rsquo;te başlatmayı da deneyebilirsiniz. Ancak lütfen bunun uygun donanım yazılımına, ilgili macOS&rsquo;a ve yamalı birim ile aynı OpenCore&rsquo;a sahip olması gerektiğini unutmayın. Ayrıca donanımın aynı olması gerekmektedir. Farklı Bluetooth modülleri gibi farklılıklar varsa, donanım tanınmazsa başlatma sorunları ortaya çıkabilir.</p>
<h4 id="vi-sorun-çözümleri-1">VI. SORUN ÇÖZÜMLERİ</h4>
<p>1. Önerilen çözümler için <a href="https://dortania.github.io/OpenCore-Legacy-Patcher/TROUBLESHOOTING.html">Github</a> sayfasını ziyaret edebilirsiniz. Özellikle Bluetooth sorunları için bakmanızda da fayda var. Gerekirse en son sürüm olan Sonoma yerine bir önceki sürümü yüklemeniz bazen daha uyumlu ve faydalı olabiliyor.</p>
<p>2. 0.6.7 sürümünden bu yana, ~/Library/Logs/Dortania klasöründeki OCLP günlük dosyasına “Dosya” ve “Günlük Dosyasını Göster” menüleri aracılığıyla doğrudan erişebilirsiniz. Bu, hataların olası nedenlerinin belirlenmesine olanak sağlar.</p>
<p>3. Bir ses arızası varsa, Ses sistemi ayarlarından dahili hoparlörlerin çıkış cihazı olarak seçilip seçilmediğini kontrol edebilirsiniz.</p>
<p>4. Sistem bir sistem veya güvenlik güncellemesinden sonra artık başlamazsa, Shift tuşunu basılı tutarak Mac&rsquo;i Güvenli Modda başlatmayı ve ardından &ldquo;Yükleme Sonrası Kök Yaması&rdquo; yolunu kullanmayı deneyebilirsiniz</p>
<p>Bu işe yaramazsa kök yamaları silmenizi öneririz. Bu şu şekilde çalışır:</p>
<p>➝ Başlatma sırasında alt tuşunu basılı tutun ve başlangıç yöneticisinde “EFI önyükleme” seçeneğini seçin.</p>
<p>➝ Bir sonraki ekranda önyükleme seçenekleri menüsünü açmak için boşluk çubuğuna basın.</p>
<p>➝ Kurtarma bölümünü seçin.</p>
<p>➝ Orada Terminal programını açın.</p>
<p>➝ Aşağıdaki komut satırını kopyala ve yapıştır kullanarak terminal penceresine yapıştırın:</p>
<p><code>mount -uw /Volumes/Macintosh\ HD</code></p>
<p>➝ Enter tuşuna basın.</p>
<p>➝ Bu ikinci komut satırını ekleyin:</p>
<p><code>bless --mount /Volumes/Macintosh\ HD --bootefi --last-sealed-snapshot</code></p>
<p>➝ Enter tuşuna tekrar basın.</p>
<p>➝ Sol üstteki Apple simgesine tıklayın ve alttaki “Yeniden Başlat”a tıklayın.</p>
<p>Her iki komut satırını da girerken, <em>Macintosh\ HD</em> adını yamalı biriminizin adı ile değiştirin ve addaki her boşluğun önüne \ ters eğik çizgi karakterini ekleyin.</p>
<p>Bu adımlardan sonra, OCLP&rsquo;yi güncelleyene kadar veya önyükleme sorunundan önce bunu zaten yaptıysanız, sorunu çözen yeni bir OCLP güncellemesi mevcut olana kadar kök yamaları yeniden yüklemeyi beklemelisiniz.</p>
<p>6. Büyük sorunlar olması durumunda, yama yapılmamış önceki sistem sürümüne geçmek de mümkündür. Bunu yapmak için Time Machine&rsquo;i, kurtarma bölümünü veya önyüklenebilir bir yükleyiciyi kullanabilirsiniz. Bununla ilgili talimatları <a href="https://www.drbuho.com/how-to/downgrade-macos">burada</a> bulabilirsiniz. (Lütfen reklamları dikkate almayın). Time Machine için yamadan önce oluşturulmuş bir yedeği seçmeniz gerektiğini unutmayın. Ancak eski bir OCLP sistem yamasına geçmek mümkün değildir. Bunu yapmak için, Temiz Kurulum&rsquo;u kullanarak OCLP&rsquo;yi kullanarak istediğiniz eski sistem sürümünü yüklemelisiniz.</p>
<h1 id="son">SON</h1>
<p>Neyse ki OCLP yalnızca ücretsiz değil aynı zamanda son derece sürdürülebilirdir. Mac&rsquo;in daha uzun süre kullanılabilmesi nedeniyle program yalnızca donanım maliyetlerini ve elektronik atıkları azaltmakla kalmıyor, aynı zamanda kaynak tüketimini ve üretimden kaynaklanan emisyonları da azaltıyor.</p>
<p>OCLP geliştiricilerinin sürekli kararlılığını desteklemek isterseniz, örneğin çok sayıda test bilgisayarı satın alarak veya yalnızca teşekkür etmek amacıyla bunu küçük bir bağışla geliştiricilerin <a href="https://opencollective.com/opencore-legacy-patcher">web sitesinden</a> yapabilirsiniz.</p>
<p>OCLP gelişmeye devam ettikçe gelecekte bu talimatlardan sapmalar ortaya çıkabilir. Daha sonra yeni özellikleri <a href="https://github.com/dortania/OpenCore-Legacy-Patcher">OCLP web sitesinde</a> bulabilirsiniz. Ayrıca şu <a href="https://www.youtube.com/@Mr.Macintosh/videos">video koleksiyonunu</a> ve ilgili <a href="https://de.wikipedia.org/wiki/OpenCore_Legacy_Patcher">Wiki</a> sayfasına da göz atılmasını öneririm.</p>
<p>MacOS Sonoma kurulumu ile ilgili örnek videoya aşağıdan ulaşabilirsiniz:


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/eGR2qGw9lG8?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>
</p>
<h2 id="kaynakça">Kaynakça:</h2>
<p>Yazı sırasında kullandığım kaynaklar:</p>
<ul>
<li><a href="https://github.com/dortania/OpenCore-Legacy-Patcher">OpenCore Legacy Patcher Github</a></li>
<li><a href="https://dortania.github.io/OpenCore-Legacy-Patcher">OpenCore Legacy Patcher Web Sayfası</a></li>
<li><a href="https://macsofa.net/">Macsofa Forum</a></li>
<li><a href="https://www.youtube.com/@Mr.Macintosh/videos">Mr.Macintosh Youtube Kanalı</a></li>
<li><a href="https://khronokernel.github.io">Khronokernel Web Sayfası</a></li>
<li>İlk Yayım: <a href="https://btt.community/t/eski-maclere-opencore-ile-desteklenmeyen-surumlerin-kurulumu/2140">BTT</a></li>
</ul>
]]></content:encoded></item><item><title>Actalis ile ücretsiz S/MIME sertifikası alınması</title><link>https://wiseweb-works.github.io/blog/post/actalis-ile-smime-sertifikasi/</link><pubDate>Sun, 01 Oct 2023 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/actalis-ile-smime-sertifikasi/</guid><description>Ücretsiz S/MIME Sertifikası Nasıl Alınır: Adım Adım Rehber Günümüzde e-posta iletişimi günlük yaşamın ayrılmaz bir parçası haline geldi. Ancak e-posta gönderirken veya alırken güvenlik endişeleri her zaman mevcuttur. S/MIME (Secure/Multipurpose Internet Mail Extensions), e-postalarınızı daha güvenli hale getirmenize yardımcı olan bir teknolojidir. S/MIME sertifikaları, e-postalarınızı şifrelemek ve kimlik doğrulama sağlamak için kullanılır. Neyse ki, ücretsiz S/MIME sertifikaları edinmek oldukça kolaydır. Bu forum rehberinde, bu işlemi adım adım anlatacağız.
Adım 1: Actalis Extrassl Sayfasına Gidin İlk adımda, ücretsiz bir S/MIME sertifikası almak için Actalis Extrassl web sitesini ziyaret edin.</description><content:encoded><![CDATA[<h1 id="ücretsiz-smime-sertifikası-nasıl-alınır-adım-adım-rehber">Ücretsiz S/MIME Sertifikası Nasıl Alınır: Adım Adım Rehber</h1>
<p>Günümüzde e-posta iletişimi günlük yaşamın ayrılmaz bir parçası haline geldi. Ancak e-posta gönderirken veya alırken güvenlik endişeleri her zaman mevcuttur. S/MIME (Secure/Multipurpose Internet Mail Extensions), e-postalarınızı daha güvenli hale getirmenize yardımcı olan bir teknolojidir. S/MIME sertifikaları, e-postalarınızı şifrelemek ve kimlik doğrulama sağlamak için kullanılır. Neyse ki, ücretsiz S/MIME sertifikaları edinmek oldukça kolaydır. Bu forum rehberinde, bu işlemi adım adım anlatacağız.</p>
<h2 id="adım-1-actalis-extrassl-sayfasına-gidin">Adım 1: Actalis Extrassl Sayfasına Gidin</h2>
<p>İlk adımda, ücretsiz bir S/MIME sertifikası almak için <a href="https://extrassl.actalis.it/portal/uapub/freemail">Actalis Extrassl</a> web sitesini ziyaret edin. Bu sertifikayı almak için bu siteyi kullanacağız. Siteye girdikten sonra sizde bir e-posta adresi isteyecek. Bu adres s/mime sertifikasını üreteceğiniz adres olması gerekli.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/1.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/1.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/actalis/1.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Actalis Extrassl</b></small></center>
</picture></p>
<h2 id="opsiyonel-adım-2-dil-seçeneğini-ayarlayın">(Opsiyonel) Adım 2: Dil Seçeneğini Ayarlayın</h2>
<p>Sitenin üst sağ köşesinde, dil seçeneğini ayarlayabilirsiniz. Eğer sizde de başlangıçta İtalyanca çıkıyor ise dil seçeneğini İngilizce olarak ayarlamak isteyebilirsiniz, böylece prosedürü daha iyi anlayabilirsiniz.</p>
<h2 id="adım-3-e-posta-adresinizi-doğrulayın">Adım 3: E-Posta Adresinizi Doğrulayın</h2>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/actalis/2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Gelen mail</b></small></center>
</picture></p>
<p>Bir önceki adımda girmiş olduğunuz mail adresinize görseldeki gibi bir kod gönderecekler. Bu kod girmiş olduğumuz mail adresinin bize ait olduğunu ve gönderilen mailleri alabildiğimizi teyit etmek amacıyla gönderiliyor.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/3.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/3.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/actalis/3.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Doğrulama kodu girme ekranı</b></small></center>
</picture></p>
<p>Size gelen kodu ilgili fotoda görülen Verification code alanını girmeniz ve her iki kutucuğu da seçtikten sonra Submit request butonuna tıklamanız gerekiyor.</p>
<h2 id="adım-4-sertifikayı-indirin-ve-kurun">Adım 4: Sertifikayı İndirin ve Kurun</h2>
<p>Doğrulama işlemi tamamlandığında, S/MIME sertifikası hazır olacak ve size verilen talimatları izleyerek sertifikayı indirip kurabileceksiniz.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/4.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/4.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/actalis/4.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Onay Ekranı</b></small></center>
</picture></p>
<p>Fakat öncelikle yukarıdaki gibi bir onaylama ekranı gördüğünüzden emin olmanız ve tüm süreç bitene kadar bu ekranı kapatmamanız gerekiyor. Ekrandaki onaylama metninin altında (ben ilk seferinde gözden kaçırmıştım) bir şifre beliriyor ve bunu bir yere not etmeniz gerekiyor.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/5.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/actalis/5.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/actalis/5.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Sertifika Geldi</b></small></center>
</picture></p>
<p>Daha sonra mail adresinize gelen şifreli sertifika dosyasını ilgili zip dosyasından çıkarmanız gerekiyor. Size verilen şifre zip dosyası için değil sertifikayı içeri aktarırken kullanılacak. Zip dosyasının bir şifresi yok.</p>
<h2 id="adım-5-e-posta-istemcisi-ayarlarınızı-yapın">Adım 5: E-Posta İstemcisi Ayarlarınızı Yapın</h2>
<p>Son olarak, e-posta istemcinizde S/MIME sertifikanızı kullanmak için gerekli ayarları yapmanız gerekecektir. Bu adımlar, kullandığınız e-posta istemcisine göre değişebilir. O yüzden ayrı ayrı anlatmak yerine ilgili linkleri aşağıya bırakıyorum.</p>
<ul>
<li><a href="https://www.ssl.com/how-to/installing-an-s-mime-certificate-and-sending-secure-email-in-mozilla-thunderbird-on-windows-10/">Thunderbird</a></li>
<li><a href="https://support.apple.com/en-ie/HT202345">Apple Cihazları</a></li>
<li><a href="https://support.microsoft.com/en-au/office/encrypt-messages-by-using-s-mime-in-outlook-on-the-web-878c79fc-7088-4b39-966f-14512658f480">Outlook Web</a></li>
<li><a href="https://support.microsoft.com/en-us/office/encrypt-email-messages-373339cb-bf1a-4509-b296-802a39d801dc">Outlook Uygulaması</a></li>
<li><a href="https://docs.kde.org/stable5/en/kleopatra/kleopatra/configuration-smime-validation.html">Kleopatra (Manuel kullanım için)</a></li>
</ul>
<h2 id="son-söz">Son Söz</h2>
<p>Artık ücretsiz S/MIME sertifikasına sahipsiniz ve e-postalarınızı daha güvenli hale getirebilirsiniz. Bu sertifikalar, e-postalarınızın şifrelenmesine ve kimlik doğrulamasına yardımcı olur, böylece kişisel bilgilerinizin güvende olduğundan emin olabilirsiniz. Son bir hatırlatma olarak da S/MIME sertifikaları belirli bir süreyle sınırlı olmaktadır, bu nedenle süresi dolduğunda yeniden sertifika almanız gerekecektir. Bu siteden aldığınız sertifikalar genelde 1 senelik oluyor.</p>
<h3 id="kaynakça">Kaynakça</h3>
<p>E-posta güvenliği hakkında daha fazla bilgi edinmek için bu yazıda fazlasıyla yararlandığım <a href="https://www.frankysweb.de/tipp-kostenloses-s-mime-zertifikat-neu/">Franky&rsquo;s Web</a> sitesini ziyaret edebilirsiniz.</p>
<p>İlk yayım: <a href="https://btt.community/t/actalis-ile-ucretsiz-s-mime-sertifikasi-alinmasi/1927">BTT Community</a></p>
]]></content:encoded></item><item><title>Crowdsec IPS/IDS Yazılımı</title><link>https://wiseweb-works.github.io/blog/post/crowdsec-anlatim/</link><pubDate>Tue, 11 Apr 2023 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/crowdsec-anlatim/</guid><description>1. Crowdsec IPS/IDS Yazılımı Tanıtımı CrowdSec, siber tehditlere karşı gerçek zamanlı koruma sağlamak için kolektif bir zeka yaklaşımı kullanan Linux sunucuları için açık kaynaklı bir güvenlik çözümüdür. Bu blog gönderisinde, CrowdSec&amp;rsquo;in (v.1.4.6)1 özelliklerini, Linux sunucularınızı korumak için neden harika bir seçim olduğunun nedenlerini ve CrowdSec ile diğer IPS/IDS yazılımları arasındaki farkları ve benzerlikleri keşfedeceğiz.
1.1 CrowdSec&amp;rsquo;in Özellikleri CrowdSec, onu Linux sunucuları için güçlü ve etkili bir güvenlik çözümü yapan çeşitli özellikler sunar.</description><content:encoded><![CDATA[<h1 id="1-crowdsec-ipsids-yazılımı-tanıtımı">1. Crowdsec IPS/IDS Yazılımı Tanıtımı</h1>
<p>CrowdSec, siber tehditlere karşı gerçek zamanlı koruma sağlamak için kolektif bir zeka yaklaşımı kullanan Linux sunucuları için açık kaynaklı bir güvenlik çözümüdür. Bu blog gönderisinde, CrowdSec&rsquo;in (v.1.4.6)<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> özelliklerini, Linux sunucularınızı korumak için neden harika bir seçim olduğunun nedenlerini ve CrowdSec ile diğer IPS/IDS yazılımları arasındaki farkları ve benzerlikleri keşfedeceğiz.</p>
<h2 id="11-crowdsecin-özellikleri">1.1 CrowdSec&rsquo;in Özellikleri</h2>
<p>CrowdSec, onu Linux sunucuları için güçlü ve etkili bir güvenlik çözümü yapan çeşitli özellikler sunar. Temel özelliklerinden bazıları şunlardır:</p>
<h3 id="111-gerçek-zamanlı-tehdit-tespiti">1.1.1 Gerçek zamanlı tehdit tespiti</h3>
<ul>
<li>CrowdSec, tehditleri gerçek zamanlı olarak tespit etmek için makine öğrenimi algoritmalarını kullanır ve saldırıların gerçekleşmesini önler.</li>
</ul>
<h3 id="112-otomatik-engelleme">1.1.2 Otomatik engelleme</h3>
<ul>
<li>Bir tehdit algılandığında CrowdSec, saldırıyla ilişkili IP adresini otomatik olarak engelleyerek anında koruma sağlar.</li>
</ul>
<h3 id="113-kolektif-zeka">1.1.3 Kolektif zeka</h3>
<ul>
<li>CrowdSec, yeni ve gelişmekte olan tehditleri algılamak için diğer CrowdSec kullanıcıları da dahil olmak üzere birden çok kaynaktan gelen verilerden yararlanır.</li>
</ul>
<h3 id="114-kolay-entegrasyon">1.1.4 Kolay entegrasyon</h3>
<ul>
<li>CrowdSec, kapsamlı bir güvenlik çözümü sağlamak için güvenlik duvarları ve SIEM&rsquo;ler gibi diğer güvenlik çözümleriyle kolayca entegre edilebilir.</li>
</ul>
<h3 id="115-özelleştirilebilir-kurallar">1.1.5 Özelleştirilebilir kurallar</h3>
<ul>
<li>CrowdSec, kullanıcıların güvenlik politikalarının kendi özel gereksinimleriyle uyumlu olmasını sağlayarak kendi kurallarını oluşturmasına ve özelleştirmesine olanak tanır.</li>
</ul>
<h2 id="12-neden-crowdseci-seçmelisiniz">1.2 Neden CrowdSec&rsquo;i Seçmelisiniz?</h2>
<p>CrowdSec&rsquo;in Linux sunucularınızın güvenliğini sağlamak için mükemmel bir seçim olmasının birkaç nedeni vardır. Bu nedenlerden bazıları şunlardır:</p>
<h3 id="121-açık-kaynak">1.2.1 Açık kaynak</h3>
<ul>
<li>CrowdSec açık kaynaklı bir çözümdür, yani kullanımı ücretsizdir ve özel ihtiyaçlarınızı karşılayacak şekilde kolayca özelleştirilebilir.</li>
</ul>
<h3 id="122-toplu-zeka">1.2.2 Toplu zeka</h3>
<ul>
<li>CrowdSec, yeni ve gelişmekte olan tehditleri tespit etmek için toplu zekanın gücünden yararlanarak geleneksel güvenlik çözümlerinden daha yüksek düzeyde koruma sağlar.</li>
</ul>
<h3 id="123-kolay-entegrasyon">1.2.3 Kolay entegrasyon</h3>
<ul>
<li>CrowdSec, diğer güvenlik çözümleriyle kolayca entegre edilebilir ve bu da onu her kuruluş için esnek ve uyarlanabilir bir çözüm haline getirir.</li>
</ul>
<h3 id="124-özelleştirilebilir-kurallar">1.2.4 Özelleştirilebilir kurallar</h3>
<ul>
<li>CrowdSec, kullanıcıların güvenlik politikalarının kendi özel gereksinimleriyle uyumlu olmasını sağlayarak kendi kurallarını oluşturmasına ve özelleştirmesine olanak tanır.</li>
</ul>
<h2 id="13-crowdsec-ve-cloudflare-arasındaki-fark-ve-benzerlikler">1.3 CrowdSec ve Cloudflare Arasındaki Fark ve Benzerlikler</h2>
<p>CrowdSec ve Cloudflare güvenlik çözümleri olmakla birlikte, ikisi arasında bazı temel farklılıklar vardır. Örneğin:</p>
<h3 id="131-farkları">1.3.1 Farkları</h3>
<ul>
<li>
<p>CrowdSec açık kaynaklı bir çözümken Cloudflare ticari bir çözümdür.</p>
</li>
<li>
<p>CrowdSec, yeni ve gelişmekte olan tehditleri algılamak için toplu zekayı kullanırken Cloudflare, makine öğrenimi ve imza tabanlı algılamanın bir kombinasyonunu kullanır.</p>
</li>
<li>
<p>CrowdSec, Linux sunucularını korumaya odaklanırken, Cloudflare çok çeşitli platformlar için güvenlik çözümleri sunar.</p>
</li>
</ul>
<h3 id="132-benzerlikleri">1.3.2 Benzerlikleri</h3>
<p>Bu farklılıklara rağmen, hem CrowdSec hem de Cloudflare bazı benzerlikleri paylaşır. Örneğin:</p>
<ul>
<li>
<p>Her iki çözüm de tehditleri gerçek zamanlı olarak algılamak için makine öğrenimi algoritmalarını kullanır.</p>
</li>
<li>
<p>Her iki çözüm de kötü amaçlı IP adreslerinin otomatik olarak engellenmesini sağlar.</p>
</li>
<li>
<p>Her iki çözüm de diğer güvenlik çözümleriyle kolayca entegre edilebilir ve kapsamlı bir güvenlik çözümü sunar.</p>
</li>
</ul>
<h2 id="14-kısa-özet">1.4 Kısa Özet</h2>
<p>(TL;DR) <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> CrowdSec, Linux sunucuları için gerçek zamanlı tehdit algılama, otomatik engelleme ve toplu zeka sağlayan güçlü ve etkili bir güvenlik çözümüdür. Açık kaynak yapısı, kolay entegrasyonu ve özelleştirilebilir kuralları, onu Linux sunucularının güvenliğini sağlamak isteyen tüm kuruluşlar için mükemmel bir seçim haline getirir. CrowdSec ve Cloudflare arasında bazı farklılıklar olsa da, her iki çözüm de bazı benzerliklere sahiptir ve dijital varlıklarını güvence altına almak isteyen kuruluşlar için mükemmel seçeneklerdir.</p>
<h1 id="2-crowdsec-linux-nasıl-kurulur">2. Crowdsec Linux Nasıl Kurulur</h1>
<p>CrowdSec, siber tehditlere karşı gerçek zamanlı koruma sağlamak için toplu zeka kullanan Linux sunucuları için açık kaynaklı bir güvenlik çözümüdür. Blog yazısının bu kısmında CrowdSec&rsquo;i Linux sunucunuza kurma adımlarının yanı sıra sunucunuzun güvenliğini daha da artırmak için bir Linux bouncer&rsquo;ı nasıl kuracağınız konusunda size yol göstereceğiz.</p>
<h2 id="21-adım-adım-kılavuz">2.1 Adım Adım Kılavuz</h2>
<p>Başlamadan önce, kurulum işleminin Linux dağıtımınıza bağlı olarak değişebileceğini lütfen unutmayın. Aşağıdaki adımlar Ubuntu 20.04&rsquo;ü temel alır, ancak diğer dağıtımlar için talimatları CrowdSec dokümantasyon sayfasında bulabilirsiniz.</p>
<h3 id="211-crowdseci-yükleyin">2.1.1 CrowdSec&rsquo;i yükleyin</h3>
<p>Öncelikle, aşağıdaki komutu çalıştırarak CrowdSec deposunu sisteminize eklemeniz gerekir:</p>
<h4 id="repo-ve-gpg-anahtarını-manul-ekleme-yöntemi">Repo ve GPG anahtarını manul ekleme yöntemi</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;deb https://packages.crowdsec.net/deb stable main&#39;</span> | sudo tee /etc/apt/sources.list.d/crowdsec.list
</span></span></code></pre></div><p>Ardından, aşağıdaki komutu çalıştırarak CrowdSec imzalama anahtarını sisteminize eklemeniz gerekir:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget -qO - https://packages.crowdsec.net/crowdsec.gpg.key | sudo apt-key add -
</span></span></code></pre></div><h4 id="otomatikleştirilmiş-script-ile-repo-ve-gpg-anahtarının-eklenmesi">Otomatikleştirilmiş script ile Repo ve GPG anahtarının eklenmesi</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -s https://packagecloud.io/install/repositories/crowdsec/crowdsec/script.deb.sh | sudo bash
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">Debian<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></th>
<th style="text-align:center">Ubuntu<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/1.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/1.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/1.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/1-1.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/1-1.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/1-1.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<p>Depoyu ve anahtarı ekledikten sonra CrowdSec&rsquo;i aşağıdaki komutu çalıştırarak kurulumu yapabilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install crowdsec
</span></span></code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">Debian<sup id="fnref1:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></th>
<th style="text-align:center">Ubuntu<sup id="fnref1:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/2.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/2.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/2-1.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/2-1.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/2-1.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<h3 id="212-crowdseci-yapılandırın">2.1.2 CrowdSec&rsquo;i yapılandırın</h3>
<p>CrowdSec yüklendikten sonra ihtiyaçlarınıza göre yapılandırmanız gerekir. CrowdSec için ana yapılandırma dosyası <code>/etc/crowdsec/config.yaml</code> konumunda bulunur. Bu dosyayı nano veya vim gibi bir metin düzenleyici kullanarak düzenleyebilirsiniz.</p>
<p>Yapılandırma dosyası iyi yorumlanmıştır, bu nedenle her seçeneğin ne yaptığını anlamak kolaydır. CrowdSec tarafından kullanılan Bouncer ve Parserların yanı sıra log kaydı alma, engelleme ve bildirim seçeneklerini özelleştirebilirsiniz.</p>
<h3 id="213-crowdseci-başlatın">2.1.3 CrowdSec&rsquo;i Başlatın</h3>
<p>CrowdSec&rsquo;i yapılandırdıktan sonra, aşağıdaki komutu çalıştırarak hizmeti başlatabilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl start crowdsec
</span></span></code></pre></div><p>Aşağıdaki komutu çalıştırarak CrowdSec&rsquo;in durumunu kontrol edebilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status crowdsec
</span></span></code></pre></div><p>CrowdSec düzgün çalışıyorsa hizmetin etkin olduğunu belirten bir mesaj görmelisiniz.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/3.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/3.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/3.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Debian(3)</b></small></center>
</picture></p>
<h3 id="214-bir-linux-bouncer-kurun">2.1.4 Bir Linux Bouncer Kurun</h3>
<p>Linux Bouncer, sunucunuzu siber tehditlere karşı korumaya yardımcı olabilecek ek bir güvenlik katmanıdır. Bouncerlar, ağ trafiğini izleyerek ve bilinen kötü amaçlı IP adreslerinden gelen istekleri engelleyerek çalışır.</p>
<p>CrowdSec, iptables bouncer ve nftables bouncer dahil olmak üzere kurabileceğiniz birkaç bouncer ile birlikte gelir.</p>
<h4 id="iptables-bouncer-yüklemek-için-aşağıdaki-komutu-çalıştırın">Iptables Bouncer yüklemek için aşağıdaki komutu çalıştırın</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install crowdsec-firewall-bouncer
</span></span></code></pre></div><p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/4.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/4.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/4.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Ubuntu(4)</b></small></center>
</picture></p>
<h4 id="nftables-bouncer-yüklemek-için-aşağıdaki-komutu-çalıştırın">Nftables Bouncer yüklemek için aşağıdaki komutu çalıştırın</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt install crowdsec-nftables-bouncer
</span></span></code></pre></div><p>Bir bouncer kurduktan sonra onu CrowdSec ile çalışacak şekilde yapılandırmanız gerekir. bouncer için yapılandırma dosyası <code>/etc/crowdsec/bouncers.yaml</code> konumunda bulunur. Bu dosyayı nano veya vim gibi bir metin düzenleyici kullanarak düzenleyebilirsiniz.</p>
<p>Yapılandırma dosyası iyi yorumlanmıştır, bu nedenle her seçeneğin ne yaptığını anlamak kolaydır. CrowdSec tarafından kullanılan Bouncer ve Parserların yanı sıra günlüğe kaydetme, engelleme ve bildirim seçeneklerini özelleştirebilirsiniz.</p>
<h3 id="215-bouncerı-başlatın">2.1.5 Bouncer&rsquo;ı Başlatın</h3>
<p>bouncer yapılandırdıktan sonra, aşağıdaki komutu çalıştırarak hizmeti başlatabilirsiniz:</p>
<h4 id="iptables-için">Iptables için</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl start crowdsec-firewall-bouncer
</span></span></code></pre></div><p>Aşağıdaki komutu çalıştırarak bouncerların durumunu kontrol edebilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status crowdsec-firewall-bouncer
</span></span></code></pre></div><h4 id="nftables-için">Nftables için</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl start crowdsec-nftables-bouncer
</span></span></code></pre></div><p>Aşağıdaki komutu çalıştırarak bouncerların durumunu kontrol edebilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status crowdsec-nftables-b
</span></span></code></pre></div><p>Aşağıdaki komutu çalıştırarak CrowdSec&rsquo;in durumunu kontrol edebilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl status crowdsec
</span></span></code></pre></div><p>CrowdSec düzgün çalışıyorsa hizmetin etkin olduğunu belirten bir mesaj görmelisiniz.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/3.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/3.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/3.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Debian(3)</b></small></center>
</picture></p>
<h3 id="216-crowdseci-test-edin">2.1.6 CrowdSec&rsquo;i Test Edin</h3>
<p>CrowdSec&rsquo;in düzgün çalıştığını test etmek için sunucunuza farklı bir IP adresinden birkaç kez giriş yapmayı deneyebilirsiniz. Birkaç başarısız oturum açma denemesinden sonra CrowdSec, başarısız denemelerle ilişkili IP adresini bloke etmelidir.</p>
<p>Engellenen IP adreslerini aşağıdaki komutu çalıştırarak kontrol edebilirsiniz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo cscli alerts list
</span></span></code></pre></div><p>Bu komut size CrowdSec tarafından engellenen IP adreslerinin bir listesini gösterecektir.</p>
<h3 id="217-kısa-özet">2.1.7 Kısa Özet</h3>
<p>(TL;DR) <sup id="fnref1:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> CrowdSec&rsquo;i Linux sunucunuza yüklemek, sunucunuzu gerçek zamanlı olarak siber tehditlere karşı korumaya yardımcı olabilecek basit bir işlemdir. CrowdSec, yeni ve gelişmekte olan tehditleri algılamak için toplu zekayı kullanarak geleneksel güvenlik çözümlerinden daha yüksek düzeyde koruma sağlar. Bu gönderide belirtilen adımları izleyerek CrowdSec&rsquo;i Linux sunucunuza yükleyip yapılandırabilir ve dijital varlıklarınızı korumaya başlayabilirsiniz.</p>
<h1 id="3-crowdsec-nasıl-çalışır">3. CrowdSec Nasıl Çalışır?</h1>
<p>CrowdSec, toplu zeka kullanarak siber tehditlere karşı gerçek zamanlı koruma sağlayan, Linux sunucuları için açık kaynaklı bir güvenlik çözümüdür. Bu blog gönderisinde, CrowdSec&rsquo;in nasıl çalıştığını ve işleyişinde yer alan farklı bileşenleri tartışacağız.</p>
<h2 id="31-zararlı-trafiği-tespit-ve-işleme">3.1 Zararlı Trafiği Tespit ve İşleme</h2>
<p>CrowdSec, çeşitli kaynaklardan veri toplayarak, ilgili bilgileri çıkarmak için verileri ayrıştırarak ve olası tehditleri belirlemek için senaryolar uygulayarak çalışır. Bir tehdit belirlenirse, IP adresini bloke etmek veya bir bildirim göndermek gibi uygun eylem gerçekleştirilir.</p>
<p>CrowdSec, potansiyel tehditleri belirleme yeteneğini geliştirmek için toplu zekayı da kullanır. Bir tehdit belirlendiğinde, benzer tehditleri belirleme becerilerini geliştirmek için bilgiler diğer CrowdSec kullanıcılarıyla paylaşılır.</p>
<h3 id="311-data-sources">3.1.1 Data Sources</h3>
<p>CrowdSec, olası tehditleri belirlemek için çeşitli kaynaklardan veri toplar. Bu veri kaynakları, sistem günlüklerini, ağ trafiğini ve üçüncü taraf API&rsquo;leri içerir. Toplanan veriler daha sonra ilgili bilgileri çıkarmak için Parserlar tarafından işlenir.</p>
<h3 id="312-parsers">3.1.2 Parsers</h3>
<p>Parserlar, toplanan verilerden ilgili bilgileri çıkarmak için kullanılır. CrowdSec, sistem günlükleri, ağ trafiği ve üçüncü taraf API&rsquo;ler için yerleşik Parserlarla birlikte gelir. Ayrıca, diğer kaynaklardan bilgi ayıklamak için özel Parserlar oluşturabilirsiniz.</p>
<h3 id="313-scenarios">3.1.3 Scenarios</h3>
<p>Senaryolar, olası tehditleri belirlemeye yönelik kuralları tanımlamak için kullanılır. CrowdSec, kaba kuvvet saldırıları ve bağlantı noktası taraması gibi yaygın tehditler için yerleşik senaryolarla birlikte gelir. Ayrıca, ortamınızla ilgili belirli tehditleri belirlemek için özel senaryolar da oluşturabilirsiniz.</p>
<h3 id="314-collections">3.1.4 Collections</h3>
<p>Koleksiyonlar, benzer senaryoları birlikte gruplandırmak için kullanılır. Bu, senaryoların yönetimini ve dağıtımını basitleştirmeye yardımcı olur. CrowdSec, SSH ve HTTP gibi yaygın tehdit türleri için yerleşik koleksiyonlarla birlikte gelir. Senaryoları gerektiği gibi gruplandırmak için özel koleksiyonlar da oluşturabilirsiniz.</p>
<h3 id="315-kısa-özet">3.1.5 Kısa Özet</h3>
<p>(TL;DR) <sup id="fnref2:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> CrowdSec, siber tehditlere karşı gerçek zamanlı koruma sağlayan, Linux sunucuları için güçlü bir açık kaynaklı güvenlik çözümüdür. CrowdSec, çeşitli kaynaklardan veri toplayarak, verileri ayrıştırarak ve senaryolar uygulayarak potansiyel tehditleri belirleyebilir ve uygun önlemleri alabilir. Ek olarak, toplu zekanın kullanılması, CrowdSec&rsquo;in potansiyel tehditleri belirleme yeteneğini sürekli olarak geliştirmesine olanak tanıyarak onu herhangi bir Linux sunucusu için etkili bir güvenlik çözümü haline getirir.</p>
<h2 id="32-zararlı-trafiği-engelleme-yöntemleri">3.2 Zararlı Trafiği Engelleme Yöntemleri</h2>
<p>CrowdSec, siber tehditlere karşı gerçek zamanlı koruma sağlayan, Linux sunucuları için açık kaynaklı bir güvenlik çözümüdür. CrowdSec&rsquo;in temel özelliklerinden biri, yasaklama, captcha&rsquo;lar ve özel kararlar dahil olmak üzere çeşitli yöntemler kullanarak yasal olmayan trafiği önleme yeteneğidir. Bu blog gönderisinde, bu yöntemleri ve sunucunuzun güvenliğini artırmak için nasıl kullanılabileceğini ayrıntılı olarak tartışacağız.</p>
<h3 id="321-ban">3.2.1 Ban</h3>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/5-ban.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/5-ban.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/5-ban.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://tr.wordpress.org/plugins/crowdsec/ (Erişim Tarihi: 11.04.2023)</b></small></center>
</picture></p>
<p>Yasaklama, meşru olmayan trafiği önlemenin en basit yöntemidir. CrowdSec potansiyel bir tehdit belirlediğinde, daha fazla erişimi engellemek için rahatsız edici IP adresini engelleyebilir. Bu, IP adresini her yeni bağlantı kurulduğunda kontrol edilen bir kara listeye ekleyerek yapılır. Yasaklama, tekrarlayan suçluların sunucunuza erişmesini önlemenin etkili bir yoludur, ancak aynı zamanda yanlış pozitiflere yol açabilir ve meşru trafiği engelleyebilir.</p>
<h3 id="322-captcha">3.2.2 Captcha</h3>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/6-captcha.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/6-captcha.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/6-captcha.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://tr.wordpress.org/plugins/crowdsec/ (Erişim Tarihi: 11.04.2023)</b></small></center>
</picture></p>
<p>Captcha, otomatik botların sunucunuza erişmesini engellemek için yaygın olarak kullanılan bir yöntemdir. CrowdSec potansiyel bir tehdit belirlediğinde, kullanıcıya bir captcha sorgulaması sunabilir. Bu zorluk tipik olarak belirli görüntüleri tanımlamayı veya bir dizi karakter girmeyi içerir. Kullanıcı captcha sınamasını geçerse, sunucunuza erişebilir. Captcha, otomatik botların sunucunuza erişmesini önlemenin etkili bir yoludur, ancak gelişmiş botlar tarafından da atlanabilir.</p>
<h3 id="323-custom-decision">3.2.3 Custom Decision</h3>
<p>CrowdSec, belirli senaryolara göre özel kararlar almanıza da olanak tanır. Örneğin, sürekli olarak sunucunuza erişmeye çalışan bir IP adresi tespit ederseniz, bu IP adresinden gelecek tüm istekleri engellemeye karar verebilirsiniz. Alternatif olarak, kullanıcıyı farklı bir sayfaya yönlendirmeyi veya özel bir mesaj görüntülemeyi seçebilirsiniz. Özel kararlar, CrowdSec&rsquo;in yanıtını belirli senaryolara uyarlamanıza olanak tanıyarak sunucunuzun güvenliği üzerinde daha fazla kontrol sahibi olmanızı sağlar.</p>
<h3 id="323-kısa-özet">3.2.3 Kısa Özet</h3>
<p>(TL;DR) <sup id="fnref3:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> CrowdSec, siber tehditlere karşı gerçek zamanlı koruma sağlayan Linux sunucuları için güçlü bir güvenlik çözümüdür. CrowdSec, yasaklama, captcha&rsquo;lar ve özel kararlar gibi yöntemleri kullanarak meşru olmayan trafiği önleyebilir ve sunucunuzun güvenliğini artırabilir. İster küçük bir web sitesi ister büyük bir kurumsal uygulama çalıştırıyor olun, CrowdSec sunucunuzu siber tehditlere karşı korumanıza ve kullanıcılarınızın sitenize güvenli bir şekilde erişmesini sağlamanıza yardımcı olabilir.</p>
<h1 id="4-crowdsec-ile-tech-demo">4. Crowdsec İle Tech Demo</h1>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/kG68PgwOOeU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<blockquote>
<p><a href="https://www.youtube.com/watch?v=kG68PgwOOeU">https://www.youtube.com/watch?v=kG68PgwOOeU</a></p>
<p>Crowdsec Youtube Kanalı (Erişim Tarihi: 11.04.2023)</p>
</blockquote>
<p>Günümüzün dijital çağında, Dağıtılmış Hizmet Reddi (DDoS) saldırıları, işletmeler ve kuruluşlar için ortak bir tehdit haline geldi. Bu saldırılar, bir web sitesini veya uygulamayı trafikle doldurmak, trafiği bunaltmak ve meşru kullanıcılar için kullanılamaz hale getirmek için tasarlanmıştır. Önde gelen bir güvenlik çözümleri sağlayıcısı olan CrowdSec, yakın tarihli bir <a href="https://www.crowdsec.net/blog/how-to-beat-application-ddos">blog gönderisinde (Erişim Tarihi: 11.04.2023)</a>, uygulama DDoS saldırılarını yenmek için bazı etkili stratejiler paylaştı.</p>
<p>Blog gönderisi, kuruluşların karşılaşabileceği farklı uygulama DDoS saldırı türlerini açıklayarak başlıyor. Bunlar, HTTP/S Flood, Slow R/W Atağı (Slowloris) ve Application Layer Atak saldırılarını içerir. Her saldırı türü farklı bir yürütme yöntemine sahip olsa da, hepsi bir uygulamayı aşırı yükleyerek kullanıcılar tarafından kullanılamaz hale getirmeyi amaçlar.</p>
<p>Gönderi daha sonra uygulama DDoS saldırılarını yenmek için bazı etkili teknikleri açıklamaya devam ediyor. En önemli stratejilerden biri, kapsamlı bir DDoS koruma yazılımına sahip olmaktır. Bu, diğer önlemlerin yanı sıra güvenlik duvarlarının, izinsiz giriş tespit sistemlerinin (IDS), izinsiz giriş engelleme sisstemlerinin (IPS) ve yük dengeleyicilerin (Load Balancing) kurulmasını içerir.</p>
<p>Diğer bir etkili yaklaşım, İçerik Dağıtım Ağlarını (CDN&rsquo;ler) kullanmaktır. CDN&rsquo;ler, trafiği birden çok sunucu arasında dağıtmaya yardımcı olur ve bu da bir saldırının etkisini azaltmaya yardımcı olabilir. Ek olarak, CDN&rsquo;ler, meşru kullanıcılar için performansını iyileştirerek bir uygulamanın gecikmesini azaltmaya yardımcı olabilir.</p>
<p>Gönderi ayrıca hız sınırlayıcı tekniklerin uygulanmasını önerir. Bu, belirli bir zaman çerçevesi içinde bir uygulamaya gönderilebilecek trafik miktarına ilişkin sınırlar belirlemeyi içerir. Rate Limiting (Hız sınırlama), bir uygulamaya gönderilebilecek trafik miktarını sınırlayarak uygulama DDoS saldırılarını önlemeye yardımcı olabilir.</p>
<p>Son olarak gönderi, tüm yazılımları güncel tutmanızı önerir. Buna işletim sistemleri, web sunucuları ve uygulamalar dahildir. Yazılımı güncel tutmak, bilinen tüm güvenlik açıklarının yamalanmasını sağlamaya yardımcı olarak saldırı riskini azaltır.</p>
<p>Sonuç olarak, uygulama DDoS saldırıları, işletmeler ve kuruluşlar için önemli bir tehdit olabilir. Ancak doğru stratejiler uygulandığında bu saldırıları yenmek ve uygulamaları ve web sitelerini çevrimiçi tutmak mümkündür. Kuruluşlar, kapsamlı bir DDoS koruma planı uygulayarak, CDN&rsquo;leri kullanarak, hız sınırlayıcı teknikler uygulayarak ve yazılımları güncel tutarak, bir uygulama DDoS saldırısı riskini önemli ölçüde azaltabilir.</p>
<h2 id="41-beta-sürümü-ve-geleceği-hakkında">4.1 Beta Sürümü ve Geleceği Hakkında</h2>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/crowdsec-beta.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/crowdsec/crowdsec-beta.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/crowdsec/crowdsec-beta.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Crowdsec Beta Duyurusu (Erişim Tarihi: 11.04.2023)</b></small></center>
</picture></p>
<p>Crowdsec yazılımı yakın zaman önce v1.5 Beta sürümünü<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> kısıtlı kullanıma açtı. Kısıtlı test için yapmış olduğum başvuruyu kabul etmeleri sebebiyle kendilerine öncelikle teşekkür ediyorum. Mevcut trendlere ve siber güvenlik çözümlerine yönelik artan talebe dayanarak, Crowdsec yazılımının önümüzdeki yıllarda büyümeye ve popülerlik kazanmaya devam edeceğini tahmin ediyorum. Yazılımın, topluluk zekası ve makine öğrenimi algoritmalarını kullanarak tehdit algılama ve hafifletmeye yönelik benzersiz yaklaşımı, sektörde potansiyel olarak devrim yaratabilecek umut verici bir yeniliktir.</p>
<p>Ayrıca, açık kaynak topluluğundan gelen güçlü destek, Crowdsec&rsquo;in başarısının arkasındaki itici güç olmuştur. Yazılımın açık kaynak olması ve herkesin kullanması ve katkıda bulunması için ücretsiz olarak erişilebilir olması, yazılımı iyileştirmek ve geliştirmek için sürekli çalışan (ve Beta sürümünde olacağı gibi feedback veren) büyük ve özel bir kullanıcı ve geliştirici topluluğunun gelişmesine yardımcı olmuştur.</p>
<p>Daha fazla insan Crowdsec&rsquo;in yeteneklerinin farkına vardıkça ve bir açık kaynak projesine katkıda bulunmanın faydalarını gördükçe, bu topluluk desteğinin büyümeye ve güçlenmeye devam etmesini bekliyorum. Topluluğun geri bildirimleri ve katkıları, Crowdsec&rsquo;in siber güvenlik sektörünün ön saflarında kalmasını sağlayarak yeni özelliklerin ve iyileştirmelerin geliştirilmesine yardımcı olacaktır. Bu nedenle bir sonraki blog yazımda Crowdsec&rsquo;in Beta sürümünü inceleyip deneyimlerimi paylaşacağım.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://github.com/crowdsecurity/crowdsec/releases/tag/v1.4.6">https://github.com/crowdsecurity/crowdsec/releases/tag/v1.4.6</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>TL;DR: <code>Too long; Didn't read</code> veya <code>Çok uzundu; okumadım</code> özet geç anlamında&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref2:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref3:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://www.youtube.com/watch?v=7jwVkWt_4TI">https://www.youtube.com/watch?v=7jwVkWt_4TI</a> (Erişim Tarihi: 11.04.2023)&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://www.youtube.com/watch?v=2kW_200N60k">https://www.youtube.com/watch?v=2kW_200N60k</a> (Erişim Tarihi: 11.04.2023)&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://www.crowdsec.net/blog/crowdsec-v1-5-beta">https://www.crowdsec.net/blog/crowdsec-v1-5-beta</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>AdGuard ile Reklam Engelleme</title><link>https://wiseweb-works.github.io/blog/post/adguard-reklam-engelleme/</link><pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/adguard-reklam-engelleme/</guid><description>1. AdGuard: Reklamsız Gezinti İçin Nihai Çözümünüz İnternette gezinirken sürekli karşınıza çıkan reklam ve açılır pencerelerinden sıkıldıysanız, AdGuard Windows uygulamasını kullanmayı düşünebilirsiniz. AdGuard, yalnızca reklamları kaldırmakla kalmayıp aynı zamanda bilgisayarınızı kötü amaçlı yazılımlardan ve kimlik avı saldırılarından koruyan güçlü bir reklam engelleyicidir. Tanıdığınız ve bildiğiniz tüm reklamlara son kez sarılın artık onları bir daha göremeyeceksiniz. Çünkü bu blog gönderisinde, AdGuard&amp;rsquo;ın özelliklerini ve göz atma deneyiminizi nasıl geliştirebileceğini keşfedeceğiz.
1.1 AdGuard Uygulamasının Özellikleri 1.</description><content:encoded><![CDATA[<h1 id="1-adguard-reklamsız-gezinti-için-nihai-çözümünüz">1. AdGuard: Reklamsız Gezinti İçin Nihai Çözümünüz</h1>
<p>İnternette gezinirken sürekli karşınıza çıkan reklam ve açılır pencerelerinden sıkıldıysanız, <a href="https://adguard.com/tr/adguard-windows/overview.html">AdGuard Windows uygulamasını</a> kullanmayı düşünebilirsiniz. AdGuard, yalnızca reklamları kaldırmakla kalmayıp aynı zamanda bilgisayarınızı kötü amaçlı yazılımlardan ve kimlik avı saldırılarından koruyan güçlü bir reklam engelleyicidir. Tanıdığınız ve bildiğiniz tüm reklamlara son kez sarılın artık onları bir daha göremeyeceksiniz. Çünkü bu blog gönderisinde, AdGuard&rsquo;ın özelliklerini ve göz atma deneyiminizi nasıl geliştirebileceğini keşfedeceğiz.</p>
<h2 id="11-adguard-uygulamasının-özellikleri">1.1 AdGuard Uygulamasının Özellikleri</h2>
<h3 id="111-reklam-engelleyici">1.1.1 Reklam engelleyici</h3>
<ul>
<li>AdGuard&rsquo;ın birincil özelliği, banner reklamlar, açılır pencereler ve video reklamlar dahil olmak üzere her türlü reklamı<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> web sayfalarından kaldırabilen reklam engelleyicisidir. Bu özellik yalnızca gezinmeyi hızlandırmakla kalmaz, aynı zamanda verilerden tasarruf etmenizi sağlar ve göz yorgunluğunu azaltır.</li>
</ul>
<h3 id="112-gizlilik-koruması">1.1.2 Gizlilik koruması</h3>
<ul>
<li>AdGuard, web sitelerinin verilerinizi toplamak için kullandığı izleme çerezlerini ve diğer izleme mekanizmalarını engelleyerek gizliliğinizi korur. Ayrıca, IP adresinizi ve diğer hassas bilgileri web sitelerinden gizleyen Gizli mod adı verilen bir özelliği de vardır.</li>
</ul>
<h3 id="113-ebeveyn-kontrolü">1.1.3 Ebeveyn Kontrolü</h3>
<ul>
<li>AdGuard, yetişkinlere uygun içerik veya diğer uygunsuz materyaller barındıran web sitelerine erişimi engellemenizi sağlayan bir ebeveyn denetimi özelliğine sahiptir. Belirli web sitelerini veya kategorileri engellemek için özel kurallar da oluşturabilirsiniz.</li>
</ul>
<h3 id="114-malware-koruması">1.1.4 Malware koruması</h3>
<ul>
<li>AdGuard, kötü amaçlı kod veya bağlantılar içeren web sitelerini engelleyen yerleşik bir kötü amaçlı yazılımdan koruma özelliğine sahiptir. Ayrıca tehlikeli olduğu bildirilen bir web sitesini ziyaret ettiğinizde sizi uyarabilir.</li>
</ul>
<h3 id="115-özelleştirilebilir-filtreler">1.1.5 Özelleştirilebilir Filtreler</h3>
<ul>
<li>AdGuard, belirli içerik türlerini veya web sitelerini engellemek için kendi filtrelerinizi oluşturmanıza veya diğer kullanıcılardan filtreler eklemenize olanak tanır. Bu özellik, gördükleriniz ve görmedikleriniz üzerinde tam kontrol sahibi olmanızı sağlar.</li>
</ul>
<h3 id="116-kullanıcı-dostu-arayüz">1.1.6 Kullanıcı dostu arayüz</h3>
<ul>
<li>AdGuard, en acemi kullanıcılar için bile kullanımı kolaylaştıran basit ve sezgisel bir arayüze sahiptir. Tüm özelliklere ve ayarlara ana panodan kolayca erişebilirsiniz.</li>
</ul>
<h3 id="-117-kısa-özet">&gt; 1.1.7 Kısa Özet</h3>
<blockquote>
<p>(TL;DR)<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> AdGuard karşınıza çıkan reklamları engellerken aynı zamanda da kullanıcı dostu arayüzü ve özelleştirilebilir filtreleri sayesinde gizliliğinizi de korur. Ebeveyn kontrolü ve Malware koruması sayesinde ise istenmeyen sonuçlara karşı hazırlıklı olursunuz.</p>
</blockquote>
<h2 id="12-neden-adguardı-seçmelisiniz">1.2 Neden AdGuard&rsquo;ı Seçmelisiniz?</h2>
<p>AdGuard, gelişmiş özellikleri ve kullanımı kolay arayüzü nedeniyle Windows için mevcut olan en iyi reklam engelleyicilerden biridir. İşte AdGuard&rsquo;ı seçmeniz için bazı nedenler:</p>
<h3 id="121-kapsamlı-reklam-engelleme">1.2.1 Kapsamlı Reklam Engelleme</h3>
<ul>
<li>AdGuard, pop-up&rsquo;lar, video reklamlar ve banner reklamlar dahil her türlü reklamı<sup id="fnref1:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> engelleyerek tarama deneyiminizi daha akıcı ve hızlı hale getirebilir.</li>
</ul>
<h3 id="122-gelişmiş-gizlilik-koruması">1.2.2 Gelişmiş Gizlilik Koruması</h3>
<ul>
<li>AdGuard yalnızca reklamları engellemekle kalmaz, izleme çerezlerini engelleyerek ve IP adresinizi gizleyerek gizliliğinizi de korur.</li>
</ul>
<h3 id="123-malware-koruması">1.2.3 Malware koruması</h3>
<ul>
<li>AdGuard&rsquo;ın kötü amaçlı yazılımdan koruma özelliği, sizi kötü amaçlı web sitelerinden korur ve tehlikeli bir siteyi ziyaret ettiğinizde sizi uyarır.</li>
</ul>
<h3 id="124-özelleştirilebilir-filtreler">1.2.4 Özelleştirilebilir Filtreler</h3>
<ul>
<li>AdGuard&rsquo;ın özelleştirilebilir filtreleri, size hangi içeriği görüp neyi görmediğiniz konusunda tam kontrol sağlar.</li>
</ul>
<h3 id="125-kullanımı-kolay-arayüz">1.2.5 Kullanımı Kolay Arayüz</h3>
<ul>
<li>AdGuard&rsquo;ın kullanıcı dostu arayüzü, teknik uzmanlıkları ne olursa olsun tüm kullanıcılar için kullanımı kolaylaştırır.</li>
</ul>
<h3 id="-126-kısa-özet">&gt; 1.2.6 Kısa Özet</h3>
<blockquote>
<p>(TL;DR) <sup id="fnref1:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> AdGuard diğer reklam engelleme yazılımları ve çözümlerinden daha gelişmiş ve hızlı bir çözüme sahiptir. Ayrıca diğer yazılımlarda olmayan Malware koruması ve Gelişmiş Gizlilik özelliklerine de sahiptir.</p>
</blockquote>
<hr>
<h1 id="2-adguard-windows-uygulaması-nasıl-kurulur">2. AdGuard Windows Uygulaması Nasıl Kurulur</h1>
<p>AdGuard, bilgisayarınızı kötü amaçlı yazılımlardan ve kimlik avı saldırılarından koruyabilen ve aynı zamanda web sayfalarından her türlü reklamı<sup id="fnref2:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> kaldırabilen güçlü bir reklam engelleyicidir. Reklamsız bir tarama deneyimi yaşamak istiyorsanız, AdGuard&rsquo;ı Windows PC&rsquo;nize yüklemek kolay ve kolaydır. Bu blog gönderisinde, AdGuard&rsquo;ı Windows PC&rsquo;nize yükleme adımlarında size rehberlik edeceğiz.</p>
<h2 id="21-adım-adım-kılavuz">2.1 Adım Adım Kılavuz</h2>
<h3 id="211-adguard-yükleyiciyi-indirin">2.1.1 AdGuard Yükleyiciyi İndirin</h3>
<p>AdGuard&rsquo;ı Windows PC&rsquo;nize kurmanın ilk adımı, AdGuard yükleyicisini resmi web sitesinden indirmektir. AdGuard web sitesindeki &ldquo;İndir&rdquo; düğmesine tıklayarak yükleyiciyi indirebilirsiniz.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/1.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/1.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/1.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://adguard.com/tr/adguard-windows/overview.html (Erişim Tarihi 07.04.2023)</b></small></center>
</picture></p>
<h3 id="212-yükleyiciyi-çalıştırın">2.1.2 Yükleyiciyi Çalıştırın</h3>
<p>AdGuard yükleyicisini indirdikten sonra, PC&rsquo;nizde dosyayı bulun ve yükleyiciyi çalıştırmak için üzerine çift tıklayın. Kullanıcı Hesabı Denetimi (UAC) tarafından istenirse, yükleyiciye PC&rsquo;nizde değişiklik yapması için izin vermeniz gerekebilir.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Adguard Windows uygulaması yükleyici görüntüleri</b></small></center>
</picture></p>
<h3 id="213-kurulum-seçeneklerini-seçin">2.1.3 Kurulum Seçeneklerini Seçin</h3>
<p>Bir sonraki adım, AdGuard için kurulum seçeneklerini seçmektir. AdGuard&rsquo;ı tüm kullanıcılar için veya yalnızca mevcut kullanıcı için yüklemeyi seçebilirsiniz. Ayrıca kurulum klasörünü seçebilir ve bir masaüstü kısayolu oluşturabilirsiniz.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/3.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/3.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/3.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Adguard Windows uygulaması kurulum seçenekleri</b></small></center>
</picture></p>
<h3 id="214-adguardı-yükleyin">2.1.4 AdGuard&rsquo;ı yükleyin</h3>
<p>Kurulum seçeneklerini seçtikten sonra, kurulum sürecini başlatmak için &ldquo;Yükle&rdquo; düğmesine tıklayın. Yükleme işlemi bilgisayarınızın hızına bağlı olarak birkaç dakika sürebilir.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/4.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/4.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/4.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Adguard Windows uygulaması kurulum görüntüleri</b></small></center>
</picture></p>
<h3 id="215-adguardı-başlatın">2.1.5 AdGuard&rsquo;ı başlatın</h3>
<p>Yükleme tamamlandıktan sonra, AdGuard&rsquo;ı masaüstü kısayolundan veya Başlat menüsünden başlatabilirsiniz. AdGuard&rsquo;ı ilk kez başlattığınızda, ayarları tercihlerinize göre yapılandırmanızı isteyecektir.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/5.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/5.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/5.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Adguard Windows uygulaması genel ayarları</b></small></center>
</picture></p>
<h3 id="216-reklamsız-taramanın-keyfini-çıkarın">2.1.6 Reklamsız Taramanın Keyfini Çıkarın</h3>
<p>AdGuard&rsquo;ın ayarlarını yapılandırdıktan sonra, reklamsız bir göz atma deneyiminin keyfini çıkarabilirsiniz. AdGuard, web sayfalarından her türlü reklamı<sup id="fnref3:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> otomatik olarak kaldırarak gezinmenizi daha hızlı ve sorunsuz hale getirir.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/6.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/6.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/6.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.youtube.com/watch?v=YW9Ojcm1Gkg (Erişim Tarihi 07.04.2023)</b></small></center>
</picture></p>
<h3 id="-217-kısa-özet">&gt; 2.1.7 Kısa Özet</h3>
<blockquote>
<p>Sistem admini iseniz veya herhangi bir ayar ile uğraşmaadan direk kurmak istiyorsanız <code>Msiexec /q /i AdGuard.msi</code> komutunu kullanabilirsiniz.</p>
<p>Alternatif olarak da halk arasında &ldquo;Next &gt; Next &gt; Next&rdquo; tabir edilen yöntemi kullanabilirsiniz. Yani <code>kapattım gözlerimi karanlığa, açtım ellerimi sonsuzluğa, rabbim sonum hayrola :D</code> diyerek her gelen sayfada hiçbir şeyi okumadan İleri/Next butonuna tıklayarak çok hızlı bir şekilde kurabilirsiniz.</p>
</blockquote>
<hr>
<h1 id="3-adguard-nasıl-çalışıyor">3. AdGuard Nasıl Çalışıyor?</h1>
<p>AdGuard, dünya çapında milyonlarca kullanıcının güvendiği güçlü bir reklam engelleyicidir. Reklamları engelleme yollarından biri, DNS tabanlı engelleme teknikleri kullanmaktır. Bu blog gönderisinde, AdGuard&rsquo;ın DNS, DNS-over-HTTPS (DoH) ve diğer teknikleri kullanarak reklamları nasıl engellediğini keşfedeceğiz.</p>
<h2 id="31-dns-tabanlı-engelleme">3.1 DNS Tabanlı Engelleme</h2>
<p>DNS tabanlı engelleme, AdGuard tarafından reklamları DNS isteklerini kara listeye alınmış bir IP adresine yönlendirerek engellemek için kullanılan bir tekniktir. Bir web sitesini ziyaret ettiğinizde, tarayıcınız, web sitesinin alan adını bir IP adresine çevirmek için bir DNS sunucusuna bir DNS isteği gönderir. AdGuard bu isteği yakalar ve kara listesine göre kontrol eder. Alan kara listedeyse AdGuard, isteği kara listedeki bir IP adresine yönlendirerek reklamın ekranınızda görüntülenmesini etkili bir şekilde engeller.</p>
<p>DNS filtresi, reklamları daha bilgisayarınıza yüklenmelerine fırsat vermeden engelleyerek zamandan ve bant genişliğinden tasarruf etmenizi sağladığı için oldukça etkilidir. AdGuard&rsquo;ın DNS filtresi de son derece özelleştirilebilir olup, kullanıcıların gerektiğinde belirli alanları beyaz listeye veya kara listeye almasına olanak tanır. DNS tabanlı engelleme, reklamları engellemenin basit ve etkili bir yoludur, ancak bazı sınırlamaları vardır. Örneğin, bazı reklamlar, standart olmayan bağlantı noktaları veya şifreli bağlantılar kullanarak DNS engellemesini atlayabilir.</p>
<h2 id="32-https-filtresi">3.2 HTTPS filtresi</h2>
<p>HTTPS filtresi, AdGuard&rsquo;ın bir başka önemli özelliğidir ve HTTPS şifrelemesi kullanan web sitelerindeki istenmeyen içeriği filtreleyerek çalışır. Birçok reklam engelleme aracı, şifreleme web sitesinin içeriğini görmelerini engellediği için HTTPS web sitelerindeki reklamları engellemekte zorlanır. Ancak, AdGuard&rsquo;ın HTTPS filtresi, web sitesinin içeriğinin şifresini çözebilir ve istenmeyen reklamları veya diğer içeriği filtreleyebilir.</p>
<p>HTTPS filtresi, daha fazla web sitesi gelişmiş güvenlik için HTTPS&rsquo;ye geçtikçe giderek yaygınlaşan HTTPS şifrelemesi kullanan web sitelerindeki reklamları engellemede oldukça etkilidir. AdGuard&rsquo;ın HTTPS filtresi de son derece özelleştirilebilir ve kullanıcıların belirli web sitelerini veya etki alanlarını beyaz veya kara listeye almasına olanak tanır.</p>
<h2 id="33-içerik-filtresi">3.3 İçerik filtresi</h2>
<p>İçerik filtresi, AdGuard&rsquo;ın bir diğer önemli özelliğidir ve web sitelerindeki istenmeyen içeriği filtreleyerek çalışır. Buna, kullanıcıların dikkatini dağıtabilecek veya rahatsız edebilecek reklamlar, açılır pencereler, Cookie (Çerez) uyarı bildirimleri, afişler ve diğer istenmeyen içerik türleri dahildir.</p>
<p>İçerik filtresi, tüm etki alanlarını veya IP adreslerini engellemek yerine bir web sitesindeki belirli öğeleri hedef aldığı için oldukça etkilidir. Bu, kullanıcıların istenmeyen içerikle bombardımana tutulmadan daha akıcı bir tarama deneyiminin keyfini çıkarmasına olanak tanır. AdGuard&rsquo;ın İçerik filtresi de son derece özelleştirilebilir ve kullanıcıların belirli web sitelerini veya etki alanlarını beyaz veya kara listeye almasına olanak tanır.</p>
<h2 id="-34-kısa-özet">&gt; 3.4 Kısa Özet</h2>
<blockquote>
<p>(TL;DR) <sup id="fnref2:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> 
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/adguard-nasil-calisir.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/adguard-nasil-calisir.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/adguard-nasil-calisir.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://adguard.com/tr/adguard-windows/overview.html (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
</blockquote>
<hr>
<h1 id="4-dns-ile-ilgili-gelişmiş-ayalar">4. DNS ile ilgili Gelişmiş Ayalar</h1>
<p>DNS (Alan Adı Sistemi), insanlar tarafından okunabilen alan adlarını bilgisayarların anlayabileceği IP adreslerine çevirmek için kullanılan bir protokoldür. Ancak, DNS sorguları normal olarak 53 numaralı port üzerinden gönderilir ve herhangi bir şifreleme yapılmaz. Dolayısıyla varsayılan olarak güvenli değildir ve DNS sorguları saldırganlar tarafından ele geçirilebilir veya manipüle edilebilir.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/Unsecured-DNS.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/Unsecured-DNS.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/Unsecured-DNS.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://blog.chromium.org/2020/05/a-safer-and-more-private-browsing-DoH.html (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<p>Bu sorunu çözmek için HTTPS üzerinden DNS (DoH), TLS üzerinden DNS (DoT), QUIC üzerinden DNS (DoQ) ve DNSCrypt dahil olmak üzere birkaç yeni protokol geliştirilmiştir. Blog gönderisinin bu kısmında, bu protokoller arasındaki farkları ve DNS sorgularınızı korumaya nasıl yardımcı olabileceklerini tartışacağız. DNS-over-HTTPS (DoH), DNS-over-TLS (DoT), DNS-over-QUIC (DoQ) ve DNSCrypt birçok avantaj sağlarken, dikkate alınması gereken bazı potansiyel dezavantajlar da vardır. <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<h2 id="41-https-üzerinden-dns-doh">4.1 HTTPS üzerinden DNS (DoH)</h2>
<p>DNS-over-HTTPS (DoH), HTTPS protokolünü kullanarak DNS sorgularını şifreleyen bir protokoldür. DoH, üçüncü tarafların DNS sorgularına müdahale etmesini ve kurcalamasını önleyerek gizliliği ve güvenliği artırmak için tasarlanmıştır. DoH ile, DNS sorguları şifrelenmiş bir kanal üzerinden gönderilerek saldırganların bunları yakalamasını ve manipüle etmesini zorlaştırır.</p>
<p>DoH, Firefox, Chrome ve Edge dahil olmak üzere birçok büyük web tarayıcısı tarafından desteklenir. Bir DoH uygulaması yükleyerek veya cihazınızı bir DoH sunucusu kullanacak şekilde yapılandırarak mobil cihazlarda da kullanılabilir.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-HTTPS.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-HTTPS.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-HTTPS.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://blog.chromium.org/2020/05/a-safer-and-more-private-browsing-DoH.html (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<ul>
<li>
<h3 id="411-dezavantajları">4.1.1 Dezavantajları</h3>
<ul>
<li>
<p>DoH&rsquo;nin bir dezavantajı, belirli ortamlarda uygulanmasının zor olabilmesidir. Örneğin DoH, bazı güvenlik duvarları veya internet servis sağlayıcıları tarafından engellenebilir ve bu da kullanımını zorlaştırabilir. Ek olarak, bazı ağ yöneticileri, ağ trafiğini izlemeyi ve denetlemeyi zorlaştırabileceğinden, şifrelenmiş DNS sorgularına izin vermek istemeyebilir.</p>
</li>
<li>
<p>DoH ile ilgili bir başka olası sorun, gecikmeyi artırabilmesi ve DNS sorgularını yavaşlatabilmesidir. Bunun nedeni, DoH sorgularının, geleneksel bir DNS sorgusundan daha fazla ek yük gerektiren bir HTTPS bağlantısı üzerinden gönderilmesidir. Bu, çoğu kullanıcı için fark edilmese de, çevrimiçi oyunlar veya gerçek zamanlı video konferans gibi düşük gecikmeli DNS sorguları gerektiren uygulamalar için bir sorun olabilir.</p>
</li>
</ul>
</li>
</ul>
<h2 id="42-tls-üzerinden-dns-dot">4.2 TLS üzerinden DNS (DoT)</h2>
<p>DNS-over-TLS (DoT), DNS sorgularını şifreleyen başka bir protokoldür, ancak HTTPS yerine Aktarım Katmanı Güvenliği (TLS) protokolünü kullanır. DoT, DoH ile benzer güvenlik avantajları sağlar, ancak yaygın olarak desteklenmez.</p>
<p>DoT&rsquo;yi kullanmak için cihazınızı bir DoT sunucusu kullanacak şekilde yapılandırmanız gerekir. DoT, Cloudflare, Quad9 ve Google dahil olmak üzere birkaç DNS sunucusu tarafından desteklenir.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-TLS.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-TLS.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-TLS.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.myrasecurity.com/de/knowledge-hub/dns-over-tls (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<ul>
<li>
<h3 id="421-dezavantajları">4.2.1 Dezavantajları</h3>
<ul>
<li>
<p>DoH gibi, DoT da güvenlik duvarları veya internet servis sağlayıcıları tarafından engellenebilir. Bu, özellikle ağ yöneticilerinin şifreli DNS sorgularına izin vermek istemediği ortamlarda kullanımı zorlaştırabilir.</p>
</li>
<li>
<p>DoT ile ilgili bir başka olası sorun, güvenlik duvarında açık olmak için özel bir bağlantı noktası (853 numaralı bağlantı noktası) gerektirmesidir. Güvenlik duvarı özellikle izin verilenler dışındaki tüm bağlantı noktalarını engelleyecek şekilde yapılandırılmışsa bu sorun olabilir.</p>
</li>
</ul>
</li>
</ul>
<h2 id="43-quic-üzerinden-dns-doq">4.3 QUIC üzerinden DNS (DoQ)</h2>
<p>DNS-over-QUIC (DoQ), QUIC protokolünü kullanarak DNS sorgularını şifreleyen yeni bir protokoldür. DoQ hala geliştirme aşamasındadır, ancak DoH veya DoT&rsquo;den daha hızlı ve daha güvenli DNS sorguları sağlama potansiyeline sahiptir.</p>
<p>DoQ, gecikmeyi azaltan ve performansı artıran TCP yerine UDP kullanır. Ayrıca, bir DNS sunucusuyla bağlantı kurmak için gereken süreyi azaltabilen sıfır RTT anlaşmalarını da destekler.</p>
<ul>
<li>
<h3 id="431-dezavantajları">4.3.1 Dezavantajları</h3>
<ul>
<li>
<p>DoQ nispeten yeni bir protokoldür ve şu anda onu destekleyen yalnızca birkaç DNS sunucusu vardır. Bu, özellikle DoQ&rsquo;yu desteklemeyen belirli bir DNS sunucusu kullanmanız gerekiyorsa, kullanımı zorlaştırabilir.</p>
</li>
<li>
<p>DoQ ile ilgili bir başka olası sorun, hala geliştirme aşamasında olması ve çözülmesi gereken hatalar veya uyumluluk sorunları olabilmesidir. Bu, daha yavaş performansa veya başka sorunlara neden olabilir.</p>
</li>
</ul>
</li>
</ul>
<h2 id="44-dnscrypt">4.4 DNSCrypt</h2>
<p>DNSCrypt, DNS sorgularını ve yanıtlarını açık anahtarlı şifreleme kullanarak şifreleyen bir protokoldür. DNSCrypt, DNS sahtekarlığını ve ortadaki adam saldırılarını önlemek için tasarlanmıştır.</p>
<p>DNSCrypt ile, DNS sorguları bir ortak anahtar kullanılarak şifrelenir ve sunucu, ortak anahtar kullanılarak doğrulanabilen imzalı bir yanıtla yanıt verir. Bu, saldırganların DNS sorgularını ve yanıtlarını yakalamasını ve manipüle etmesini önler.</p>
<p>DNSCrypt, OpenDNS ve Cloudflare dahil olmak üzere birkaç DNS sunucusu tarafından desteklenir. Ayrıca, dnscrypt-proxy ve Simple DNSCrypt dahil olmak üzere birkaç DNS istemcisiyle birlikte kullanılabilir.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-crypt.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-crypt.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/DNS-crypt.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://dev.to/cipherops/using-dnscrypt-with-adguard-home-pi-hole-7j6 (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<ul>
<li>
<h3 id="441-dezavantajları">4.4.1 Dezavantajları</h3>
<ul>
<li>
<p>DNSCrypt&rsquo;in olası bir dezavantajı, hem istemcinin hem de sunucunun protokolü desteklemesini gerektirmesidir. DNSCrypt birkaç DNS sunucusu ve istemcisi tarafından desteklenirken, DoH veya DoT kadar yaygın olarak desteklenmez. Bu, özellikle DNSCrypt&rsquo;i desteklemeyen belirli bir DNS sunucusu kullanmanız gerekiyorsa, kullanımı zorlaştırabilir.</p>
</li>
<li>
<p>DNSCrypt ile ilgili bir başka olası sorun, gecikmeyi artırabilmesi ve DNS sorgularını yavaşlatabilmesidir. Bunun nedeni, DNSCrypt sorgularının, geleneksel bir DNS sorgusundan daha fazla ek yük gerektiren açık anahtarlı şifreleme kullanılarak şifrelenmesidir</p>
</li>
</ul>
</li>
</ul>
<h2 id="-45-kısa-özet">&gt; 4.5 Kısa Özet</h2>
<blockquote>
<p>(TL;DR) <sup id="fnref3:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> DNS-over-HTTPS, DNS-over-TLS, DNS-over-QUIC ve DNSCrypt birçok avantaj sağlarken, dikkate alınması gereken potansiyel dezavantajları da vardır. Bu protokoller, güvenlik duvarları veya internet servis sağlayıcıları tarafından engellenebilir ve gecikmeyi artırabilir veya DNS sorgularını yavaşlatabilir. Bu protokollerden herhangi birini kullanmadan önce, olası dezavantajları göz önünde bulundurmak ve ek güvenlik ve gizlilik avantajlarına değip değmeyeceğini belirlemek önemlidir. Ek olarak, tüm sunucular tüm protokolleri desteklemediğinden, kullandığınız DNS sunucusunun kullanmak istediğiniz protokolü desteklediğinden emin olmanız önemlidir. Seçtiğiniz protokol ne olursa olsun, güvenli bir DNS sunucusu kullanmak çevrimiçi gizliliğinizi ve güvenliğinizi korumada önemli bir adımdır. DNS sorgularınızın şifreli ve güvenli olduğundan emin olmak için bu protokollerden birini kullanmayı düşünün. 
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-TLDR.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-TLDR.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/DNS-over-TLDR.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.researchgate.net/profile/Minzhao-Lyu/publication/357587121 (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
</blockquote>
<hr>
<h1 id="5-daha-ileri-gizlilik-için">5. Daha İleri Gizlilik İçin</h1>
<p>DNSSEC, EDNS İstemci Alt Ağı (ECS), Şifreli SNI (Encrypted SNI) ve Şifreli İstemci Merhaba (Encrypted Client Hello), internette güvenliği ve gizliliği geliştirmeye yardımcı olan önemli teknolojilerdir. Blog gönderimizin bu kısmında, söz konusu teknolojilerin her birine daha yakından bakacağız <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> ve faydalarını keşfedeceğiz.</p>
<h2 id="51-dnssec">5.1 DNSSEC</h2>
<p>DNSSEC, DNS sızdırma saldırılarını önlemek için tasarlanmış bir güvenlik protokolüdür. DNS sahtekarlığı, bir bilgisayar korsanı bir DNS sorgusunu yakaladığında ve istenen etki alanının IP adresini kötü amaçlı bir IP adresiyle değiştirdiğinde gerçekleşir. DNSSEC, DNS yanıtlarının gerçekliğini doğrulamak ve kullanıcıların doğru web sitesine yönlendirilmesini sağlamak için kriptografik imzalar kullanır.</p>
<p>DNSSEC, her DNS kaydına, yanıta güvenmeden önce istekte bulunan cihaz tarafından doğrulanan bir dijital imza ekleyerek çalışır. DNSSEC ayrıca, orijinalliklerini doğrulamak için kullanılabilecek DNS kayıtları için ortak anahtarları dağıtmak için bir mekanizma sağlar.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNSSEC.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/DNSSEC.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/DNSSEC.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.dk-hostmaster.dk/en/dnssec (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<h2 id="52-edns-istemci-alt-ağı-ecs">5.2 EDNS İstemci Alt Ağı (ECS)</h2>
<p>EDNS İstemci Alt Ağı, DNS sunucularının istemcinin IP adresi hakkında bilgi almasına izin veren DNS protokolünün bir uzantısıdır. Bu bilgiler, DNS sorgularına daha doğru yanıtlar sağlamak için kullanılır ve DNS çözümleme sürecinin hızını ve güvenilirliğini artırmaya yardımcı olabilir.</p>
<p>EDNS İstemci Alt Ağı ile DNS sunucuları, istekte bulunan cihazın coğrafi konumunu belirleyebilir ve bu konum için optimize edilmiş bir yanıt sağlayabilir. Bu, gecikmeyi azaltmaya ve internetin genel performansını iyileştirmeye yardımcı olabilir.</p>
<h2 id="53-şifreli-sni-encrypted-sni">5.3 Şifreli SNI (Encrypted SNI)</h2>
<p>Şifreli SNI (Server Name Indicator), TLS el sıkışma işleminde SNI alanını şifreleyen bir teknolojidir. SNI alanı, istemcinin bağlanmak istediği sunucunun ana bilgisayar adını belirlemek için kullanılır. Şifreli SNI, bu alanı şifreleyerek gizli dinleme ve ortadaki adam saldırılarını önlemeye yardımcı olur.</p>
<p>Şifreli SNI, önemli bir gizlilik özelliğidir çünkü SNI alanı bir kullanıcının çevrimiçi etkinliğini izlemek için kullanılabilir. Şifreleme olmadan, ISP&rsquo;ler, hükümetler ve diğer üçüncü tarafların SNI bilgilerine müdahale etmesi ve kullanıcı gizliliğini tehlikeye atarak izlemesi mümkündür.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/ESNI.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/ESNI.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/ESNI.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://blog.cloudflare.com/encrypted-client-hello (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<h2 id="54-şifreli-istemci-merhaba-encrypted-client-hello">5.4 Şifreli İstemci Merhaba (Encrypted Client Hello)</h2>
<p>Encrypted Client Hello, TLS anlaşma sürecinin gizliliğini ve güvenliğini artırmaya yardımcı olan başka bir teknolojidir. İstemci Merhaba mesajı, TLS bağlantısını başlatmak için istemci tarafından gönderilir ve istemcinin desteklediği TLS sürümleri ve şifre paketleri hakkında bilgi içerir.</p>
<p>Encrypted Client Hello, İstemci Merhaba mesajını şifreleyerek, gizli dinleme ve ortadaki adam saldırılarını önlemeye yardımcı olur. Ayrıca, üçüncü tarafların Müşteri Merhaba mesajını ele geçirmesini ve analiz etmesini önleyerek kullanıcı gizliliğinin korunmasına yardımcı olur.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/ECH.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/adguard/ECH.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/adguard/ECH.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://blog.cloudflare.com/encrypted-client-hello (Erişim Tarihi: 07.04.2023)</b></small></center>
</picture></p>
<p>Çözüm
DNSSEC, EDNS İstemci Alt Ağı, Şifreli SNI ve Şifreli İstemci Hello, internette güvenliği ve gizliliği geliştirmeye yardımcı olan önemli teknolojilerdir. Bu teknolojiler, DNS sahtekarlığı saldırılarını önlemek, daha doğru DNS yanıtları sağlamak ve TLS el sıkışma işlemi sırasında kullanıcı gizliliğini korumak için tasarlanmıştır. Bu teknolojileri uygulayarak herkes için daha güvenli ve güvenli bir internet oluşturmaya yardımcı olabiliriz.</p>
<hr>
<h1 id="6-sonuç">6. Sonuç</h1>
<p>(TL;DR) İnternette gezinirken karşınıza çıkan reklamlardan sıkıldıysanız, AdGuard reklamları engellemek için mükemmel bir seçimdir. Gelişmiş özellikleri ve özelleştirilebilir filtreleri, size hangi içeriği görüp neyi görmediğiniz üzerinde tam kontrol sağlar. AdGuard&rsquo;ı bugün indirin ve daha hızlı, daha güvenli ve daha keyifli bir tarama deneyiminin keyfini çıkarın.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><code>Contextual Advertising</code>, <code>Analytics Tools</code>, <code>Banner Advertising</code>, <code>Error Monitoring</code>, <code>Cookie Consent Notification</code>, <code>Youtube Ads</code> ve <code>Message Box</code>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref2:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref3:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>TL;DR: <code>Too long; Didn't read</code> veya <code>Çok uzundu; okumadım</code> özet geç anlamında&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref1:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref2:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a>&#160;<a href="#fnref3:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Büyük güç büyük sorumluluk getirir. -Örümcek Adam&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>Dikkatli bakıyor musunuz? -Prestige <a href="https://www.youtube.com/watch?v=C6MlffsLfkM">Youtube</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>OpenVPN Derinlemesine Anlatım</title><link>https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/</link><pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/openvpn-full-anlatim/</guid><description>Giriş ve Özet Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN&amp;rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak.</description><content:encoded><![CDATA[<h1 id="giriş-ve-özet">Giriş ve Özet</h1>
<p>Bugün sizlerle kendi bence son zamanların en önemli yazılımlarından olan OpenVPN ile ilgili derinlemesine bir inceleme yapacağız. Bu incelememizde öncelikle OpenVPN&rsquo;in ne için kullanıldığından bahsedeceğiz. Ardından programı çalıştırmak için nelere ihtiyaç duyduğumuzu ve ilk çalıştırma öncesi yapılması gerekenleri inceleyeceğiz. Son olarak da bağlantının başlatıldığı ilk andan verinin çözüldüğü son adıma kadar nelerin arka planda döndüğünü anlatmaya çalışacağım. Dolayısıyla yazımız tahminimce 3 bölüm ve gerekirse bir de soru-cevap bölümünden oluşacak. Şimdi kemerlerimizi bağlayalım ve internetin derin ve kasvetli dünyasında bir geziye çıkalım.</p>
<h2 id="openvpn-nedir-ve-ne-için-kullanılıyor-">OpenVPN nedir ve ne için kullanılıyor ?</h2>
<p>Günümüzde artık internet üzerinden yapılmayan bir iş neredeyse kalmadı. Hatta normalde internet üzerinden olmayan çalışma eylemimiz bile pandemi ve yeni normal nedeniyle evden çalışmaya doğru evrildi. Fakat hem alışık olmadığımız bir çalışma yöntemi olması nedeniyle hem de insanlarımızın teknoloji ile arasının pek iyi olmaması nedeniyle büyük sorunlar yaşandı. İnsanların evlerindeki bilgisayarlardan ofisteki bilgisayarlarına bağlanması gerektiği anlaşılmadan önce bazı firmalar çalışanların evlerine ofis bilgisayarlarını gönderme gibi uçuk fikirler buldu. Bunun ne kadar hatalı bir gidiş yolu olduğunu kısa süre içinde aldıkları geri dönüşlerden çok iyi anladılar. Kısaca elektronik cihazların ofiste kalması ve bir şekilde uzaktan güvenli ve sürdürülebilir bir bağlantı yapılması gerektiği sonunda kabullenildi. Kurumlar daha önceleri de kendilerini böyle ihtiyaçlar içinde buluyordu elbette ama bu derece büyük ölçekli bir durum söz konusu değildi o zamanlar. Pandemi öncesinde PPTP, L2TP, IPSec, IKev2, SSTP ve nihayet OpenVPN gibi çeşitli protokoller kullanıyordu. Bunlar genelde belirli uzun ve havalı kelimelerin kısaltması olup temel mantıkları iki veya daha fazla cihazı birbirine bağlamak ve aynı ağdaymış gibi hareket etmelerini sağlamak üzerinedir. OpenVPN&rsquo;den önceki protokoller belirli zayıflıkları, yavaşlıkları ve uygulanmasıyla ilgili teknik zorlukları da beraberlerinde getirdikleri için çok bahsetmeyeceğim. OpenVPN sunucu ve istemci rolündeki en az 2 cihazın birbirlerine bağlanması ve  bunu endüstiri standartlarını karşılayacak şekilde yapmasına yarayan protokol ve programın adıdır. Ben uzak masaüstü programı kullanıyorum buna ne gerek var dediğinizi duyar gibiyim. Maalesef o ve onun gibi diğer tüm programlar temelde bu protokolü kullanmak durumunda kalıyorlar. En meşhurlarından olan TeamViewer programında kalkan simgesine veya bağlantı ayrıntılarına bastığınız takdirde OpenVPN protokolünü görebilirsiniz.</p>
<h2 id="openvpn-bağlantısı-kurmak-için-nelere-ihtiyaç-duyarız-">OpenVPN bağlantısı kurmak için nelere ihtiyaç duyarız ?</h2>
<p>Öncelikle hem sunucu hem de istemci (bağlanacak cihaz) tarafında OpenVPN&rsquo;in kurulu olması gerekiyor. Ardından cihazların hangi şartlar altında iletişim kuracaklarını gösterir bir ayar (config) dosyasının düzenlenmesi gerekmektedir. Asıl olay zaten bu config dosyasının üretilmesi ve istemci tarafından kullanılmasıdır. Bu config dosyası sunucu tarafından kullanılan server_config ve istemci tarafından kullanılan client_config olarak ikiye ayrılır.</p>
<h3 id="server-tarafında-tutulan-ayar-dosyası-şu-girdileri-içermektedir">Server tarafında tutulan ayar dosyası şu girdileri içermektedir</h3>
<ul>
<li><code>port 1194</code> OpenVPN bağlantısını yapmak için kendisine hangi port üzerinden bağlantı talebi geleceğini belirtir.</li>
<li><code>proto tcp</code> Bağlantının TCP veya UDP üzerinden yapılması mümkün. Seçim için girilen ayar girdisi.</li>
<li><code>dev tun</code> TAP veya TUN arabirimi kullanılabilir. Bunlar sanal arabirimlerdir. TAP layer 2 bir bağlantı kurarken TUN layer 3 bir bağlantı kurar.</li>
<li><code>user nobody</code> Bağlanan kullanıcıların sunucu üzerinde yetkisiz bir kullanıcıya linklenmesini sağlıyor.</li>
<li><code>group $NOGROUP</code> Bağlanan kullanıcıların sunucu üzerinde grup olarak da yetkisiz bir gruba linklenmesini sağlıyor.</li>
<li><code>persist-key</code> Sanal arabirimin oluşturulması ve yeniden başlatılması ile ilgili bir yetkilendirme ayarı</li>
<li><code>persist-tun</code> Yine aynı şekilde sanal arabirimin oluşturulması ve yeniden başlatılması ile ilgili bir yetkilendirme ayarı</li>
<li><code>keepalive 10 120</code> Kaç adet bağlantının aktif tutulacağını ve ne kadar süre iletişim kurulmaz ise aktif bağlantının sonlandırılacağı ile ilgili bir ayar</li>
<li><code>ifconfig-pool-persist ipp.txt</code> OpenVPN tarafından istemcilere sanal ağda verilen IP adreslerinin tutulması ve tekrar bağlandıkları takdirde aynı adreslerin verilmesi için bir ayar</li>
<li><code>push &quot;dhcp-option DNS 1.1.1.1&quot;</code> Sunucunun ağa çıkarken kullanması için bir DNS ayarı</li>
<li><code>compress</code> Sıkıştırma seçeneklerinin ayarlandığı kısım</li>
<li><code>dh none</code> Diffie-Hellman&rsquo;ın açılıp kapatılması ile ilgili bir ayar</li>
<li><code>ecdh-curve</code> Eğer Elliptik Eğri Diffie-Hellman kullanıyor iseniz yanında seçmeniz gereken eğrinin ayarlandığı ayar</li>
<li><code>dh dh.pem</code> Diffie-Hellman kullanıyor iseniz önceden oluşturmanız gereken PEM dosyasının konumunu belirten ayar</li>
<li><code>tls-crypt tls-crypt.key</code> TLS katmanının pre-shared master öncesinde dahi şifrelenmesi için gerekli ayar</li>
<li><code>tls-auth tls-auth.key 0</code> TLS katmanının pre-handshake aşamasında şifrelenmesinin de ötesinde tarafların da doğrulanmasını sağlayan ayar</li>
<li><code>crl-verify crl.pem</code> Üretilen sertifikaların revoke edilip edilmediğinin CRL listesi üzerinden kontrol edilmesine yarayan ayar</li>
<li><code>ca ca.crt</code> Üretilen sertifikaya ait sertifika otoritesinin sertifikasının konumunu bildiren bir ayar</li>
<li><code>cert $SERVER_NAME.crt</code> Sunucunun sertifikasının konumunu bildiren bir ayar</li>
<li><code>key $SERVER_NAME.key</code> Sunucunun sertifikasının yanında yine gerekli olan asimetrik secret keyinin konumunu bildiren bir ayar</li>
<li><code>auth $HMAC_ALG</code> Veri kanalı ve gerekirse <code>tls-auth</code> için hangi özet algoritmasının kullanılacağını bildiren bir ayar</li>
<li><code>cipher $CIPHER</code> Veri kanalı için hangi şifreleme algoritmasının kullanılacağını bildiren bir ayar</li>
<li><code>ncp-ciphers $CIPHER</code> Sunucunun kullanabileceği şifreleme algoritmalarını bildiren bir ayar</li>
<li><code>tls-server</code> Sunucunun TLS kanalını kullanmasını söyleyen bir ayar</li>
<li><code>tls-version-min 1.2</code> TLS kanalında kullanılması için en düşük versiyonu bildiren bir ayar</li>
<li><code>tls-cipher $CC_CIPHER</code> Veri kanalından hariç TLS katmanında da şifreleme kullanılıyor bu da kontrol kanalı şifrelemesini bildiren ayar</li>
<li><code>client-config-dir /etc/openvpn/ccd</code> İstemci ayar dosyalarının tutulduğu konumu bildiren ayar</li>
<li><code>status /var/log/openvpn/status.log</code> Durum raporlarının yazılacağı konumu ve log dosyalarının tutulduğu konumu bildiren ayar</li>
<li><code>verb 3</code> Verbose kelimesinin kısaltılmışı olan bu ayar ne kadar detaylı durum raporu verileceğinin ayarıdır.</li>
</ul>
<h3 id="istemci-tarafında-tutulan-ayar-dosyası-şu-girdileri-içermektedir">İstemci tarafında tutulan ayar dosyası şu girdileri içermektedir</h3>
<ul>
<li><code>client</code> İlgili cihazın istemci rolünde olduğunu belirtiyor</li>
<li><code>proto tcp-client</code> Protokol olarak TCP&rsquo;nin kullanılacağını bildiriyor</li>
<li><code>remote $IP $PORT</code> Bağlanılacak sunucu(ların) IP adresinin ve Port numarasının ayarladığı kısım</li>
<li><code>dev tun</code> TUN/TAP arabirimlerinden hangisinin kullanılacağını ayarlıyor</li>
<li><code>resolv-retry infinite</code> Eğer IP veya DNS nedeniyle adres çözümlemesi gecikir ise ne kadar süre ile bekleyeceğini söylüyoruz</li>
<li><code>nobind</code> Lokaldeki herhangi bir adrese bağlanılmamasını bildiren ayar</li>
<li><code>persist-key</code> Yeniden başlatma durumunda anahtar dosyalarının ek bir yetkiye gerek kalmadan okunabilmesini yarar</li>
<li><code>persist-tun</code> Aynı şekilde yeniden başlatma durumunda TUN/TAP arabiriminin yetkiye gerek kalmadan uyandırılabilmesine yarar</li>
<li><code>remote-cert-tls server</code> Bağlanılan sunucunun sertifikasını TLS katmanında doğrulanmasını sağlar</li>
<li><code>verify-x509-name $SERVER_NAME name</code> Sunucunun geri döneceği sertifikasındaki ismi ve sunucunun isminin ne olması gerektiğini bildiren komut</li>
<li><code>auth $HMAC_ALG</code> Doğrulama için hangi algoritmanın kullanılacağını bildiren komut</li>
<li><code>auth-nocache</code> Oturum açmak için gerekli parolayı önbelleğe almaz</li>
<li><code>cipher $CIPHER</code> Şifreleme için kullanılacak algoritmayı seçmeye yarayan komut</li>
<li><code>tls-client</code> TLS iletişimi sırasında TLS&rsquo;yi etkinleştirir ve istemci rolünü üstlenir</li>
<li><code>tls-version-min 1.2</code> En düşük TLS versiyonunu ayarlar</li>
<li><code>tls-cipher $CC_CIPHER</code> TLS kontrol kanalında kullanılacak şifreleme algoritmasını seçer</li>
<li><code>ignore-unknown-option block-outside-dns</code> Bilinmeyen DNS adreslerinin kullanılmasını engeller</li>
<li><code>setenv opt block-outside-dns</code> Windows 10 için DNS sızıntılarını engeller</li>
<li><code>verb 3</code> Rapor verme derecesini belirler</li>
<li><code>compress</code> Sıkıştırma algoritması ayarları burada bildirilir</li>
<li><code>&quot;&lt;ca&gt;/etc/openvpn/easy-rsa/pki/ca.crt&lt;/ca&gt;&quot;</code> Beklenilen sunucu sertifika otoritesi dosyasının Hard-Coded gömülmesi</li>
<li><code>&quot;&lt;cert&gt;/etc/openvpn/easy-rsa/pki/issued/$CLIENT.crt&lt;/cert&gt;&quot;</code> İstemci sertifika dosyasının Hard-Coded gömülmesi</li>
<li><code>&quot;&lt;key&gt;/etc/openvpn/easy-rsa/pki/private/$CLIENT.key&lt;/key&gt;&quot;</code> İstemci asimetrik secret keyinin Hard-Coded gömülmesi</li>
<li><code>&quot;&lt;tls-crypt&gt;/etc/openvpn/tls-crypt.key&lt;/tls-crypt&gt;&quot;</code> TLS crypt için key dosyasının belirtilmesi</li>
<li><code>&quot;&lt;tls-auth&gt;/etc/openvpn/tls-auth.key&lt;/tls-auth&gt;&quot;</code> TLS auth için key dosyasının belirtilmesi</li>
<li><code>key-direction 1</code> TLS katmanı şifrelenmesi için istemci ve sunucuya rol atıyor (0 ve 1 şeklinde)</li>
</ul>
<p>Bu ayarları ve daha bir çoğunun ayrıntılı dökümantasyonunu <a href="https://openvpn.net/community-resources/reference-manual-for-openvpn-2-4/">OpenVPN</a> web sayfasında bulabilirsiniz.</p>
<h2 id="openvpn-bağlantısı-kurulurken-neler-oluyor-">OpenVPN bağlantısı kurulurken neler oluyor ?</h2>
<p>OpenVPN ile bağlantı kurduğum her zaman kendimi Yıldız Filosu planlarını kaçıran R2-D2 gibi hissediyorum. İnsanlar kendilerini her zaman için derinlemesine bir inceleme içerisinde bulmak istemiyorlar ve birilerinin onlara neyin nasıl döndüğünü açıklamalarını isteyebiliyorlar. Benim bu yazıyı kaleme alma amacımda aslında bu soruyu kendime sormuş olmam ve cevabını almak için çok çaba sarfetmiş olmam. Sizin de bu kadar uğraşmanızı istemem fakat size hemencecik bunu yükle gerisini düşünme o iş bende de diyemem. Başta söz verdiğim gibi derinlemesine bir şekilde bu süreci sizlere anlatacağım ve kararı size bırakacağım. Bir OpenVPN bağlantısında artısıyla eksisiyle (benim şu ana kadar çözebildiğim şekliyle) süreç şöyle işliyor. Önce bir TCP/UDP bağlantısı kuruyorsunuz. TCP kullanan her uygulama gibi bir süreç yürütüyorsunuz ve ardından TLS katmanına geçiyorsunuz. TLS katmanında el sıkışma (handshake) ve bazı kimlik doğrulama işlemleri yapıyorsunuz. Bu katmana aynı zamanda kontrol kanalı da deniliyor. Ardından belirli bir iletişim tutturulmuş oluyor ve veri kanalına geçiliyor. Veri veya data kanalında bu sefer gönderilecek veri paketlerinin şifrelenmesi ve çözülmesi süreci başlıyor. Bunun için yine cihazlar birbirleri ile konuşuyor ve belirli ortak şartlar altında veriler gönderilmeye başlanıyor. Kısaca bu şekilde anlattığım sürecin sonunda 0&rsquo;dan başlattığımız iletişim bize güvenli ve istediğimiz şekilde verilerin ulaşması ile son buluyor veya açık tutulan bağlantı üzerinden bu sefer tersine bir yolla yeniden istekler iletiliyor. Böylece iç içe borular gibi bir sistem ortaya çıkıyor. Yazı için gerekli olan tek önemli şeyi buraya yazmak gerekirse eğer:</p>
<ul>
<li><code>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384_P512</code> şeklinde olacaktır.
<ul>
<li>Burada <code>TLS</code> girdisi kontrol kanalının TLS katmanı üzerinden yürütüleceğini belirtir. Diğer alternatifler <code>SSL</code> veya <code>NULL</code>&lsquo;dur.</li>
<li><code>ECDHE</code> girdisi Elliptik Diffie-Hellman algoritması kullanılarak ilk ön-anahtarın üretileceğini belirtir. Diğer alternatifler <code>DHE</code>, <code>DH</code> veya kullanmamaktır.</li>
<li><code>ECDSA</code> verisi karşılıklı kimlik doğrulama ve asimetrik anahtar için Elliptik Dijital İmza Sertifikası Algoritmasının kullanılacağını belirtir. Diğer kullanılabilir alternatif <code>RSA</code>&lsquo;dır. Diğerlerini saymaya gerek bile yok.</li>
<li><code>AES_256_GCM</code> veri kanalında kullanılacak şifreleme algoritmasının belirtir. Diğer alternatifler <code>AES-128-CBC</code>, <code>AES-128-GCM</code> ve <code>AES-256-CBC</code>&lsquo;dir</li>
<li><code>SHA384</code> kullanılacak özet algoritmasını belirtir. Diğer alternatif <code>SHA256</code>&lsquo;dır.</li>
<li><code>P512</code> ise kullanılacak elliptik eğrinin Prime-512 adlı eğri olarak seçilmesini sağlar. Diğer alternatifler <code>P-256</code> ve <code>P-384</code>&lsquo;dür.</li>
</ul>
</li>
</ul>
<h3 id="tcp-bağlantısının-kurulması-süreci">TCP bağlantısının kurulması süreci</h3>
<p>Şimdi kafanızda sürecin yaklaşık bir resmi oluştu ise başlangıcı TCP sürecinin anlatımıyla yapıyorum. Olayımızda bir istemci ve bir sunucunun olduğunu ve bağlantının sadece bu ikisinden ibaret olduğunu düşünelim. İstemci bağlanmak istediği sunucuya bir SYN (m) paketi gönderir. Sunucu ise buna cevap olarak aynı port üzerinden bir SYN (n) paketi ve ACK (m+1) paket gönderir. Bunu alan istemci de cevap olarak ACK (n+1) şeklinde dönüş yapar ve 3&rsquo;lü TCP el sıkışması veya 3 Way TCP handshake gerçekleşmiş olur. Böylece belirtilen port üzerinden istemci ve sunucu arasında açık bir kanalımız oluştu.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://blog.shiftasia.com/what-happen-when-access-website (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<hr>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TCP-Handshake-2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.netscout.com/blog/asert/ddos-attacks-ssl-something-old-something-new (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<p>Fotoğraflarda da görüleceği üzere eğer süreç sorunsuz işler ise 3 adımda iletişim kurulabiliyor. Fakat neden 3 adımda bu işi yapıyoruz daha kısa şekilde olmaz mı derseniz size (şimdilik) hayır olmaz full-duplex bir iletişim için her iki tarafın da SYN ve ACK paketlerini göndermesi gerekiyor derim. İleride belki farklı yollarını da anlatırım ama şimdilik böyle. Zaten işin TCP/UDP kısmı her zaman için kısa ve basittir.</p>
<h3 id="tls-katmanındaki-işletilen-süreç">TLS katmanındaki işletilen süreç</h3>
<p>TCP üzerinden bir iletişim kurulmasının ardından yine muhabbeti başka bir aşamaya taşıyan kişi istemci oluyor. Her zaman için istemciler sunucudan bir şeyler talep eder veya bir cevap ister. Sunucular genel olarak kendilerine gelmeyen bir isteği cevapladığı çok görülmemiştir. Önce talep sonra arz ilkesine göre süreç ilerler. Evet, taraflar TLS katmanındalar şimdi. İstemci sunucuya önce bir merhaba diyor. Şaka değil gerçek. İstemci tarafından gönderilen ilk pakete <code>Client-Hello</code> paketi denir. Bu paketin yanında (süreci hızlandırmak adına) desteklediği şifreleme algoritmalarını belirten <code>Supported-Chipers</code> paketi, istemci tarafından rastgele üretilmiş bir sayı, aynı IP adresinde birden fazla hizmet çalıştırılıyor ise bir <code>SNI</code> sunucu adı indikatörü ve yine gerekiyor ise oturum ID&rsquo;si gönderilir. Sunucunun buna cevabı ise öncelikle kibar bir merhaba demek oluyor. Çünkü sunucunun cevaben gönderdiği ilk pakete de <code>Server-Hello</code> paketi denir. Bu paketin yanında sunucu sertifikasını, kendi desteklediği şifreleme algoritmalarını ve seçtiği algoritmayı belirten <code>Selected-Chiper</code> paketi, kendisinin ürettiği rastgele bir sayıyı, gerekirse Oturum ID&rsquo;sini ve aynı IP üzerinden birden fazla istemci bağlanıyor ise buna ilişkin SNI benzeri bir ID&rsquo;yi gönderir. İstemci öncelikle iletişime başladığı tarafından gerçekten beklediği kişi olup olmadığını sunucu sertifikası ile doğrular. Ayrıca bazı durumlarda da sunucu istemcinin beklediği istemcilerden biri olup olmadığını yine sertifika ile doğrular. Eğer bu karşılıklı doğrulama (mutual-authentication) süreci olumlu sonuçlanır ise bir sonraki aşamaya geçilir. Anahtar üretim ve değişim süreci tetiklenmiş olur. Bu aşamda yine istemci devreye girer ve güvensiz önkabul edilen bu iletişim sırasında belirledikleri algoritma ile anahtar değiştirmek istediğini söyler. Taraflar Diffie-Hellman veya ECDHE ile bir önanahtar oluşturmaya başlarlar. Bunun için istemci ve sunucu tarafından ön-sırlar paylaşılır. Bir takım matematiksel işlemler yapılarak bulunan cevaplar karşıya gönderilir ve tekrar matematiksel işlemler yapılarak aynı sonuca ulaşılır. İşte ulaşılan sonuç aralarında güvenli bir şekilde oluşturdukları ilk ön-anahtar oluyor. Bundan sonra belirledikleri şifreleme algoritması ile
iletişime geçmek için kontrol kanalından hariç bir veri kanalı oluşturulur ve süreç oradan devam eder.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.researchgate.net/publication/298065605_A_multi-level_framework_to_identify_HTTPS_services (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<hr>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TLS-Handshake-2.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></p>
<p>Fotoğraflarda da görülebileceği üzere süreç bir web sayfasına bağlanılırken yaşanan süreçle neredeyse aynı. Sadece ihtiyaçlara göre belirli aşamalar ekleniyor, çıkarılıyor veya değiştiriliyor. Örneğin İleri Seviye Gizlilik anlamına gelen PFS gereğince taraflar ön-anahtarı sunucunun asimetrik anahtarı ile iletmiyor. Çünkü bu durumda her oturum için aynı anahtar kullanılacağı için verilerin depolanıp daha sonra anahtar açığa çıktığı bir gün beklenerek veriler geçmişe dönük okunabilir bir hale gelecektir. Bu yüzden bu değişiklik yapıldı. Yine sıfır güven tehdit modeli gereğince her bir katmanın ve sürecin bir diğerinin işini doğru yapacağına güvenmeden süreci ilerletmesini istiyorum. Bu yüzden TLS katmanındaki o ilk iletişim anında dahi paketlerin <code>tls-auth</code> özelliği gereğince şifrelenmesini ve gelen-giden verilerin bütünlüğünün doğrulanmasını istiyoruz. Daha ilk merhaba dediğiniz andan itibaren üçüncü kişiler sizin ne konuştuğunuzu hangi aşamada olduğunuzu anlayamayacaklardır. Bunun için önceden belirlenmiş bir anahtar/anahtarlar ile ilk iletişim başlatılır ve gerekirse belirli aralıklarla bu anahtarlar yenilenir. Böylece TLS katmanında ilk ön-anahtar oluşturulana kadar dahi gizlilikten ödün verilmemiş ve yetkisiz kişilerce boşuna tarafik yaratılmamış olur.</p>
<h3 id="veri-katmanında-işleyen-süreç">Veri katmanında işleyen süreç</h3>
<p>Eğer tüm bu süreç başarılı bir şekilde tamamlanmış ve veri kanalına geçilebildiyse eğer artık işin en güzel kısmına gelmiş bulunuyorsunuz. Veriler AES şifreleme methodu ile şifrelenecek. Şifreleme sırasında seçiminize göre CBC-GCM counter moduna göre tablolar karıştırılacak ve bu süreçte seçiminize göre 128 veya 256 bit uzunluğunda şifreleme anahtarı kullanılacak. Tabi ne hangisini seçerseniz seçin şifreleme blok uzunluğu 128 bit olucak. Değişen sadece şifreleme anahtarı uzunluğu. Benim bu anlatımım için seçmiş olduğum AES-256-GCM bir AEAD şifreleme türüdür. Diğer kanallardan ve süreçlerden bağımsız olarak gönderdiği verileri belirli bir aşamada özetini çıkartır ve özeti ile birlikte gönderir. Böylece &lsquo;Authentication Encryption with associated data&rsquo; anlamına gelen AEAD&rsquo;de doğrulama ve şifreleme işlevleri yerine getirilmiş oluyor. Burada bir ayrıma gidilmesini gerektirecek şöyle bir sorun mevcuttur. Şifreleme ve Özet alma algoritmalarını hangi aşamada ve sırayla kullanacağız.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/EtM.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Encrypt-then-MAC (EtM)</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/EaM.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Encrypt-and-MAC (E-and-M)</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/MtE.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>MAC-then-Encrypt (MtE)</b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Authenticated_encryption">https://en.wikipedia.org/wiki/Authenticated_encryption</a> (Erişim Tarihi: 08.04.2023)</p>
</blockquote>
<ul>
<li>
<p>Birinci yaklaşım olan EtM&rsquo;ye göre veri önce şifrelenir ardından başka bir anahtar ile özeti sonucu şifrelenir ve ortaya çıkan sonuç bloklar halinde birlikte gönderilir. Bunu kullanan gerçek dünya çözümlerine bakacak olursak IPSec protokolü ilk akla gelen olacaktır. Bu, AE&rsquo;de en yüksek güvenlik tanımına ulaşabilen tek yöntemdir, ancak bu ancak kullanılan MAC algoritmasının bozulma içermediği veya henüz kırılmadığı takdirde elde edilebilir. SSHv2 için de çeşitli EtM şifre takımları mevcuttur. Ancak veri ve özet için anahtar ayrımının zorunlu olduğunu unutmayın (şifreleme ve anahtarlı karma için farklı anahtarlar kullanılmalıdır), aksi takdirde kullanılan belirli şifreleme yöntemine ve karma işlevine bağlı olarak potansiyel olarak güvensiz bir sonuç elde edebilirsiniz.</p>
</li>
<li>
<p>İkinci yaklaşım olan E&amp;M&rsquo;ye göre düz metin olan veri şifrelenir ve yanına düz metin verinin şifrelenmemiz halinin özeti eklenir. Burada sadece bir anahtar kullanılmış olmasına rağmen aynı veriye ait iki farklı sonucun (şifreleme sonucu ve özet sonucu) olması güvenliğin yeterince iyi olmadığını açıkca gözler önüne sermektedir. Bu sistemi kullanan gerçek dünya çözümü olarak SSH&rsquo;ın ilk versiyonlarını örnek gösterebiliriz. Bunu geliştirmek için ayrıca gönderilen özet dosyasını da aynı anahtar ile şifreleme gibi yöntemler denenmiştir.</p>
</li>
<li>
<p>Üçüncü ve bildiğim son yaklaşım olan MtE&rsquo;ye göre düz metine dayalı olarak bir özet dosyası üretilir. Ardından düz metin ve özet dosyası birlikteyken anahtar ile şifrelenir.  Şifreli metin ve şifreli özet dosyası birlikte gönderilir. Bunu kullanan gerçek dünya çözümlerine bakacak olursak ilk ve en önemlisi SSL/TLS uygulamalarıdır. SSL/TLS uygulamalarının kendi içlerinde ne kadar güvenilir ve sürdürülebilir olduklarını hepimiz biliyoruz. Bunun ötesinde de güvenliği artırmak adına yıllar içersinde <code>MAC-then-pad-then-encrypt</code> gibi geliştirmeler yapıldı. Bu geliştirmeye göre önce düz metinin özeti alınır ardından blok boyutuna kadar doldurulur ve ardından şifreleme işlemi yapılır. Böylece daha da güvenilir bir şifreleme sonucu oluşur. Ama doldurma mekanizmasının belirli hatalar yapması durumunda Padding Oracle gibi saldırılara neden olduğu durumlar mevcuttur.</p>
</li>
</ul>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/openvpn-full/TAP-TUN.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://community.openvpn.net/openvpn/wiki/Gigabit_Networks_Linux (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<p>Kullanılacak AEAD yaklaşımı da seçildikten sonra TAP veya TUN kullanımına göre yukarıdaki grafikte görülen yol izlenir. Bu yola göre kullanıcı alanında yapılan/yapılmak istenen eylem çekirdek (kernel) seviyesinde TAP/TUN adaptörlerine gider. Bu adaptörler çekirdek seviyesinde bulunmaları nedeniyle çok hızlı bir şekilde işlem yaparlar. Ardından sanal adaptörler ilgili kütüphane ile gerekli şifrelemeyi yapar, gerekirse özeti ekler ve paket boyutu ayarı yapar. Ardından sunucu Ethernet arayüzü üzerinden istemcinin Ethernet arayüzüne paketleri sırayla gönderir. Bunu alan istemci ise paketleri yeniden ayarlar, düzenler gerekirse birleştirir ve gerekli kütüphaneler ile şifresini çözer. Şifresini çözdükten sonra bunu sanal adaptör aracılığı ile istemcini son kullanıcısına iletir. Böylece tüm bu matematiksel işlemler, uğraşlar sonucunda birkaç çevrim neticesinde kullanıcı istediği içeriğe ulaşmış oldu. Anlatması oldukça uzun ama kullanması çok kolay sevgili okuyucular. Sadece GitHub sayfama girik ilgili <a href="https://github.com/wiseweb-works/openvpn-most-secure-install/">script sayfasını</a> ziyaret etmeniz yeterlidir. İlgili script tüm bu ayarlamaları interaktif olarak sizin yerinize yapmaktadır. Size de arkanıza yaslanıp keyfini çıkarmak kalıyor.</p>
<h1 id="sss-ve-son">SSS ve Son</h1>
<p>Bana <a href="mailto:wisewebworks@outlook.com">mail</a> yoluyla, <a href="https://fosstodon.org/@wise">Fosstodon</a> üzerinden veya <a href="https://github.com/wiseweb-works">GitHub</a> üzerinden gelen soruları zaman zaman buraya eklemeye çalışacağım. Böylece tarihsel olarak da hangi tarihte ne gibi sorular olmuş veya çözümü mevcut mu gibi düşüncelere kapılmadan direk sonuca ulaşabileceksiniz. Bunun haricinde de teknik dökümanı değiştirmeden ekstra açıklama gerektiren sorular gelirse onları da bu kısma almayı düşünüyorum.</p>
]]></content:encoded></item><item><title>Linux Sunucuda ECC SSL Sertifikası Üretme</title><link>https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/</link><pubDate>Sun, 20 Mar 2022 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/ecc-ssl-sertifikasi/</guid><description>Giriş ve Özet Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&amp;rsquo;s Encrypt&amp;rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür.</description><content:encoded><![CDATA[<h1 id="giriş-ve-özet">Giriş ve Özet</h1>
<p>Bugün sizlerle yönettiğiniz bir web sitesi veya uygulama sunucusu ile ziyaretçileriniz arasındaki trafiğin gizli/güvenilir ve doğrulanabilir olmasını sağlamak için SSL sertifikası üretmeyi öğreneceğiz. Ürettiğiniz sertifikayı nasıl ve hangi konfigürasyon ile deploy edeceğinizi önceki yazılarımda anlatmıştım. Bu yazıda ise az ekmek çok köfte denklemini nasıl kurabileceğimizi yani daha hızlı ve daha güvenli bir SSL sertifikası üretmeyi göstereceğim. Normalde Let&rsquo;s Encrypt&rsquo;in ACME protokolüne aşina iseniz (yazının yazıldığı tarih itibariyle) RSA asimetrik anahtar yapısı ile 1024-4098 (çok zorlarsanız belki 8196) bitlik bir sertifika ürettirmeniz ve bunu görece olarak 90 gün kullanmanız mümkündür. Fakat bu kadar büyük bir anahtarın üretilmesi, ürettikten sonra TLS handshake sırasında kullanılması ve ziyaretçilerin kullandığı cihazlar ile uyumlu olması çoğu senaryoda sorun çıkarmaktadır. Örneğin 2048 bit yerine 4096 bit kullanıldığı zaman bazı denemelerimde 0.4-0.8 sn daha uzun handshake süreleri ile karşı karşıya kalıyorum. Sadece handshake in bu kadar uzaması sorun değilmiş gibi sunucuya da ekstra bir yük bindiriyor. Fakat 4096 bit RSA yerine 384 bit ECC sertifikası ürettiğiniz zaman çok daha hızlı bir sertifikaya sahip olduğunuz gibi aynı zamanda da 7680 bit RSA&rsquo;ya (öyle bir boyut olsaydı) eşit bir güvenlik elde ediyorsunuz.</p>
<p>Peki iyi güzel anlattın da bu işin aması nerede dediğinizi duyar gibiyim. Sizi üzeceğim fakat bu işin aması yok. Olmamasının sebebi ise işin arka plandaki matematikte saklı. Kısaca her iki sertifika üretim ve kullanımındaki ufak farklardan bahsedip, bunların nasıl ve neden büyük farklara neden olduğunu açıklayıp son kısımda da bonus olarak başlıkta yazmayan bir şeyden bahsedeceğim. (Sonuna kadar okumanız gerekecek bonus için :D)</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/key-size-comparison.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://www.globalsign.com/en/blog/elliptic-curve-cryptography (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<h2 id="ecc-sertifikasının-üretim-süreci">ECC Sertifikasının üretim süreci</h2>
<p>Öncelikle (her zaman olduğu gibi) içinde bulunduğumuz Linux sürümünün paket yöneticisi ile son güncellemeleri konsol üzerinden yüklememiz gerekmektedir.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu için: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora için: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux için: sudo pacman -Syyu
</span></span></code></pre></div><p>Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) nginx servisini (ki bu servis dışarıdan HTTP/HTTPS bağlantıları almanıza yarayan servistir) yapılandırmaya başlıyoruz. Öncelikle çok karıştırılması nedeniyle belirtmek gerekir ki apache, nginx ve litespeed servisleri aynı işi yapan farklı servislerdir. Ben yönetimi daha kolay ve topluluk desteği daha çok diye NGINX&rsquo;i terchi ettim.</p>
<h2 id="özel-anahtarı-oluşturalım">Özel anahtarı oluşturalım</h2>
<p>İlk olarak, OpenSSL ile özel anahtarı oluşturuyoruz. Kullanacağımız OpenSSL komutu <code>ecparam</code> (EC parametre manipülasyonu) ve konfigürasyon parametrelerini bu komuta geçirmek için:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ecparam -genkey -name secp384r1 -out privkey.pem
</span></span></code></pre></div><ul>
<li><code>-genkey</code> seçeneği, OpenSSL&rsquo;ye bir EC anahtarı oluşturmasını söyler.</li>
<li><code>-name</code> parametresi OpenSSL&rsquo;ye hangi eğrinin kullanılacağını söyler.</li>
<li><code>-out</code> parametresi OpenSSL&rsquo;ye çıktıyı bir dosyaya yazmasını söyler.</li>
</ul>
<p>OpenSSL&rsquo;nin çıktısını varsayılan olarak PEM biçiminde yazdığını unutmayın. EC anahtarlarını işleyen <code>ec</code> komutuyla OpenSSL&rsquo;nin doğru şeyi yaptığını kontrol edebiliriz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl ec -in privkey.pem -noout -text
</span></span></code></pre></div><ul>
<li><code>-in</code> girdi dosyasıdır</li>
<li><code>-noout</code>, OpenSSL&rsquo;ye anahtarı çıkarmamasını söyler, bu da privkey.pem&rsquo;i stdout&rsquo;a anlamsızca yazdırır.</li>
<li><code>-text</code>, OpenSSL&rsquo;ye anahtar hakkındaki bilgileri düz metin biçiminde yazmasını söyler</li>
</ul>
<p>Her şey yolunda giderse ve anahtar doğru şekilde oluşturulduysa, OpenSSL aşağıdakine benzer bir şey gösterecektir:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>read EC key
</span></span><span style="display:flex;"><span>Private-Key: (384 bit)
</span></span><span style="display:flex;"><span>priv:
</span></span><span style="display:flex;"><span>    [gizli]
</span></span><span style="display:flex;"><span>pub:
</span></span><span style="display:flex;"><span>    [gizli]
</span></span><span style="display:flex;"><span>ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>NIST CURVE: P-384
</span></span></code></pre></div><p>Bu, anahtarın P-384 eğrisi ile oluşturulduğunu doğrular. Neden P-384 yerine P-512 kullanmıyoruz derseniz Let&rsquo;s Encrypt ekliptik eğrilerde 384 bitten daha yüksek olursa imzalamıyor ve Google Chrome gibi modern tarayıcılar 512 bitlik ekliptik eğrileri kullanan internet sitelerini geçersiz olarak işaretliyor. Kısa cevap bu.</p>
<h2 id="sertifika-için-openssl-yapılandırması-oluşturalım">Sertifika için OpenSSL yapılandırması oluşturalım</h2>
<p>Şimdi TLS sertifikası almak istediğimiz etki alanına özgü parametreleri içeren bir OpenSSL yapılandırma dosyası oluşturmalıyız. Bu örnekte, bir <code>openssl.cnf</code> dosyasına aşağıdaki konfigürasyonu gireceğiz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>[ req ]
</span></span><span style="display:flex;"><span>prompt = no
</span></span><span style="display:flex;"><span>encrypt_key = no
</span></span><span style="display:flex;"><span>default_md = sha512
</span></span><span style="display:flex;"><span>distinguished_name = dname
</span></span><span style="display:flex;"><span>req_extensions = reqext
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ dname ]
</span></span><span style="display:flex;"><span>CN = example.com
</span></span><span style="display:flex;"><span>emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[ reqext ]
</span></span><span style="display:flex;"><span>subjectAltName = DNS:example.com, DNS:www.example.com
</span></span></code></pre></div><p>Bu yapılandırma seçeneklerinin kısa bir açıklaması:</p>
<p>Gerekli <code>[ req ]</code> bölümünde:</p>
<ul>
<li><code>prompt = no</code>, OpenSSL&rsquo;ye yapılandırma dosyasından olabildiğince fazla yapılandırma almasını söyler</li>
<li><code>encrypt_key = no</code>, OpenSSL&rsquo;ye özel anahtarı bir parola ile şifrelememesini söyler. (Şifreli özel anahtarlar Nginx tarafından desteklenir, ancak ben onları kullanmıyorum.)</li>
<li><code>default_md = sha512</code>, OpenSSL&rsquo;ye CSR&rsquo;yi SHA512 ile imzalamasını söyler. (Bildiğim kadarıyla, Let&rsquo;s Encrypt, imzaları için yalnızca SHA256&rsquo;lı RSA&rsquo;yı destekler, ancak bu, CSR&rsquo;de daha güçlü şifreleme kullanamayacağımız anlamına gelmez.)</li>
<li><code>distinguished_name = dname</code>, OpenSSL&rsquo;ye Ayırt Edici Ad yapılandırma seçenekleri için bir <code>[ dname ]</code> bölümü aramasını söyler.</li>
<li><code>req_extensions = reqext</code>, OpenSSL&rsquo;ye, Konu Alternatif Adlarının (SAN&rsquo;lar) yapılandırılmak istenen uzantılar için yapılandırma seçeneklerinde bir <code>[ reqext ]</code> bölümü aramasını söyler.</li>
</ul>
<p>Ayırt Edici Ad <code>[ dname ]</code> bölümünde:</p>
<ul>
<li><code>CN = example.com</code>, sertifikanın Ortak Adını belirtir.</li>
<li><code>emailAddress = admin@example.com</code> e-posta adresiniz belirgin olmalıdır.
İstenen Uzantılar <code>[ reqext ]</code> bölümünde, konuAltName, sertifika için SAN&rsquo;ların listesini sağlar. (Chrome, v58&rsquo;den itibaren, Ortak Adın SAN&rsquo;lar listesine dahil edilmesini gerektirir).</li>
</ul>
<p>Let&rsquo;s Encrypt v2, joker alan adlarını destekler, bu nedenle bu örnekte, apeks dışındaki ana bilgisayarlar için tek düzeyli bir joker karakter kullanabilirsiniz (*.example.com).</p>
<h2 id="sertifika-imzalama-isteği-oluşturalım">Sertifika İmzalama İsteği Oluşturalım</h2>
<p>İstemci tarafındaki son adım, OpenSSL kullanarak Sertifika İmzalama Talebi oluşturmaktır, ardından bunu imzalamak için Let&rsquo;s Encrypt&rsquo;e ileteceğiz ve imzalı sertifikayı geri alacağız.</p>
<p>Bir CSR oluşturmak için gereken OpenSSL komutu <code>req</code> &lsquo;dir.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -new -config openssl.cnf -key privkey.pem -out csr.pem
</span></span></code></pre></div><ul>
<li><code>-new</code>, OpenSSL&rsquo;ye bir CSR oluşturduğumuzu söyler (ve mevcut bir CSR&rsquo;yi incelemeyiz)</li>
<li><code>-config</code> openssl.cnf, yukarıda oluşturduğumuz yapılandırma dosyasını belirtir</li>
<li><code>-key privkey.pem</code>, yukarıda oluşturduğumuz özel anahtarı belirtir</li>
<li><code>-out csr.pem</code> OpenSSL&rsquo;ye CSR&rsquo;yi bir çıktı dosyasına yazmasını söyler (stdout yerine)</li>
</ul>
<p>CSR&rsquo;yi doğru şekilde oluşturduğumuzu doğrulayabiliriz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl req -in csr.pem -noout -text -verify
</span></span></code></pre></div><ul>
<li><code>-verify</code> OpenSSL&rsquo;nin CSR&rsquo;deki imzayı doğrulamasını ister</li>
</ul>
<p>Bu, çıktıda beklenen şu sonuçları üretmelidir:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>verify OK
</span></span><span style="display:flex;"><span>Certificate Request:
</span></span><span style="display:flex;"><span>    Data:
</span></span><span style="display:flex;"><span>        Version: 1 (0x0)
</span></span><span style="display:flex;"><span>        Subject: CN = example.com, emailAddress = admin@example.com
</span></span><span style="display:flex;"><span>        Subject Public Key Info:
</span></span><span style="display:flex;"><span>            Public Key Algorithm: id-ecPublicKey
</span></span><span style="display:flex;"><span>                Public-Key: (384 bit)
</span></span><span style="display:flex;"><span>                pub:
</span></span><span style="display:flex;"><span>                    [gizli]
</span></span><span style="display:flex;"><span>                ASN1 OID: secp384r1
</span></span><span style="display:flex;"><span>                NIST CURVE: P-384
</span></span><span style="display:flex;"><span>        Attributes:
</span></span><span style="display:flex;"><span>        Requested Extensions:
</span></span><span style="display:flex;"><span>            X509v3 Subject Alternative Name:
</span></span><span style="display:flex;"><span>                DNS:example.com, DNS:www.example.com
</span></span><span style="display:flex;"><span>    Signature Algorithm: ecdsa-with-SHA512
</span></span><span style="display:flex;"><span>         [gizli]
</span></span></code></pre></div><h2 id="lets-encryptten-sertifikamızı-imzalamasını-isteyin">Let&rsquo;s Encrypt&rsquo;ten sertifikamızı imzalamasını isteyin</h2>
<p>Son adım, CSR&rsquo;yi bir ACME istemcisiyle Let&rsquo;s Encrypt&rsquo;e imzalaması için göndermektir, bu iş için <code>certbot</code> en yaygın istemcidir.</p>
<p><code>Certbot</code> istemcisine iletilen komut satırı seçenekleri, kurulumumuza, alan adımızın kayıtlı olduğu kişiye vb. bağlı olarak değişir. Genellikle <code>certonly</code> komutunu kullanmamız gerekir ve asterisks (*) kullandıysanız certbot DNS eklentilerinden birini kullanmanız gerekir.</p>
<p>Örneğin, <code>example.com</code> alan adı Cloudflare&rsquo;de kayıtlıysa, son derece uygun olan ve sürece manuel müdahale gerektirmeyen doğrulamayı işlemek için ilgili eklentiyi kullanabiliriz. (Cloudflare eklentisini gizli token bilgileriyle yapılandırmak bu makalenin kapsamı dışındadır.)</p>
<p>Her şeyin yolunda olduğundan emin olmak için önce <code>--dry-run</code> ile düzgün sonuç alınacağından emin olunması genellikle tavsiye edilir.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --dry-run --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><ul>
<li>Hatalı işlemeleri önlemek için karakterlerin etrafında tırnak işaretleri gereklidir ve genel olarak bunlar iyi bir fikirdir.</li>
<li><code>--csr csr.pem</code> certbot&rsquo;a zaten bir sertifikamız olduğunu ve bizim için imzalaması için Let&rsquo;s Encrypt&rsquo;e ihtiyacımız olduğunu söyler.</li>
</ul>
<p>Certbot istemcisi, komut satırında istenen alan adları listesinin sertifikada listelenen alan adlarıyla eşleşip eşleşmediğini kontrol edecek ve alan adının bize ait olduğunu doğrulamak için Certbot NGINX eklentisini kullanacak ve herhangi bir sorun olup olmadığını bize bildirecektir.</p>
<p>Hiçbir şey yanlış değilse, size şunu söyleyecektir:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>IMPORTANT NOTES:
</span></span><span style="display:flex;"><span> - The dry run was successful.
</span></span></code></pre></div><p>Gerçek komut hemen aşağıdaki gibidir:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>certbot nginx certonly --domain <span style="color:#e6db74">&#34;example.com&#34;</span> --domain <span style="color:#e6db74">&#34;www.example.com&#34;</span> --csr csr.pem
</span></span></code></pre></div><p>(Uzun) bir gecikmeden sonra, istemci çıktı olarak şunları üretecektir:</p>
<ol>
<li>İmzalı sertifika: <code>0000_cert.pem</code></li>
<li>Kök ve ara sertifikalar: <code>0000_chain.pem</code></li>
<li>Sertifika + ara ürünler: <code>0001_chain.pem</code>
Bu noktada, CSR <code>csr.pem</code> silinebilir.</li>
</ol>
<p>Merak ediyorsak, <code>x509</code> komutunu kullanarak istemci tarafından OpenSSL ile döndürülen sertifikaları inceleyebiliriz:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>openssl x509 -in 0001_chain.pem -noout -text
</span></span></code></pre></div><p>Ne yazık ki, yukarıda açıklandığı gibi Let&rsquo;s Encrypt&rsquo;in sertifikamızı bir SHA256 imzasıyla imzaladığını keşfedeceğiz. (Daha güvenli olmasının yanı sıra, SHA512, modern 64-bit CPU&rsquo;larda SHA256&rsquo;dan daha iyi performans gösterir.) Ancak açık anahtarımız yine de ECDSA kullanmalıdır.</p>
<p>Bu dosyalar sıradan değildir, bu yüzden onları daha bilgilendirici bir şekilde taşımalı ve düzenlemeliyiz.</p>
<p>Debian Linux&rsquo;ta, özel anahtarımı <code>/home/KULLANICI_ADI/SSL/private/example.com/privkey.pem</code> içinde tutarak etki alanlarım için alt dizinler oluşturmayı seviyorum ve sertifikalar:</p>
<ul>
<li><code>/home/KULLANICI_ADI/SSL/certs/example.com/cert.pem</code></li>
<li><code>/home/KULLANICI_ADI/SSL/certs/example.com/chain.pem</code></li>
<li><code>/home/KULLANICI_ADI/SSL/certs/example.com/fullchain.pem</code></li>
</ul>
<h1 id="son">SON</h1>
<p>Her şeyi doğru yaptıysak, sertifikayı Chrome gibi bir web tarayıcısı ile incelediğimizde, bunun bir EC sertifikası olduğunu onaylayacaktır:</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-sll-key-chrome.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<p>Mozilla Gözlemevi de bize A+ notu verecek!</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-mozilla.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc (Erişim Tarihi: 08.04.2023)</b></small></center>
</picture></p>
<p>Ayrıca SSL Labs&rsquo;ın rapor sonucunda 384 Bitlik bir ECC sertifikası&rsquo;nın kullanıldığını görebiliyoruz.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ecc-ssl/ecc-ssl-key-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>SSL Labs Test Sonucu</b></small></center>
</picture></p>
<p>NOT: Bu yazıda <a href="https://dev.to/benjaminblack/obtaining-an-elliptic-curve-dsa-certificate-with-lets-encrypt-51bc">Benjamin Black</a>&lsquo;in aynı konulu yazısından faydalanılmıştır.</p>
]]></content:encoded></item><item><title>İletişim</title><link>https://wiseweb-works.github.io/blog/page/iletisim/</link><pubDate>Wed, 01 Dec 2021 23:58:00 +0100</pubDate><guid>https://wiseweb-works.github.io/blog/page/iletisim/</guid><description>Günümüz dünyasında gizlilik, güvenlik ve internet üzerine endişelerim ile bazı projelerimi kaleme aldığım web sayfama hoş geldiniz. Bu web sayfası hem şahsi portfolyomun oluşması hem de bilgi paylaşımı amacıyla oluşturulmuştur. ​ Yazdıklarım içerisinde ilginizi çeken bir konu varsa sizin de fikirlerinizi ve tabiki de Github pull requestlerinizi beklerim.
Benimle iletişim kurmak isterseniz:
e-posta wisewebworks[at]outlook.com
mastodon fosstodon.org/@wise
xmpp wise[at]yax.im
Blog&amp;rsquo;um, RSS destekler. Arzu ederseniz kullanmakta olduğunuz RSS okuyucu üzerinden kayıt olabilirsiniz.</description><content:encoded><![CDATA[<p>Günümüz dünyasında gizlilik, güvenlik ve internet üzerine endişelerim ile bazı projelerimi kaleme aldığım web sayfama hoş geldiniz. Bu web sayfası hem şahsi portfolyomun oluşması hem de bilgi paylaşımı amacıyla oluşturulmuştur.
​
Yazdıklarım içerisinde ilginizi çeken bir konu varsa sizin de fikirlerinizi ve tabiki de Github pull requestlerinizi beklerim.</p>
<p>Benimle iletişim kurmak isterseniz:</p>
<p><strong>e-posta</strong> wisewebworks[at]outlook.com<br>
<strong>mastodon</strong> fosstodon.org/@wise<br>
<strong>xmpp</strong> wise[at]yax.im</p>
<p><em>Blog&rsquo;um, <a href="https://wiseweb-works.github.io/blog/index.xml">RSS</a> destekler. Arzu ederseniz kullanmakta olduğunuz RSS okuyucu üzerinden kayıt olabilirsiniz.</em></p>
<hr>
<p>Lüzumsuz büyük olmayan, ek bileşenler ve uzun yükleme süresi ile kullanıcıları rahatsız etmeyen bir web sayfası yapma konusunda bana ilham olan sevgili Ged&rsquo;e <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> teşekkür ederim. Bu kulüp interneti ve kullanıcıları lüzumsuz büyüklükteki sitelerden korumayı desteklemektedir.</p>
<p>Bu site, <a href="https://gohugo.io/">Hugo</a> kullanılarak ve <a href="https://github.com/adityatelange/hugo-PaperMod/">PaperMod</a> temasıyla oluşturulmuştur. Ayrıca bu site, 100kb&rsquo;nin altındaki büyüklüğüyle <a href="https://512kb.club/">512kbClub</a>&lsquo;ın Yeşil Üyesidir.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/green-team.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/green-team.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/green-team.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b></b></small></center>
</picture></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://yunbere.hayalmasal.org/">https://yunbere.hayalmasal.org/</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>Linux Sunucularda SSL güvenliğini arttırma</title><link>https://wiseweb-works.github.io/blog/post/ssl-konfigurasyonu/</link><pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/ssl-konfigurasyonu/</guid><description>Linux Sunucularda SSL güvenliğini artırma Bugün sizlere mevcut sunucunuzda eğer bir websitesi ve/veya App serve ediyorsanız mutlaka ihtiyacınız olan SSL bağlantısından ve bununla bağlantılı olarak openssl kütüphanesinden bahsedeceğim. SSL (Secure Socket Layer) ve TLS (Transport Layer Security) sunucunuza bağlanmak isteyen kişileri siteniz ile güvenli şekilde iletişim kurmasına imkan sağlayan bir bağlantı şeklidir. Eskiden SSL v1-v3 arasında değişen sürümler mevcut ve siteler genelde bu SSL sürümlerini kullanırken artık SSL siteler tarafından terk edilmiş ve yerini daha güvenli olan TLS&amp;rsquo;ye bırakmıştır.</description><content:encoded><![CDATA[<h1 id="linux-sunucularda-ssl-güvenliğini-artırma">Linux Sunucularda SSL güvenliğini artırma</h1>
<p>Bugün sizlere mevcut sunucunuzda eğer bir websitesi ve/veya App serve ediyorsanız mutlaka ihtiyacınız olan SSL bağlantısından ve bununla bağlantılı olarak openssl kütüphanesinden bahsedeceğim. SSL (Secure Socket Layer) ve TLS (Transport Layer Security) sunucunuza bağlanmak isteyen kişileri siteniz ile güvenli şekilde iletişim kurmasına imkan sağlayan bir bağlantı şeklidir. Eskiden SSL v1-v3 arasında değişen sürümler mevcut ve siteler genelde bu SSL sürümlerini kullanırken artık SSL siteler tarafından terk edilmiş ve yerini daha güvenli olan TLS&rsquo;ye bırakmıştır. Fakat yine de işin anlatımı kısmında ve config dosyalarını düzenlerken halen &ldquo;ssl&rdquo; kelimesini kullanmamız gerekecektir. Bunu ufak bir espiri ile de anlatmak gerekirse eğer bir uygulamanın 64 bit versiyonunu indirmek istediğiniz aman &ldquo;amd_64&rdquo; olarak neden geçtiğini hiç düşündünüz mü? Çünkü 64 bit&rsquo;e ilk geçen AMD olduğu için buna bir saygı göstergesi ve/veya alışkanlık olarak amd_64 olarak kaldı bu isimlendirme. Aynı şekilde de şu an TLS kullanıyor olmamıza rağmen isimlendirme ve konfigürasyon parametreleri &ldquo;SSL&rdquo; olarak kaldı.</p>
<p>Daha önceki yazımızda olduğu gibi süreci yine basit, önerilen ve ileri-seviye olarak üç farklı başlık altında anlatacağım. Başlık içerikleri kişisel gerekliliklere göre aşamalı düşünülmüştür. Başlıklar bir biri ile bağlantılı olmasına rağmen istenilen bir aşamada bırakılması sorun oluşturmayacaktır.</p>
<h2 id="basit-konfigürasyon">Basit konfigürasyon</h2>
<p>Öncelikle içinde bulunduğumuz Linux sürümünün paket yöneticisi ile güncellemeleri konsol üzerinden yüklememiz gerekmektedir.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu için: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora için: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux için: sudo pacman -Syyu
</span></span></code></pre></div><p>Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) nginx/apache servisini (ki bu servis dışarıdan gelen web bağlantılarını almanıza yarayan servistir) yapılandırmaya başlıyoruz. Nginx servisinin ayarlarının tutulduğu dosya genel itibariyle &ldquo;/etc/nginx/nginx.conf&rdquo; konumunda bulunur. Bunu kendi kullandığımız metin editörlerinden istediğimiz biriyle ama sudo (yani yönetici) yetkilerine sahip bir kullanıcı ile açmamız gerekmektedir.</p>
<p>Ubuntu üzerinden devam edecek olursak (Tek Ip Tek Sunucu Yapılandırması)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/nginx/nginx.config <span style="color:#75715e"># Ayar dosyasını açmaya yarayan komut</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Eklenecek (varsa değiştirilecek) başlıklar
</span></span><span style="display:flex;"><span>listen 443 ssl http2; &gt;&gt; ipv4 üzerinden 443 portuna gelen istekleri http2 protokolü ile karşılayıp ssl bağlantısı kurmaya yarıyor.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>listen [::]:443 ssl http2; &gt;&gt; ipv6 üzerinden 443 portuna gelen istekleri http2 protokolü ile karşılayıp ssl bağlantısı kurmaya yarıyor. (Eğer ipv6 desteğiniz yok ise veya native olarak desteklemek istemiyorsanız kaldırabilirsiniz)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>server_name SUNUCU_ADINIZ; &gt;&gt; Eğer sunucu adınızı default olarak belirlemek istemiyorsanız bir Server Name Indicator belirleyebilirsiniz. Bu gelen tüm istekleri karşılamak yerine sadece sunucu adınıza gelen istekleri karşılamaya yarar.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_certificate /etc/letsencrypt/live/SUNUCU_ADINIZ/fullchain.pem; &gt;&gt; Eğer free ssl için Let&#39;s Encrypt kullanıyor iseniz default sertifika konumu burasıdır. Aksi halde kendi sertifika dosyanız ile değiştirin.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_certificate_key /etc/letsencrypt/live/SUNUCU_ADINIZ/privkey.pem; &gt;&gt; Eğer free ssl için Let&#39;s Encrypt kullanıyor iseniz default private key konumu burasıdır. Aksi halde kendi private key dosya konumunuz ile değiştirin.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_protocols TLSv1.3 TLSv1.2;  &gt;&gt; Sadece en güncel ve en güvenilir TLS protokollerini kabul etmek için gerekli komut.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_prefer_server_ciphers on; &gt;&gt; Sunucu ile istemcinin konuşması sırasında &#34;tamam nelerimiz var bakalım&#34; diye konuştuklarını tahmin ettiğim :D kısımda sunucunun sadece kendi seçtiği şifreleme algoritmaları ile bu görüşmeyi devam ettireceğini söylemesine yarayan komut. Kısacası işine gelirse böyle işine gelmezse konuşmuyorum.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_ecdh_curve secp521r1:secp384r1; &gt;&gt; Ekliptik eğrileri kullanmamız gereken durumlarda hangi eğrileri tercih ettiğimizi bildiren komuttur.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_ciphers DH-RSA-AES256-SHA:DH-RSA-AES256-SHA256:DHE-RSA-AES256-GCM-SHA384:DH-RSA-AES256-GCM-SHA384:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDH-ECDSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:ECDH-RSA-AES256-SHA:AECDH-AES256-SHA:ECDHE-ECDSA-AES256-SHA384:ECDH-ECDSA-AES256-SHA384:ECDH-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDH-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDH-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-CCM:DHE-RSA-AES256-CCM8:ECDHE-ECDSA-AES256-CCM:ECDHE-ECDSA-AES256-CCM8:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-CHACHA20-POLY1305:DHE-RSA-CHACHA20-POLY1305; &gt;&gt; En güvenilir bulduğum SSL algoritmalarının bir araya getirilerek sadece bunları kullanmasını sunucuya söyleyen kod.
</span></span></code></pre></div><p>Tek tek araştırmak isteyenler için tüm cipherlar: &ldquo;<a href="https://testssl.sh/openssl-iana.mapping.html%22">https://testssl.sh/openssl-iana.mapping.html"</a></p>
<p>Ayarları yaptıktan sonra kontrol etmek isterseniz: &ldquo;sudo nginx -t&rdquo; komutunu kullanabilirsiniz. Eğer bir hata mesajı görmez iseniz &ldquo;sudo systemctl restart nginx&rdquo; veya &ldquo;sudo service nginx restart&rdquo; komutu ile ayarları uygulayıp servisi baştan başlatabilirsiniz</p>
<h2 id="önerilen-ayarlar">Önerilen ayarlar</h2>
<p>Bir önceki ayarlara ek olarak performans özelinde bazı iyileştirmeler ve bunun yanı sıra sitenizin SSL test sitelerinde üst sıralara çıkmasını sağlayacak bazı ek konfigürasyonlar yapacağız. Bunun ardından ise sitenizin kullanıcı ile erişiminde faydalı olarak bazı başlıkları (header) ve sitenizin kaynaklarının üçüncü kişi siteler tarafından sömürülmemesi için bir takım iyileştirmeler yapacağız.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Eklenecek (varsa değiştirilecek) başlıklar
</span></span><span style="display:flex;"><span>ssl_session_cache shared:TLS:2m; &gt;&gt; TLS bağlantılarının işçiler (nginx workers) arasında nasıl dağıtılacağını ve ne kadar süre ile bağlantıların ortak kullanılacağını belirten kod
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_buffer_size 4k; &gt;&gt; SSL isteklerine cevap verirken ve handshake sonrası paket gönderimi yaparken paketlerin kaçlık konteynırlara bölüneceğini belirten kod. Daha düşük bir değer daha çok paket gönderilmesi ama daha az taşma (overhead) anlamına gelir.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_stapling on; &gt;&gt; OCSP zımbalama özelliğini aktif hale getirir
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssl_stapling_verify on; OCSP zımbalamanın üst ve kök sunucularda dahil olmak üzere doğrulanması özelliğini açar.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>resolver 1.1.1.1 1.0.0.1 2606:4700:4700::1111 2606:4700:4700::1001; &gt;&gt; Cloudlfare ile OCSP zımbalama doğrulamasının yapılmasını sağlar. Eğer IPV6 kullanmıyor veya native olarak desteklemek istemiyorsanız ipv6 adreslerini silebilirsiniz.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Content-Type-Options &#34;nosniff&#34; always; &gt;&gt; Tarayıcıların MIME içeriklerini anlamak için koklama (sniff) yapmasını engeleyen başlık değeridir.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Xss-Protection &#34;1; mode=block&#34; always; &gt;&gt; Olası bir XSS açığında kullanıcıların beyaz ekran görmesini sağlayarak açığı bir nebze de olsa engelleyen bir başlıktır.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header X-Frame-Options &#34;SAMEORIGIN&#34; always; &gt;&gt; Herhangi bir şekilde i-frame vb bir kod ile sunucunuzun bir sayfasının başka bir sayfada gösterilmesini ve/veya alt-alta üst-üste yayımlanmasını engeller. Sadece siz kendi siteniz içerisinde kendi sitenizden bir pencere yayımlayabilirsiniz.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Referrer-Policy &#34;no-referrer-when-downgrade&#34; always; &gt;&gt; Daha alt güvenlik önlemine sahip bir siteye yönlendirme veya link verdiğinizde otomatik olarak referrer başlığı eklemez ve sitenizden trafik geldiği belli olmaz.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Content-Security-Policy &#34;default-src &#39;self&#39; https: data: &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;&#34; always; &gt;&gt; Sizin ve diğer kullanıcıların dışarıdan çağırabilecekleri isteklerin hangi koşullar altında çağrılabileceğini düzenleyen başlık. Ben default olarak https üzerinden gelen bazı kaynaklara güveniyorum.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Permissions-Policy &#34;camera=(), fullscreen=(self), geolocation=(), microphone=(), payment=()&#34; always; &gt;&gt; Tarayıcıya hangi izinleri isteyeceğinizi veya hangilerine hiç ihtiyacınız olmayacağını belirterek çeşitli zehirleme türleri (cache-poisoning veya js-poisoning) ile sizin siteniz üzerinden bilgi toplanmasını engeller.
</span></span></code></pre></div><p>Ayarları yaptıktan sonra kontrol etmek isterseniz: &ldquo;sudo nginx -t&rdquo; komutunu kullanabilirsiniz. Eğer bir hata mesajı görmez iseniz &ldquo;sudo systemctl restart nginx&rdquo; veya &ldquo;sudo service nginx restart&rdquo; komutu ile ayarları uygulayıp servisi baştan başlatabilirsiniz.</p>
<h2 id="ileri-seviye-ayarlar">İleri Seviye Ayarlar</h2>
<p>Öncelikle sitenize sadece ssl üzerinden bağlanması gerektiğini gösterecek bir başlık ekleyeceğiz. Bu sayede sizin sitenize daha önce girmiş olanlar ve hali hazırda bu başlığı tarayıcısında mevcut olanlar istese bile sizin sitenize Non-SSL şekilde erişemeyecekler. Ardından ise HTTP oturumlarına kullanılması gereken SSL sertifikalarını zımbalayacağız ve önceki yöntemin yanından hangi sertifikalar ile bağlanması gerekeceğini de önceden belirtmiş olacağız. Bu sayede yetkili bir üst sertifika yöneticisi veya kök yöneticisi olsanız dahi sizin adınıza imzaladığı sertifika ile sizin sitenize bağlanamayacaklar. Zamaında Türkiyede yerleşik E-Tuğra Kök Sertifika sağlayıcısı *.google.com adresine bir sertifika imzaladı. Biraz araştırırsanız hangi dönemde meydana geldiğini ve nedenini (ne kadar kötü sonuçlara neden olabileceğini) fardekersiniz. Şimdi başlayalım son konfigürasyon kısmına.</p>
<p>Öncelikle sitenizin SSL üzerinden hiçbir soruna neden olmaksızın erişilebiliyor olduğundan emin olun. Ardından nginx konfig dosyasına aşağıdaki başlıklardan isteğinize göre birini ekleyin. Ama dikkat edin sadece bir tanesini.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=2592000;&#34; always; &gt;&gt; Sitenize 30 gün boyunca sadece HTTPS üzerinden erişilebileceğini belirten başlık. (Alt alan adları dahil değil)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=2592000; includeSubDomains;&#34; always; &gt;&gt; Sitenize alt alan adları da dahil olmak üzere 30 gün boyunca sadece HTTPS üzerinden erişilebileceğini belirten başlık.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains;&#34; always; &gt;&gt; Sitenize alt alan adları da dahil olmak üzere 1 yıl boyunca sadece HTTPS üzerinden erişilebileceğini belirten başlık.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=31536000; includeSubDomains; preload&#34; always; &gt;&gt; Sitenize alt alan adları da dahil olmak üzere 1 yıl boyunca sadece HTTPS üzerinden erişilebileceğini ve bu başlığın tarayıcıların önbelleğine alınması talimatını veren başlık. Ayrıca yeni çıkan tarayıcılar sitenize daha önce hiç girmese dahi bu başlıktan haberdar olacaktır.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>add_header Strict-Transport-Security &#34;max-age=0; includeSubDomains&#34;; &gt;&gt; HSTS özelliğini ve preload listesi üyeliğini tamamen kaldırmaya yarayan başlık.
</span></span></code></pre></div><p>Yukarıda belirtilen başlığı ekledikten sonra şimdi kullanmış olduğunuz ssl sertifikasının özetinin HTTP oturumuna zımbalanmasına geldi. Bu aşamada mevcut sertifikanızın bir özetini çıkarmamız, üst imzalayan yetkilinin sertifikasının özetini çıkarmamız ve en üst kök sertifika yetkilisi de dahil olmak üzere tüm zinciri tamamlayana kadar bu özet çıkarma sürecini devam ettirmemiz gerekiyor. Bu nedenle root kullanıcısı veya sudo yetkisine sahip bir kullanıcı ile aşağıdaki komutları sırasıyla çalıştırıyoruz. (Anlatım Let&rsquo;s Encrypt özelinde yapılmıştır.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1<span style="color:#f92672">]</span> cat /etc/letsencrypt/live/SUNUCU_ADINIZ/cert.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; Bu komut sizin sitenize ait sertifikanın özetini çıkaracaktır. Sonuç değerini bir yere kopyalayın.
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">]</span> curl -s https://letsencrypt.org/certs/lets-encrypt-x4-cross-signed.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; Bu komut letsencrypt<span style="color:#e6db74">&#39;e ait çoklu imzalı sertifikalardan bir tanesinin özetini çıkaracaktır.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">3] curl -s https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; Bu komut letsencrypt&#39;</span>e ait çoklu imzalı sertifikalardan bir tanesinin özetini çıkaracaktır.
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">]</span> curl -s https://letsencrypt.org/certs/isrgrootx1.pem | openssl x509 -pubkey | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64 &gt;&gt; Bu komut letsencrypt<span style="color:#e6db74">&#39;e ait kök (en üst) sertifikasının özetini çıkaracaktır.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Nginx config dosyasına aşağıdaki değer eklenir
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">5] add_header Public-Key-Pins &#39;</span>pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ILK_SONUC&#34;</span>; pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;IKINCI_SONUC&#34;</span>; pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;UCUNCU_SONUC&#34;</span>; pin-sha256<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;DORDUNCU_SONUC&#34;</span>; max-age<span style="color:#f92672">=</span>2592000; includeSubDomains<span style="color:#960050;background-color:#1e0010">&#39;</span> always; &gt;&gt; Sitenize <span style="color:#ae81ff">30</span> gün boyunca sadece belirtilen sertifika ile bağlanılmasına izin verir. Max-age değerini isteğe bağlı olarak artırabilirsiniz. Sertifika geçerlilik süreniz <span style="color:#ae81ff">30</span> günden daha az kalmadan başlığı devredışı bırakmanız veya yeni sertifika edinmeniz ve beşinci değer olarak onu eklemeniz gerekmektedir.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Bonus olarak sunucunuzun yapmasının çok uzun süreceği ama faydası çok olan bir komut daha göstermek istiyorum.
</span></span><span style="display:flex;"><span>6<span style="color:#f92672">]</span> openssl dhparam -out /etc/nginx/dhparams.pem <span style="color:#ae81ff">4096</span> &gt;&gt; Bu komutu uygulaması 15dk ile <span style="color:#ae81ff">1</span> saat arasında sürebilir.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>İşlem bittikten sonra nginx konfig dosyasına aşağıdaki komutu eklemeniz gerekmektedir.
</span></span><span style="display:flex;"><span>ssl_dhparam /etc/nginx/dhparam.pem; &gt;&gt; Diffie-Hellman anahtar değişim algoritması sırasında kullanılacak değerleri default değerler dışında az önce oluşturduğumuz gizli değerler ile değiştirmeye yarayan komut.
</span></span></code></pre></div><p>Ayarları yaptıktan sonra &ldquo;sudo nginx -t&rdquo; ve ardından eğer bir hata mesajı görmez iseniz &ldquo;sudo service nginx restart&rdquo; komutu ile ayarları uygulayıp servisi baştan başlatın. Artık sizin belirlediğiniz konfigürasyon ve şartlar ile bağlantı sağlanacaktır. Eğer öncesi/sonrası puanlama farkını görmek isterseniz aşağıdaki görsellere bakabilirsiniz veya kendi sitenizi &ldquo;<a href="https://www.ssllabs.com/ssltest/index.html%22">https://www.ssllabs.com/ssltest/index.html"</a> adresinden test edebilirsiniz.</p>
<p>İLK HALİ

<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-ilk-hali-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-ilk-hali-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-ilk-hali-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>SSL Labs test sonucu</b></small></center>
</picture></p>
<p>SON DURUM

<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-son-hali-ssllabs.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-son-hali-ssllabs.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/ssl-anlatim/ssl-son-hali-ssllabs.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>SSL Labs test sonucu</b></small></center>
</picture></p>
<p>Neden Cipher Strength %100 değil derseniz TLS 1.3 ile otomatik gelen ve biz istemesek de eklenen &ldquo;TLS_AES_128_GCM_SHA256 (0x1301)&rdquo; yüzünden şu an %100 yapmak mümkün değil. TLS 1.3&rsquo;ü kapatırım o zaman gelmez diye düşünürseniz o zaman da başka yerden puanınız gidiyor maalesef.</p>
<h1 id="son">Son</h1>
<p>Bu yazı daha önce <a href="https://teknolojirehberleri.xyz">https://teknolojirehberleri.xyz</a> adresinde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item><item><title>Linux Sunucularda SSH Güvenliği Artırma</title><link>https://wiseweb-works.github.io/blog/post/ssh-guvenligi/</link><pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/ssh-guvenligi/</guid><description>Linux Sunucularda SSH güvenliğini artırma Bugün sizlerle bir sunucu kiraladığınız zaman güvenli bir şekilde bağlanmamızı sağlayan SSH hizmetini nasıl daha güvenli ve dışarıdan gelecek kötü niyetli isteklerden uzak tutabiliriz bundan bahsedeceğim. Öncelikle süreci basit, önerilen ve ileri-seviye olarak üç farklı başlık altında anlatacağım. Başlık içerikleri kişisel gerekliliklere göre aşamalı düşünülmüştür. Başlıklar bir biri ile bağlantılı olmasına rağmen istenilen bir aşamada bırakılması sorun oluşturmayacaktır.
Basit Güvenlik Önlemleri Öncelikle içinde bulunduğumuz Linux sürümünün paket yöneticisi ile güncellemeleri konsol üzerinden yüklememiz gerekmektedir.</description><content:encoded><![CDATA[<h1 id="linux-sunucularda-ssh-güvenliğini-artırma">Linux Sunucularda SSH güvenliğini artırma</h1>
<p>Bugün sizlerle bir sunucu kiraladığınız zaman güvenli bir şekilde bağlanmamızı sağlayan SSH hizmetini nasıl daha güvenli ve dışarıdan gelecek kötü niyetli isteklerden uzak tutabiliriz bundan bahsedeceğim. Öncelikle süreci basit, önerilen ve ileri-seviye olarak üç farklı başlık altında anlatacağım. Başlık içerikleri kişisel gerekliliklere göre aşamalı düşünülmüştür. Başlıklar bir biri ile bağlantılı olmasına rağmen istenilen bir aşamada bırakılması sorun oluşturmayacaktır.</p>
<h2 id="basit-güvenlik-önlemleri">Basit Güvenlik Önlemleri</h2>
<p>Öncelikle içinde bulunduğumuz Linux sürümünün paket yöneticisi ile güncellemeleri konsol üzerinden yüklememiz gerekmektedir.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Ubuntu için: sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt upgrade -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Fedora için: sudo yum update -y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Arch Linux için: sudo pacman -Syyu
</span></span></code></pre></div><p>Güncellemeler yüklendikten sonra ise sunucunuzdaki (Benim olayımda Ubuntu) sshd servisini (ki bu servis dışarıdan ssh bağlantıları almanıza yarayan servistir) yapılandırmaya başlıyoruz. Öncelikle çok karıştırılması nedeniyle belirtmek gerekir ki ssh servisi ile sshd servisi farklı servislerdir. SSH servisi sunucunun başkaca bilgisayar veya sunuculara bağlanmasını yarayan servisken SSHD servisi başka bilgisayarların sizin sunucunuza bağlanmasını yani gelen bağlantıları karşılayan servistir.</p>
<p>SSHD servisinin ayarlarının tutulduğu dosya genel itibariyle &ldquo;/etc/ssh/sshd_config&rdquo; konumunda bulunur. Bunu kendi kullandığımız metin editörlerinden istediğimiz biriyle ama sudo (yani yönetici) yetkilerine sahip bir kullanıcı ile açmamız gerekmektedir.</p>
<p>Ubuntu üzerinden devam edecek olursak</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo nano /etc/ssh/sshd_config <span style="color:#75715e"># Ayar dosyasını açmaya yarayan komut</span>
</span></span></code></pre></div><p>Bulup değiştireceğimiz başlıklar</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#ClientAliveInterval 0  &gt;&gt; Başındaki hashtag işaretini kaldırıyoruz ve &#34;0&#34; olan değeri 300 yapıyoruz. Bu komut bağlantı kullanılmadığı (idle konumunda kaldığı) zaman kaç sn sonra bağlantının otomatik kapatılacağını düzenler
</span></span><span style="display:flex;"><span>#PermitEmptyPasswords no &gt;&gt; Başındaki hashtag işaretini kaldırıyoruz ve &#34;no&#34; olan değeri değiştirmiyoruz. Bu komut boş veya şifresiz kullanıcıların bağlanmasını engeller. Yani boş şifrelere izin vermez.
</span></span><span style="display:flex;"><span>X11Forwarding yes &gt;&gt; Eğer başında hastag var ise kaldırıyoruz yok ise &#34;yes&#34; olan değeri no olarak değiştiriyoruz. Bu komut sunucu üzerinde GUI arayüzüne sahip uygulamaları çalıştırma kolaylığı sağlamasına rağmen suistimal edilmesi mümkün bir durum olduğundan kapatıyoruz.
</span></span><span style="display:flex;"><span>#MaxAuthTries 6 &gt;&gt; Başındaki hashtag işaretini kaldırıyoruz ve &#34;6&#34; olan değeri 3 yapıyoruz. Bu komut şifrenizi kaç kez deneyebileceklerini düzenler. 6 sayısı gereksiz derece yüksek bir değer olup genel kabul 3 ve veya 4 olması yönündedir.
</span></span><span style="display:flex;"><span>#Protocol 2 &gt;&gt; Eğer başında hastag var ise kaldırıyoruz, böyle bir kayıt hiç yok ise &#34;Protocol 2&#34; şeklindeki değeri ilk bulduğumuz boşluğa ekliyoruz. Bu komut SSH&#39;ın sadece en yeni protokolü ile bağlantıların yapılmasını sağlayarak eski protokolün açıklıklarından sizi korur.
</span></span></code></pre></div><p>Ayarları yaptıktan sonra kontrol etmek isterseniz: &ldquo;sudo sshd -t&rdquo; komutunu kullanabilirsiniz. Eğer bir hata mesajı görmez iseniz &ldquo;sudo systemctl restart sshd&rdquo; veya &ldquo;sudo service sshd restart&rdquo; komutu ile ayarları uygulayıp servisi baştan başlatabilirsiniz</p>
<h2 id="önerilen-ayarlar">Önerilen ayarlar</h2>
<p>Bir önceki ayarlara ek olarak kullanıcı bazlı oturum açma, sadece güvenli anahtar kullanarak oturum açma ve Root kullanıcısı ile oturum açmayı kısıtlama gibi ek ayarlamalar yapacağız. Öncelikle yerel bilgisayarınızdaki kullanıcınız için bir gizli anahtar üretmeniz gerekiyor. Bunun için eğer linux tabanlı bir işletim sistemi kullanıyor iseniz</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ssh-keygen -t rsa -b 4096 # yazdıktan sonra aşağıdaki sorulara cevap olarak istediğiniz şifreyi giriniz
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter passphrase (empty for no passphrase): [Press enter key]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter same passphrase again: [Press enter key]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>veya
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssh-keygen -t ecdsa -b 521 # Daha güvenli ve daha hızlı olan ekliptik anahtar üretir. Aşağıdaki sorulara cevap olarak istediğiniz şifreyi giriniz
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter passphrase (empty for no passphrase): [Press enter key]
</span></span><span style="display:flex;"><span>&gt;&gt;&gt;&gt; Enter same passphrase again: [Press enter key]
</span></span></code></pre></div><p>Diğer sorulara Enter&rsquo;a basarak cevap vermiş ve anahtar için belirli bir konum yazmamış iseniz anahtar çiftiniz (.pub= halka açık anahtar) / uzantısız olan gizli anahtar) /home/KULLANICI_ADINIZ/.ssh klasörüne kaydedilmiştir. Ürettiğiniz anahtarı sunucunuza tanıtmak için aşağıdaki kodu kullanabilirsiniz.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ssh-copy-id -i ~/.ssh/ANAHTAR_ISMINIZ.pub SUNUCUDAKI_KULLANICI_ADINIZ@SUNUCU_IP_ADRESI # yazdıktan sonra kullanıcınızın şifresini sorucak ve doğru girdiğiniz takdirde onay mesajı ile karşılaşacaksınız.
</span></span></code></pre></div><p>Kendi anahtarınızı ürettikten sonra sunucuya sadece anahtar ile erişmek için;
Bulup değiştireceğimiz başlıklar</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#PasswordAuthentication no &gt;&gt; Başındaki hashtag işaretini kaldırıyoruz ve &#34;no&#34; olan değeri no olarak bırakıyoruz. Bu komut sunucuya şifre ile bağlanmayı engeller. Kullanıcılar sadece ssh_keyleri ile bağlanabilirler.
</span></span><span style="display:flex;"><span>PubkeyAuthentication yes &gt;&gt; Eğer var ise başındaki hastag işaretini kaldırıyoruz ve değeri yes olarak belirliyoruz. Bu komut az önce oluşturduğunuz gizli key ile oturum açmanıza izin veren komuttur.
</span></span><span style="display:flex;"><span>#PermitRootLogin no &gt;&gt; Başındaki hashtag işaretini kaldırıyoruz ve &#34;no&#34; olan değeri no olarak bırakıyoruz. Bu komut ROOT kullanıcısının ki en yetkili kullanıcıdır sunucuya erişmesini engelliyor. Ancak başka bir kullanıcı ile erişip sonra ROOT kullancısına geçiş yapabilirsiniz.
</span></span><span style="display:flex;"><span>AllowUsers KULLANICI_ADINIZ &gt;&gt; Eğer yok ise böyle bir kayıt ekliyoruz. Başka kullanıcıların sunucuya bağlanmasını ve/veya kullanıcı adı denemesi yapmasını engelliyor.
</span></span><span style="display:flex;"><span>LoginGraceTime 20 &gt;&gt; Eğer yok ise böyle bir kayıt ekliyoruz ve değeri 20 olarak ayarlıyoruz. Oturum açmak için gereken süreyi saniye cinsinden belirliyor. Uzun süre oturum açma isteği ile sunucuyu meşgul etmelerini engelliyoruz.
</span></span><span style="display:flex;"><span>ChallengeResponseAuthentication no &gt;&gt; Var ise başındaki hastag işaretini kaldırıyoruz ve değeri no olarak belirliyoruz. Bu komut diğer oturum açma yöntemlerini devre dışı bırakıyor.
</span></span><span style="display:flex;"><span>KerberosAuthentication no &gt;&gt; Var ise başındaki hastag işaretini kaldırıyoruz ve değeri no olarak belirliyoruz. Bu komut diğer oturum açma yöntemlerini devre dışı bırakıyor.
</span></span><span style="display:flex;"><span>GSSAPIAuthentication no &gt;&gt; Var ise başındaki hastag işaretini kaldırıyoruz ve değeri no olarak belirliyoruz. Bu komut diğer oturum açma yöntemlerini devre dışı bırakıyor.
</span></span></code></pre></div><p>Ayarları yaptıktan sonra kontrol etmek isterseniz: &ldquo;sudo sshd -t&rdquo; komutunu kullanabilirsiniz. Eğer bir hata mesajı görmez iseniz &ldquo;sudo systemctl restart sshd&rdquo; veya &ldquo;sudo service sshd restart&rdquo; komutu ile ayarları uygulayıp servisi baştan başlatabilirsiniz</p>
<h2 id="ileri-seviye-ayarlar">İleri Seviye Ayarlar</h2>
<p>Öncelikle standart SSH bağlantı portu olan 22 yi değiştirip ardından SSH bağlantısı sırasında kullanılan şifreleme araçlarını daha da güçlü hale getireceğiz. Ardından sunucunu SSH hizmetinin loglarının (kayıt defteri kayıtlarının) nasıl tutulacağını belirleyeceğiz.</p>
<p>Bulup değiştireceğimiz başlıklar</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>#Port 22 &gt;&gt; Bunu bulup başındaki hastag işaretini kaldırıyoruz ve oraya başka hizmet tarafından kullanılmayan ve açık olan bir port numarasını yazıyoruz. Örneğin 2992 olabilir.
</span></span><span style="display:flex;"><span>LogLevel INFO &gt;&gt; Bu ayarı bulup değiştiriyoruz yok ise ekliyoruz. Kayıt seviyesini belirlememize yarıyor.
</span></span><span style="display:flex;"><span>AllowAgentForwarding no &gt;&gt; Bu ayarı bulup değiştiriyoruz yok ise ekliyoruz. Alternatif yönlendirme yöntemlerini devredışı bırakıyor.
</span></span><span style="display:flex;"><span>AllowTcpForwarding no &gt;&gt; Bu ayarı bulup değiştiriyoruz yok ise ekliyoruz. Alternatif yönlendirme yöntemlerini devredışı bırakıyor.
</span></span><span style="display:flex;"><span>PrintMotd no &gt;&gt; Bu ayarı bulup değiştiriyoruz yok ise ekliyoruz. Bağlantı kurulmadan önce sunucu ile ilgili bilgi sahibi olmalarını engellemek için.
</span></span><span style="display:flex;"><span>PermitUserEnvironment no &gt;&gt; Bu ayarı bulup değiştiriyoruz yok ise ekliyoruz.
</span></span><span style="display:flex;"><span>PermitTunnel no &gt;&gt; Bu ayarı bulup değiştiriyoruz yok ise ekliyoruz.
</span></span></code></pre></div><p>Daha da ileri giderek SSH bağlantısı sırasında kullanılan şifreleme algoritmalarını, doğrulama algoritmalarını, anahtar değişim algoritmalarını ve diğer algoritmaların hangilerinin öntanımlı olacağını belirliyoruz.</p>
<p>Root kullanıcısı veya sudo yetkisine sahip bir kullanıcı ile aşağıdaki komutları sırasıyla çalıştırıyoruz.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>1<span style="color:#f92672">]</span> rm /etc/ssh/ssh_host_*
</span></span><span style="display:flex;"><span>2<span style="color:#f92672">]</span> ssh-keygen -t rsa -b <span style="color:#ae81ff">4096</span> -f /etc/ssh/ssh_host_rsa_key -N <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>3<span style="color:#f92672">]</span> ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>4<span style="color:#f92672">]</span> awk <span style="color:#e6db74">&#39;$5 &gt;= 3072&#39;</span> /etc/ssh/moduli &gt; /etc/ssh/moduli.tmp
</span></span><span style="display:flex;"><span>5<span style="color:#f92672">]</span> mv /etc/ssh/moduli.tmp /etc/ssh/moduli
</span></span><span style="display:flex;"><span>6<span style="color:#f92672">]</span> sed -i <span style="color:#e6db74">&#39;s/^\#HostKey \/etc\/ssh\/ssh_host_\(rsa\|ed25519\)_key$/HostKey \/etc\/ssh\/ssh_host_\1_key/g&#39;</span> /etc/ssh/sshd_config
</span></span><span style="display:flex;"><span>7<span style="color:#f92672">]</span> echo -e <span style="color:#e6db74">&#34;KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group-exchange-sha256\nCiphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\nMACs hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,umac-128-etm@openssh.com\nHostKeyAlgorithms ssh-ed25519,ssh-ed25519-cert-v01@openssh.com,sk-ssh-ed25519@openssh.com,sk-ssh-ed25519-cert-v01@openssh.com,rsa-sha2-256,rsa-sha2-512,rsa-sha2-256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com&#34;</span> &gt; /etc/ssh/sshd_config.d/ssh-hardening.conf
</span></span></code></pre></div><p>Ayarları yaptıktan sonra &ldquo;sudo sshd -t&rdquo; ve ardından eğer bir hata mesajı görmez iseniz &ldquo;sudo service sshd restart&rdquo; komutu ile ayarları uygulayıp servisi baştan başlatın. Artık yeni belirlediğiniz port üzerinden ve sadece sizin gizli anahtarınız ile sunucuya bağlanabileceksiniz. Bağlanmak için ise;</p>
<pre tabindex="0"><code class="language-texte" data-lang="texte">ssh -i ~/.ssh/ANAHTAR_ISMINIZ SUNUCUDAKI_KULLANICI_ADINIZ@SUNUCU_IP_ADRESI -p PORT_NUMARASI # komutunu kullanabilirsiniz. Gelen bildirimlere Enter deyip devam edebilirsiniz.
</code></pre><h1 id="son">Son</h1>
<p>Bu yazı daha önce <a href="https://teknolojirehberleri.xyz">https://teknolojirehberleri.xyz</a> adresinde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item><item><title>Maximum Kart reklamı Rubicon nehrini geçti mi?</title><link>https://wiseweb-works.github.io/blog/post/maximum-kart-reklami/</link><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/maximum-kart-reklami/</guid><description>Maximum Kart’ın artık müze kartı olarak geçerli olmadığı şu günlerde “Zaten müze müze gezip de ne yapacağız, biz Cem Yılmaz izliyoruz o bize yetiyor” şeklinde düşünen arkadaşlar için bir içerik hazırladım. Bildiğiniz veya benim de uydurmuş olabileceğim üzere İş bankasının maximum kart departmının Cem Yılmaz ve diğer sanatçılar ile yapmış olduğu 4–6 reklamlık bir iş birliği (PR) anlaşması mevcuttu. Bu süreçte bankanın ve kartın kullanımını teşvik edecek ve aynı zamanda da Cem Yılmaz üzerinden bilinirliliğini artırıcı bir takım reklamlar çekildi ve basında yayımlandı.</description><content:encoded><![CDATA[<p>Maximum Kart’ın artık müze kartı olarak geçerli olmadığı şu günlerde “Zaten müze müze gezip de ne yapacağız, biz Cem Yılmaz izliyoruz o bize yetiyor” şeklinde düşünen arkadaşlar için bir içerik hazırladım. Bildiğiniz veya benim de uydurmuş olabileceğim üzere İş bankasının maximum kart departmının Cem Yılmaz ve diğer sanatçılar ile yapmış olduğu 4–6 reklamlık bir iş birliği (PR) anlaşması mevcuttu. Bu süreçte bankanın ve kartın kullanımını teşvik edecek ve aynı zamanda da Cem Yılmaz üzerinden bilinirliliğini artırıcı bir takım reklamlar çekildi ve basında yayımlandı. Bu reklamdan büyük bir çoğunluğu son kullanıcıya hitap eden ve direkt ürünün olduğu yerde (market, kafe v.b.) çekilmiş reklamlar olmasına rağmen içlerinden bir tanesi tamamen başka bir atmosferde çekilmişti. Sadece müze kart övmesi için bu kadar prodüksiyona ne gerek vardı diye düşünürken Cem Yılmazın böyle ilginç içerikleri çok sevdiği ve çok az kişinin anladığı ufak espiriler bıraktığı aklıma geldi. Mesela meşhur G.O.R.A filmindeki “evet evet tarafından” espirisinin bir dönem anlaşılmamış olması ve Cem Yılmazın bizatihi kendisi tarafından açıklanması sonucunda meşhur olması gibi. İşte ben de bugün sizlerle bu reklamı inceleyecek ve üzerine bir şeyler söyleyeceğim.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/weFr-uSNjHo?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>Öncelikle reklamın tümünde geçen replikler veya arka planların hepsi büyük özenle seçilmiş yerler. Hani bir savaş sahnesi canlandıralım diye yapılmış şeyler değil. Reklamın başladığı yer o dönem Galyalılara ait olan ve Vercingetorix tarafından yönetilen 80.000 kişi ile en büyük Galya şehri olan Alesia’dır. Yapılan savaş da şehirden ismini alan Alesia savaşıdır. Savaş M.Ö 52 yılında Sezar komutasındaki 12 lejyonla (30,000–60,000 kişi)’nin günümüzdeki Paris sınırları içerisinde kalan Alesia şehrini kuşatması sonucunda çıkıyor. Tüm Avrupayı neredeyse fetheden Roma İmparatorluğu bir türlü bu Galyalıları (Fransa civarlarında) yenemiyor. En sonunda direkt saldırmaya karar veriyorlar ama bilmiyorlar ki Galyalılar savunmada acayip iyiler. Gerçekten de beklenilen oluyor ve Galyalılar kaleye çekiliyor. Sezar ne yaptıysa kaleye yaklaşamıyor ve surları aşamıyor. Adamları açlık ile karşı karşıya bırakmış olmasına rağmen Galyalılar teslim olmuyor bir türlü.</p>
<p>
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/maximumkart/maximum-kart-afis.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/maximumkart/maximum-kart-afis.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/maximumkart/maximum-kart-afis.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Alesia Savaşı Günümüzde Olsaydı</b></small></center>
</picture></p>
<p>Videonun daha ilk saniyede gözüken sarımsı bayrak Galyalıların kullandığı renk olup tahminimce eski bayraklarından birisidir. Normalde bayrakları yine o renk olmak üzere bir kartal-kuş türünü barındıran bir bayraktır ama renk direkt bu. Truva atı olayı M.Ö 13. yy da geçen ve yine Paris civarlarında yapılan bir taktiktir. Yine o civarda yaşamış Akhalılar tarafından yapılan iş bu taktik bu yüzden “daha önce denendi olmaz” deyip geçiyor. Sonrasında ise Brütüs’e dönüp “sen dur” veya “sen de var ya” der gibi bakması ve mimikleri Sezar ile Brütüs arasındaki bıçaklama olayına bir gönderme. Maximus ismi direkt maximum karta bir atıf olmasının haricinde filmde bu neyin kafası diyen (o dönemki lider) Sezardan sonraki adama gönderme. Tam adı Marcus Maximus Aurelius Antoninus Augustus olan ve sezardan sonra hüküm süren bir lider. Sonunda geçen “Biz buraya Sezarı övmeye değil gömmeye geldik.” sözü de orada beyaz kafası gözüken Marcus Antonius’a bir göndermedir. Kendisi Sezar’a suiskastten yargılanmış birisidir. Bence bu haliyle (benim yakalayabildiğim) reklam efsane kurgulanmış. Son olarak ilk kredi kartının çıkış tarihi ile Savaş tarihi olan M.Ö 52 arasında yaklaşık 2.000 Yıl olması da bir tesadüf değildir diye düşünüyorum.</p>
<p>Rubicon nehrini geçmek özdeyişi adını İtalya’da bulunan rubicon nehrinden alır. Roma Cumhuriyeti döneminde komutanlar askeri güçleri ve kimlikleri ile başkente giremeyeceği ve demokrasiye aykırı bir eylem olarak görüldüğü için Roma şehir sınırlarından biri olan Rubicon nehrini geçmek askerlere yasaklanmıştı. Roma’yı ele geçirmek isteyen komutanlar ilk eylem olarak bulundukları karargahtan çıkarak Rubicon nehrini geçer ve bu artık geri dönüşü olmayan bu yola girerlerdi. Bu öyle bir yoldu ki artık kararlarından vazgeçseler bile cezalandırılacaklardır. O yüzden Rubicon’u geçmeyi çok iyi hesaplamak, çok iyi düşünmek gerek. Maximum Kart Cem Yılmaz ile böyle bir reklam yaparak bence kitleleri etkileyecek bir şey yapmak istemiş olsa da kimsenin farketmeyeceği ama bence çok güzel bir reklama imza attılar.</p>
<p>Bütün bu anlatımlardan sonra “bize maximum kart tarafından böyle bir şey söylenmedi” veya “kafandan uyduruyorsun bütün bunları” diyecekseniz sizi bonus sahneye alayım.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/e6AbhhSOjEE?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>NOT: Bu yazı daha önce şahsi medium.com adresimde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item><item><title>PGP nedir ve gerçekten de oldukça iyi bir gizlilik sağlıyor mu?</title><link>https://wiseweb-works.github.io/blog/post/pgp-ve-gizlilik/</link><pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/pgp-ve-gizlilik/</guid><description>PGP Türkçede oldukça iyi gizlilik anlamına gelen Pretty Good Privacy kelimesinin baş harflerinde oluşturulmuş bir veri şifreleme, şifre çözme ve verileri elektronik olarak imzalama programıdır. Phil Zimmermann tarafından 90&amp;rsquo;lı yılların başında akademik bir makale olarak ortaya çıkmış ve yayımlandığı dönemden çok sonra gerçekten kullanılmaya ve getirilerinden yararlanılmaya başlanmıştır. Söz konusu program ilk ortaya çıktığı zamanlarda bir ihtiyacın kendisini ortaya çıkmaya zorlamasından ziyade daha çok bir düşünce deneyi olarak iletişimin her iki tarafı arasındaki verilerin şifrelenebileceği ve bunun nasıl yapılması gerektiği sorusu üzerine ortaya çıkmıştır.</description><content:encoded><![CDATA[

    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/VGz1dZ4Sg-g?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>PGP Türkçede oldukça iyi gizlilik anlamına gelen Pretty Good Privacy kelimesinin baş harflerinde oluşturulmuş bir veri şifreleme, şifre çözme ve verileri elektronik olarak imzalama programıdır. <a href="https://tr.wikipedia.org/w/index.php?title=Phil_Zimmermann&action=edit&redlink=1">Phil Zimmermann</a> tarafından 90&rsquo;lı yılların başında akademik bir makale olarak ortaya çıkmış ve yayımlandığı dönemden çok sonra gerçekten kullanılmaya ve getirilerinden yararlanılmaya başlanmıştır. Söz konusu program ilk ortaya çıktığı zamanlarda bir ihtiyacın kendisini ortaya çıkmaya zorlamasından ziyade daha çok bir düşünce deneyi olarak iletişimin her iki tarafı arasındaki verilerin şifrelenebileceği ve bunun nasıl yapılması gerektiği sorusu üzerine ortaya çıkmıştır. Ortaya çıkışının ardından gönderilen verilen şifrelenmesinin ve şifresinin taraflarca çözülmesinin yanına bir de verinin bütünlüğünün korunmasını sağlayan özet fonksiyonu ve mesajı gönderen kişinin kimliğinin doğrulanması sağlayan (ve kimi zaman inkar edilemezlik olarak da anılan) imzalama özelliği eklenmiştir. Ortaya çıktığı dönemde ve sonrasında açık kaynak kodlu olarak yayımlanmaya devam etmiş ve günümüzde OpenPGP adı altında gelişerek faaliyetlerine devam etmektedir. PGP’nin ortaya çıktığı 1991 yılından 6 sene sonra yani 1997 yılında kendilerine Internet Engineering Task Force (görev gücü biraz abartı olmadı :D) adını veren bir çalışma grubu PGP programının sağlamış olduğu şifreleme özelliklerinin piyasa standartı haline gelmesi ve kullanımının kolaylaştırılması için yazılar yayımlamaya başladılar.</p>
<p>
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/pgp-anlatim/pgp-encryption.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/pgp-anlatim/pgp-encryption.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/pgp-anlatim/pgp-encryption.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>https://zappysys.com/blog/ssis-pgp-encryption-decryption (Erişim Zamanı: 08.04.2023)</b></small></center>
</picture></p>
<p>PGP’nin şifreleme ve şifre çözme özelliklerinin nasıl çalıştığını ve internet alemi için neden bu kadar büyük bir atılım anlamına geldiğini insanlara anlatmaya başladılar. PGP asimetrik şifreleme denilen ve günümüzde internet tarayıcılarından elektronik imza ile girişi destekleyen tüm internet sitelerinde ve özellikle bankalarda kullanılan bir şifreleme/şifre çözme şeklidir. Asimetrik şifrelemeden kısaca bahsedersek eğer (sadece asimetrik şifrelemeyi tüm detaylarıyla anlatan bir yazı da gelecek) şifrelemeyi yapan anahtar ile şifrelenmiş veriyi açacak olan anahtarın farklı olduğu ve birbirlerinden üretildiği bir şifreleme türüdür. Bu şifreleme türünde sizin public (genel) anahtarınız ve private (gizli) anahtarınız mevcuttur. Bu anahtarlardan birisi ile yapılan şifrelemeyi aynı anahtar açamayıp sadece diğer anahtar ile açılması/çözülmesi mümkündür. Daha kolay anlaşılması için bir örnek üzerinden gidelim. Eskiden çelik kapılarda ve kepenklerde bolca kullanılan asma kilitleri gözümüzün önüne getirelim. Şimdi bu kilitler üretildiği zaman bu kilidi açabilecek anahtar da yanında üretilip son kullanıcıya yanında veriliyor. Bana şifreli bir şekilde bir yazı veya bir dosya göndermek istediğinizi düşünelim. Görece olarak güvenli bulduğunuz bir kutuya bana göndermek istediğiniz dosyaları koyup daha sonra da benden almış olduğunuz şahsi asma kilidimi üzerine takıyorsunuz. Bu aşamada benim size vermiş olduğum tek şey bir asma kilit ve anahtarlar hala bende. Kutu kapatıldıktan ve asma kilit üzerine takıldıktan sonra asma kilidin demirlerini ittirerek içine geçirip kutuyu tamamen kilitli bir hale getiriyorsunuz. Bu aşamadan sonra size vermiş olduğum asma kilidi kullanarak kutuyu açma imkanınız yok hatta içine koyduğunuz şeyleri de artık kapattıktan sonra tekrar değiştirmeniz mümkün değil. Benim aynı asma kilitten yüzlercesine sahip olduğumu ve hepsinin aynı ve sadece bende olan bir anahtar ile açıldığını düşündüğünüzde etrafımdaki insanlara anahtarsız bir asma kilit vermenin çok da sorun olmayacağından emin olabilirsiniz. Asimetrik anahtar ile şifreleme yapılırken de gizli (private) anahtarınız ile yüzlerce genel (public) anahtar üretebilirsiniz fakat private keyiniz her zaman için tekdir. Artık benim kilidim ile kilitlenmiş kutuyu bana göndermeniz ve benim de onu kendime ait gizli anahtar ile açmam sonucunda güvenli bir şekilde bir iletişim sağlamış olduk.</p>
<p>PGP’nin bize sağlamış olduğu bir anahtar ile şifreleyip sadece diğer anahtar ile o verinin açılabilmesi özelliği dönemi için çok üst düzey bir şifreleme ve güvenlik işleviydi. Şifreleme için kullanılan anahtarların uzunluğu 2048 Bit, 3072 Bit ve 4096 Bit boyutundaydı. 1 Bitin 8 Bayt olduğunu düşünürseniz bu sayıların hem bir insan için hem de o dönemin bilgisayarları için oldukça büyük sayılar olduğunu anlamışsınızdır. O dönem daha hızlı olması (düşündüğünüz kadar hızlı değil) için en düşük anahtar boyutu olan 2048 Bit kullanılmış olup genel olarak gönderilen maillerin içeriğinin (sadece içerik kısmı) ve ekte gönderilen dosyaların şifrelenmesi şeklinde kullanılmıştır. 2048 Bit yerine en yüksek anahtar boyutu olan 4096 Bit kullanıldığı zaman her ne kadar anahtar boyutu 2 kat artmış olsa da hız yerine göre 4 ile 10 kat arasında azalmaktaydı. Ortalama 200–400 karakterden oluşan bir salt yazının şifrelenmesi sırasında en düşük anahtar boyutu ile şifrelenmesi bilgisayarınızın gücüne bağlı olarak 1 ila 10 sn arasında değişebiliyordu. Bu nedenle daha uzun anahtar boyutuna sahip 4069 Bit’in şifreleme süreci çok uzun sürmekteydi. Şimdi bakıldığında 1–2 dk gibi süreler çok kısa gibi gelse de sadece bir metni göndermek için bu kadar beklemenizin gerekiyor olması o dönem için gerçekten can sıkıcıydı. Üstelik sizin şifreleme sürecinde beklediğiniz kadar da şifrelemeyi çözecek anahtara sahip kişiyi de çözüm sırasında bekletiyordunuz.</p>
<p>PGP ile veri gönderilmesi ile ilgili bir örnek ile devam edelim. Mesela sizin için çok önemli olan bir veriyi göndermek istiyorsunuz. Önce farazi olarak (umarım nükleer fırlatma kodları değildir) bir yazılı metin seçelim. Benim seçtiğim veri:</p>
<blockquote>
<p>“u, iki u daha, birincisi küçük u, ikincisi büyük u, 1 j, 3 3 3( üç tane 3 rakamı ama üçüncüsü küçük 3), yumuşak g, 6 a, k, küçük hığıı, 6 milyon. iki milyar. ama iki milyar yazıyla” ALINTI</p>
</blockquote>
<p>Önce bu veriyi… arkadaşlar yazıyı yazarken sıkıldım. Kusura bakmayın bunu da bu kadar anlatmış olayım. Ben keyfime düşkün bir adamım sıkılınca yapamıyorum.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/Z8aqzdARZns?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<p>NOT: Bu yazı daha önce şahsi medium.com adresimde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item><item><title>Grigori Rasputin ve aynı isimli şarkı hk</title><link>https://wiseweb-works.github.io/blog/post/grigori-rasputin/</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/grigori-rasputin/</guid><description>Nerede doğduğunu bilmediğimiz Grigori Rasputin isimli bu arkadaşın çocukluk yılları daha çok Sibirya geçiyor. Mavi gözleri ve etkileyici mimikleri var. Daha küçük yaştan itibaren insanları etkilemeyi ve ilgi çekmeyi başaran bir yapısı mevcut. Hatta bir keresinde yaşı küçük olmasına rağmen babasının çiftliğinden çalınan bir atı kimin çaldığını kehanet yoluyla tahmin eder. Herkes (babası da dahil) Rasputin’e inanmamış olsa da sonradan hırsız kendisi gelip suçunu itiraf eder. Bu olaydan sonra ailesi ve bütün çevresi onun gerçekten doğaüstü güçlere sahip olduğunu düşünmeye başlamıştır.</description><content:encoded><![CDATA[<p>Nerede doğduğunu bilmediğimiz Grigori Rasputin isimli bu arkadaşın çocukluk yılları daha çok Sibirya geçiyor. Mavi gözleri ve etkileyici mimikleri var. Daha küçük yaştan itibaren insanları etkilemeyi ve ilgi çekmeyi başaran bir yapısı mevcut. Hatta bir keresinde yaşı küçük olmasına rağmen babasının çiftliğinden çalınan bir atı kimin çaldığını kehanet yoluyla tahmin eder. Herkes (babası da dahil) Rasputin’e inanmamış olsa da sonradan hırsız kendisi gelip suçunu itiraf eder. Bu olaydan sonra ailesi ve bütün çevresi onun gerçekten doğaüstü güçlere sahip olduğunu düşünmeye başlamıştır.</p>
<p>Büyüdükten sonra ailesi tarafından Rusyanın başka bir bölgesine gönderilir ve burada manastırda eğitim almaya başlar. Fakat kehanetleri azalmadığı gibi artmaya da başlar. İlgileri yine üzerine çekmeyi başarır burada da. Öyle ki 1904 yılında Çar Romanov’un küçük oğlu Aleksi’nin hemofili olduğunu öğrenir ve çocuğu ancak kendisinin tedavi edebileceğini iddia eder. Yine bir vaazında 1. Dünya Savaşından ve yaklaşmakta olan Bolşevik devriminden bahseder. Tarih tabiiki de onun yanılmadığını bize gösterecektir. Artık saraya çok yakındır ve vaazlarında Aleksi’nin hastalığını kendisinin tedavi edebileceğini çariçe Aleksandrova’ya açıklar. Çariçe kendisini saraya çağırır ve böylelikle Petersburg ve Kremlin saraylarının kapıları Rasputin’e sonuna kadar açılmış olur.</p>
<p>Kısaca hayatından bahsettikten sonra <a href="https://www.youtube.com/watch?v=kvDMlk3kSYg">Boney M. grubunun şarkısında</a> daha çok geçen ve ölümünü (!) anlatan kısma gelmek istiyorum. Bu kısımdan sonra anlatılanlar bir miktar yoruma dayalı olmakla birlikte anlatılanlar arasında tam bir mutabakat yoktur.</p>
<p>Rasputin, Prens Yusufov tarafından bir davete çağrılır, fakat Prens, Rasputin’i kendisi ile özel bir konuda görüşmek bahanesiyle davetten önce evine daha bütün misafirler gelmeden ayrı getirtir. Durum oldukça gariptir, Rasputin’i bahçe tarafında bodrum katında bir odaya indirirler fakat ikramda kusur yoktur. Siyanürle hazırlanan kurabiyeler ve yine siyanürlü şarap sunulur Rasputin’e. Merakla Prens’in ne anlatacağını bekleyen Rasputin, kurabiyeleri afiyetle yer ve hatta şaraptan da birkaç kadeh içer. Bir türlü konuya girmeyen ve lafı geveleyen Prens, Rasputin’e hiçbir şey olmadığını görünce telaşa kapılır, müsaade ister ve komployu hazırladığı ve yine evde başka bir odada onu bekleyen İngiliz ajanından yardım ister. İngiliz ona bir silah verir ve sessizce bu işi bitirmesini söyler. Prens silahı alır, odaya gider ve iki el ateş eder, başından ve boynundan yaralanan Rasputin yere yığılır. Komplocu Prens bu işi bitirdiğini zannederek yukarı çıkar ve diğer işbirlikçileri aşağıya çağırır. Fakat iki metrelik bu dev Sibiryalıyı öldürmek o kadarda kolay değildir. Prens ve komplocular odaya girdiklerinde Rasputin ayaktadır, ölmemiştir. Rasputin kendisini bahçeye atar ve kaçmaya başlar. Fakat katiller peşine düşerler ve Rasputin bahçe duvarını aşacakken arkasından ateş ederler ve durdururlar. Artık bu tehlikeli adamı öldürdüklerini düşünürler ve cesedini neva nehrine atarlar. Ceset birkaç gün sonra nehirden çıkarılır, otopsi yapılır. Otopsi raporuna göre Rasputin kurşunlardan değil ciğerine dolan sudan, yani boğularak ölmüştür. Onu öldürmek hiçte kolay olmamıştır anlaşılan.</p>
<p>Burada bir parantez açmak istiyorum. Boğulan ve ciğerler patlayarak dışarı çıkan birinin sadece birkaç organının zarar görmüş olacağını düşünmek mantıksız. Hem cildi hem de diğer bütün hayati organları zarar görmüştür bu olaylar sonunda. Kendisini bulduklarını düşündükleri zaman teşhis etme konusunda emin olamamışlardır. Bu yüzden ben o anda dahi ölmediğini ve efsaneler aslını yaşatır kuralı gereğince hayatına bir süre daha devam ettiğini düşünüyorum. Kendisi aynı zamanda <strong>rasPUTİN</strong> ismine sahip olduğu ve Rusyanın en önde gelen şahsı ile isimleri benzediği için şarkıları son zamanlarda oldukça ön planda. Gerçi Putin başta oldu olalı bu şarkılar ön planda ama şu son 5–6 senedir bu şarkılar üzerinden Putin övmesine doyamadılar maalesef. Hatta <a href="https://www.youtube.com/watch?v=YgGzAKP_HuM">“Rasputin — Funk Overload”</a> adlı videoda Boney M. grubunun yapmış olduğu şarkıya bir animasyon ile farklı bir hava katmışlar. Ayrıca ilgili videonun içinde Putin ile ilgili bir bonus bölüm de mevcut. Hem eğlenceli hem de remix tarzı bir video olmuş. Bu kısa yazımız maalesef bitti.</p>
<p>Bu hikayeyi yazarken faydalandığım siteleri kaynakça gibi eklemek isterdim ama paralel evrende şu anda tam olarak 10 dk geçti ve benim daha önemli işlerim var. O yüzden sevgili (!) Putine bir selam çakıp aranızdan ayrılıyorum.</p>
<p>NOT: Bu yazı daha önce şahsi medium.com adresimde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item><item><title>Modern kriptografi yöntemlerinin Star Wars filmi ile ilişkisi</title><link>https://wiseweb-works.github.io/blog/post/modern-kriptografi-star-wars/</link><pubDate>Tue, 28 Apr 2020 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/modern-kriptografi-star-wars/</guid><description>Uzun uzun bir zaman önce (!) pek de uzak olmayan bir galakside yaşayan insanlar internet üzerinden yapmış oldukları işlemlerin daha güvenli bir temele oturması ve bu iletişimin tarafları dışındaki üçüncü kişilerin bu iletişimi dinleyememesi ve hakkında bilgi sahibi olamaması için bir takım şifreleme yöntemleri geliştirmeye karar verirler. INTRO
Daha önceden üniversitelerin matematik ve bilgisayar programcılığı bölümlerinde yapılmış akademik çalışmaların ötesine geçememiş olan şifreleme (cryptography) alanı artık bireylerin iyiliği için kullanılacaktı.</description><content:encoded><![CDATA[<blockquote>
<p>Uzun uzun bir zaman önce (!) pek de uzak olmayan bir galakside yaşayan insanlar internet üzerinden yapmış oldukları işlemlerin daha güvenli bir temele oturması ve bu iletişimin tarafları dışındaki üçüncü kişilerin bu iletişimi dinleyememesi ve hakkında bilgi sahibi olamaması için bir takım şifreleme yöntemleri geliştirmeye karar verirler. <a href="https://starwarsintrocreator.kassellabs.io/#!/BM5xzF-d7ZTSDYuCtJC9">INTRO</a></p>
</blockquote>
<p>Daha önceden üniversitelerin matematik ve bilgisayar programcılığı bölümlerinde yapılmış akademik çalışmaların ötesine geçememiş olan şifreleme (cryptography) alanı artık bireylerin iyiliği için kullanılacaktı. Bu ilke imza atacak ilk kişilerin arkadaş olmasının dışında onları birleştiren asıl şey Star Wars’ın orijinal üçlemesini çocuklukları döneminde birlikte izlemiş ve etkinlenmiş olmalarıdır. 1977 Yılında orijinal üçlemenin ilk, tarihsel sıralamaya göre ise dördüncü film olan <a href="https://en.wikipedia.org/wiki/Star_Wars_(film)">Star Wars A New Hope</a> vizyona girmiş ve tüm çevreler tarafından beğeniyle izlenmişti. İlk filmin vizyona girişinden sonraki 3. ve 6. senelerde serinin beşinci ve altıncı filmleri olan <a href="https://en.wikipedia.org/wiki/The_Empire_Strikes_Back">The Empire Strikes Back</a> ve <a href="https://en.wikipedia.org/wiki/Return_of_the_Jedi">Return of the Jedi</a> de peş peşe vizyona girmiş ve seyircisinin filmden beklentisini ve serinin devamına olan isteğini artırmıştır. Serinin o dönemki yönetmeni George Lucas izleyenleri daha iyi bir üçlemeye hazırlamak adına orijinal üçlemenin üçüncü filminin vizyona girdiği tarih olan 1983 yılından 1999 yılına kadar seriye yeni film çıkarmamış ve teknolojik imkanların gelişmesini beklemiştir. Yani tarihsel üçleme efsanesinin ve de modern kriptografinin bence başladığı yıl olan 1999 yılına gelinene kadar. 90&rsquo;lı yıllar kendilerini Cypherpunks olarak adlandıran ve açık kaynak kodunu yücelten, gizlilik ve bireyin anonimlik hakkı üzerinde bir manifesto yayımlayan, bilgisayar ve teknoloji ile birlikte büyümüş bir neslin dönemiydi. İnternetin ülkemize gelişi ve tüm dünyadaki internet ağının gelişmesi ile birlikte 2000&rsquo;li yıllara girmeye yaklaştığımız dönemlerde kişi başına düşen bilgisayar sayısı oranı artmış ve her eve olmasa da birçok haneye geniş bant internet hizmeti ulaşmış bulunmaktaydı. İşte ülkemizde internet yeni yeni kabul görmeye ve kullanılmaya başlandığı dönemlerde yurt dışında bir arkadaş topluluğu World Wide Web (WWW)’in eksik taraflarından biri olan şifreleme ve gizlilik üzerine odaklanmaya başlamıştı bile.</p>
<p>Basit anlatımıyla internet üzerinde bir websitesi barındırmamıza ve dünya üzerindeki herhangi bir bilgisayarın bu web sayfasına erişebilmesine imkan tanıyan bu servis temelde güzel olmasına rağmen çok büyük bir dezavantajı vardı. Bu dezavantaj bağlanmış olduğunuz internet sitesi ile aranızdaki bağlantının herhangi bir şekilde şifrelenmemesi, güvenli olmaması ve dahili/harici üçüncü kişiler tarafından bu iletişimin izlenebilir, değiştirilebilir ve dahi engellenebilir olmasıdır. Eskiden bir internet sitesine girdiğiniz zaman adres çubuğunda bir kilit simgesi ve aşağıda gördüğünüz gibi “Connection is secure” veya “Connection is not private” gibi bir bağlantının güvenli /güvensiz olduğunu düşündürecek bir bildirim yoktu. Çünkü o yıllarda bir internet sitesine üye olurken veya mail gönderirken iletişimin izlenebileceği veya bunu kötü amaçlar için kullanılabileceği henüz düşünülmemişti.</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">
<picture>
  
  
  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/starwars-kriptografi/connection-is-secure.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/starwars-kriptografi/connection-is-secure.webp" type="image/webp">

  

  <img
    src="https://wiseweb-works.github.io/blog/images/starwars-kriptografi/connection-is-secure.jpg"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Bağlantı Güvenli Bildirimi Chrome</b></small></center>
</picture></td>
<td style="text-align:center">
<picture>
  
  
  

  

  
    

    <source srcset="https://wiseweb-works.github.io/blog/images/starwars-kriptografi/not-private-notification.avif" type="image/avif">

    
    

    <source srcset="https://wiseweb-works.github.io/blog/images/starwars-kriptografi/not-private-notification.webp" type="image/webp">

  <img
    src="https://wiseweb-works.github.io/blog/images/starwars-kriptografi/not-private-notification.png"
    loading="lazy"
    decoding="async"
    width= min(100%, 720px)
    height= auto
  />
  <center><small><b>Bağlantı Güvenli Değil Bildirimi Chrome</b></small></center>
</picture></td>
</tr>
</tbody>
</table>
<p>Konunun girişine eklenmiş olan videoda 1977 yapımı Star Wars New Hope filminde (bunca yıldan sonra spoiler denemez artık) Galaktik İmparatorluk tarafından bütün galaksiyi yok edebilecek güçte ve devasa ölçekte bir ölüm yıldızı yapıldığının haberi alınır. Bu haberin alınması üzerine kendilerine Rebellion (isyancı) diyen bir grup bu ölçekte ve güçte bir geminin normal gemi savaşları ile yok edilemeyeceğini anlamış ve bu planları çalıp geminin zayıf noktalarını incelemeye karar vermişlerdir. Orijinal üçlemenin ilk filmi olmasına rağmen tarihsel olarak 4&rsquo;ncü film olması nedeniyle filmin başlangıcında bu planların çalındığını fakat henüz inceleme imkanı bulunamadan planları çalan uzay gemisinin imparatorluk kuvvetleri ve meşhur Dart Vader tarafından kovalandığını görüyoruz. Kovalamacanın sonuna doğru ellerindeki planları güvenli bir şekilde isyan kuvvetlerinin ana karargahına göndermeleri gerektiğini fakat imparatorluk kuvvetleri tarafından takip edilirken bunun çok zor olacağını anlayan Prenses Leia kendisince en güvenli gördüğü yöntemi kullanarak R2-D2 sınıfı bir robotun belleğine planları yükler ve filmimiz burada başlar. Videonun başlangıcında Dart Vader ve imparatorluk kuvvetleri tarafından geminin tamamı aranmasına rağmen Ölüm Yıldızının çalınmış planları bir türlü bulunamaz. Her ne kadar asilerden biri olduğu bilinse de (henüz Dart Vader tarafından ispatlanamamış) Prenses Leia diplomatik bir resmi görevde olduğunu söylemiş ve kendilerine böyle bir verinin gelmediğini iddia etmiştir. Yapılan incelemede gemiden böyle bir verinin aktarıldığını gösteren bir bilgiye de rastlanamamış olması sevgili Vader’ımızı çokça kızdırmıştır.</p>
<p>Günümüzden 21 sene önce vizyona girmiş olan <a href="https://en.wikipedia.org/wiki/Star_Wars:_Episode_I_%E2%80%93_The_Phantom_Menace">The Phantom Menace</a> filmi her ne kadar modern şifrelemeyi doğrudan etkilememiş olsa da bu bir grup kişiye yıllar önce izlemiş ve beğenmiş oldukları orijinal üçlemenin ilk filmini ve bence ilk sahnesini hatırlamalarına neden oldu. O dönem gelişmekte olan gizlilik, anonimlik ve güvenlik düşünceleri neticesinde filmi izledikten sonra eski günleri yad etmek ve düşüncelerini paylaşmak için bir kafede bir araya geldiler. Genel arkadaş muhabbetinden ve havadan sudan konuşulduktan sonra aralarından biri konuşmanın ve bence tarihin de seyrini değiştiren şu soruyu sordu:</p>
<blockquote>
<p>How can I keep communication private and secure when sending Death Star’s stolen blueprints ?</p>
</blockquote>
<p>Arkadaş grubu önce bir sessizliğe büründü ve soruyu soran kişi aynı ses tonuyla soruyu tekrarladı ve bu sefer sonuna <strong>“But without using R2-D2 or any kind of Droid :D”</strong> ekledi. Grupta yükselen gülüşmelerin ve filmle ilgili ardı ardına söylenen repliklerin ardından gruptaki kişiler birbirlerine bakarak bu soruna nasıl bir çözüm bulabileceklerini veya bunu kimin yapabileceğini düşünmeye koyuldular. Çok geçmeden bu soruya cevap bulabilecek kişilerin aslında bu sorunu ilk farkeden kişiler yani grup arkadaşları olduğunu anladılar. Hepsi ülkelerinde önemli üniversitelerden mezun olmuş ve alanlarında uzmanlaşmak, kendilerini geliştirmek için akademik kariyerlerine devam etmişlerdi. O dönem için böyle bir projenin yapılması için gerekli tüm matematiksel sorunların çözümü ile bilgisayarda yapılması gereken kodlamanın altından grup olarak kalkabileceklerini düşündüler. Grup olarak önce kullanıcıdan kaynaklı çözüm yöntemleri ile başlayıp ardından sunucular ve genele inen bir proje planı yaptılar. İlk olarak PGP (Pretty Good Privacy) adı ile anılan ve ilk dökümanlarının yayımlanmasının üzerinden neredeyse 8 sene geçmiş bir veri şifreleme-çözme yöntemi üzerinde durdular. Bu yöntemin (günümüzde nispeten daha güvenli olan) mail alışverişi sırasında kullanılmasının taraflar arasındaki gizliliği artıracağını düşündüler. Böylece kendilerine sormuş oldukları sorunun “güvenlik” kısmını irdelemeye başladılar ve bu başlangıç onları hiç tahmin edemeyecekleri yerlere ve kişilere götürdü. Onlar seçimini kırmızı hapı almaktan yana kullandılar. Böylece bilgisayardaki harikalar diyarının ve tavşan deliğinin ne kadar derin olduğunu tüm insanlara gösterme imkanı buldular. Yazı her ne kadar Star Wars filmi ile ilişkisi üzerinden devam etmiş olsa da Matrix filminin de aynı dönemde vizyona girdiği düşünüldüğünde böyle bir baş yapıttan etkilenilmediğini düşünmek yanlış olur.</p>
<p>Eğer yazının bu kısmına kadar gelmeyi başardıysanız merakınızın sizi bir yerlere sürüklediğini, siz istediğiniz ve ben kendimde yazma kuvveti bulduğum sürece bu tavşan deliğinin ne kadar derin olabileceğini birlikte keşfedeceğimizi anlamışsınızdır. Eğer her yerde anlatılan alışılmış hikayelerin ve kalıplaşmış kabullerin ötesinde bilgisayar ve insan arasındaki ilişkinin nasıl işlediğini, arka planda neler olduğunu öğrenmek istiyorsanız beni Twitter&rsquo;dan ve şu an bulunduğunuz medium sitesinden takip edebilirsiniz. Sizlere şimdilik “her x günde veya x haftada bir yazı” şeklinde bir söz veremiyorum. Sizlere karşı verebileceğim tek söz benden bir şey beklemezseniz sizi bu konuda hayal kırıklığına da uğratamayacağım olacaktır. Yazı bitti. After credit sahnesini izlemek isteyenler için videomuza geçiyoruz.</p>
<p>NOT: Bu yazı daha önce şahsi medium.com adresimde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item><item><title>Umursamazlık Üzerine</title><link>https://wiseweb-works.github.io/blog/post/umursamazl%C4%B1k-uzerine/</link><pubDate>Wed, 25 Feb 2015 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/umursamazl%C4%B1k-uzerine/</guid><description>Bir arkadaşım bana geçtiğimiz günlerde “istemediğin veya vazgeçtiğin zaman nasıl böyle umursamaz olabiliyorsun ?” diye sordu. Arkadaşımın da merak ettigi bu konudan bahsetmek istiyorum biraz.
Öncelikle bunu neden yaptım sorusuna cevap vererek başlamak istiyorum. Cevabı çok basit. Canım böyle istiyor çünkü. Bunun adına koca bir felsefe yıkmaktansa sadece öyle istediğim icin yapmak bana daha mantıklı geldi. Siz de takdir edersiniz ki sevmediğiniz bir insanla veya grup ile konuşmak istemez hatta bir adım daha ötesi görmek istemezsiniz.</description><content:encoded><![CDATA[<p>Bir arkadaşım bana geçtiğimiz günlerde “istemediğin veya vazgeçtiğin zaman nasıl böyle umursamaz olabiliyorsun ?” diye sordu. Arkadaşımın da merak ettigi bu konudan bahsetmek istiyorum biraz.</p>
<p>Öncelikle bunu neden yaptım sorusuna cevap vererek başlamak istiyorum. Cevabı çok basit. Canım böyle istiyor çünkü. Bunun adına koca bir felsefe yıkmaktansa sadece öyle istediğim icin yapmak bana daha mantıklı geldi. Siz de takdir edersiniz ki sevmediğiniz bir insanla veya grup ile konuşmak istemez hatta bir adım daha ötesi görmek istemezsiniz. Ben buna bir de vazgeçtiğim seyleri de ekledim. Sonuçta simdi uyguladığım davranış tarzı ortaya çıktı.</p>
<p>Kavga ettiğiniz veya tartıştığınız bir insan düşünün öncelikle. Ertesi gün okulda, sokakta muhtemelen tekrar göreceğiniz biri hem de bu kisi. Ve biliyorsunuz ki sonrasında bu sürtüşmelerin veya laf dalaşlarının devamı gelecek. Hele bir de bana genelde olduğu gibi yapışkan bir insan ile karşı karşıya iseniz isiniz bayağı zor olacaktır. Az veya çok bir sürenin sonunda (Cinnete beş kala) tamamen bağınız kopacak. Artık birbirimizi tanımıyor gibi davranacaksın ve görmek sizi o kadar da rahatsız etmeyecek, hatta umursamayacaksın.</p>
<p>Ardından benim sonradan eklediğim kısma gecelim. Üzerinde sürekli düşündüğünüz bir şey var. Bu sevdiğiniz bir kız/erkek de olabilir sizi bundan daha fazla düşünmeye iten bir şey olabilir veya birçok kisiye saçma gelebilecek ama sizin icin onemli daha birçok şey olabilir. Demek istediğimi anladınız örnekleri daha da uzatmaya gerek yok, zeki insanlarız hepimiz. Bu durumda sevgili Einstein’ın dediği veya benim kafamdan da uydurmuş olabileceğim gibi “Beyin bir düşünce düzeyine ulaştığında tekrar eski haline gelmesi oldukça zordur.” Ortalama bir hesap yaparsak 7–8 hafta kafanızı bu seye yorsanız. Bunun en az bir 3–4 hafta da düzelme süresi olsa hayatınızdan 10–12 hafta gitti demektir. Ki ben bunu saçmalık olarak adlandırıyorum.</p>
<p>İste ben aradaki kısımları atlayıp direk sonuca varıyorum. Zaten tartıştığım, sevmediğim bir insanla bir süre daha devam etmek bana mantıklı gelmiyor çünkü. Kendimi buna mecbur et memeli diye düşünüyorum. Direk görmezden geliyorum. Düşünsel olarak beni yoran şeye gelince de vazgeçmem gerektiğini anladım veya bırakıyorum benden bu kadar dediğim zaman direk bırakıyorum. Koşan insanın birdenbire durması gibi yani. İlk is elimde ne var ne yoksa siliyorum, atıyorum veya unutuyorum(hı-hı dediğinizi duyar gibiyim). Ertesi gün sanki hiç böyle bir şey olmamış gibi davranıyorum. Ve ne olursa olsun bundan ödün vermiyorum.</p>
<p>Peki bu şekilde davrandığı zaman ne gibi sıkıntılar ile karşılaşıyorum onu söyleyeyim. İnsanlar eski sisteme alıştıkları için gelip karşınıza size serzenişte bulunabiliyorlar. Siz de onları umursamayıp hatta sadece yüzlerine ne saçmalıyor bu gibisinden bakıp suskunluğunuzu bozmayınca çekip gidiyorlar. Bu sahne birkaç sefer daha tekrarlansa da sonuc genelde benim lehime oluyor. Siz bir zarar görmemiş oluyorsunuz ama karşınızdaki en uygun tabirleri küplere biniyor, sizin davranışlarınıza deli oluyor. Ama hiçbir şey yapamıyor çünkü duvara vurmak, kafa atmak gibi saçma bir hareket olur mu. Evet duvara kafa atmak. Hiç de saçma bir örnek değil bu. Duvarda sessiz sakin öyle durur. Sinirli olduğunda bazen duvara vuranlar ne bileyim yumruk atanlar, kafa atanlar oluyor. Sonuc ise hüsran oluyor.</p>
<p>Simdi sonucun bu şekilde olacağını bildiğiniz zaman “umursamamak” düşündüğünüzden daha kolay oluyor. Çünkü artık bu konuda bir motivasyonunuz var. Ve şunu da söylemek gerekir ki bunu söyleyebilecek kafaya gelmek icin bir çok olay yaşadım. Çok saçma seyler yaptım ve tabiri olarak duvara tosladım. Dedim bir şeyler yapmak lazım. Geçmişe bakınca böyle bir şey yapmalı dedim. Bu yüzden sunu da anladım ki sevgili Steve’in dediği veya benim de uydurmuş olabileceğim gibi “Noktaları ileriye bakarak birleştiremezsiniz. Noktalar geriye baktığınızda birleşir.” Ben bugün baktığımda noktalar çok net birleşiyor. Ama biz de duvara çarpmak istiyoruz, noktaları biz de göreceğiz diyorsanız tercih sizin. Bildiğiniz gibi bütün uyuyanları uyandırmak için tek bir uyanık yeter. Ben üzerime düşeni yaptım.</p>
<p>Eğer söylediklerimi mantıklı bulduysanız, doğru geliyorsa, sizde öyle yapıyorsanız, yapmayı düşünüyorsanız, yardımcı olduysam veya olumlu bir şey söylemek istiyorsanız bana aşağıdaki yeşilli kalp simgesi veya ona benzeyen şeye basmanız gerekiyor. Zaten kaç kisinin okuduğunu, anlık görüntülenme oranını filan görüyorum. Benim icin önemli olan göremediğim ve sadece sizin bana iletebileceğin şey. Görüşleriniz. Ama sadece olumluları almak istiyorum. O yüzden sadece olumlu ileti butonu var. Olumsuzları görüşlerinizi bir A4 kağıdına yazın ve isiniz bitince kağıdı çöpe atın. Kesinlikle yere degil ama. Son.</p>
<p>NOT: Bu yazı daha önce şahsi medium.com adresimde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
]]></content:encoded></item><item><title>Arkadaslık ve Dostluk Üzerine</title><link>https://wiseweb-works.github.io/blog/post/arkadaslik-ve-dostluk/</link><pubDate>Thu, 29 Jan 2015 00:00:00 +0000</pubDate><guid>https://wiseweb-works.github.io/blog/post/arkadaslik-ve-dostluk/</guid><description>Bir gün muhabbet sırasında “Çevrem çok geniştir ama arkadaşlarım azdır dostlarım ise bi’kaç tanedir.” şeklinde bir cümle kurmuşum. Etrafımda şaşkınlığa yol açan bu cümle benim için alelade bir söz değildi. Fakat o anda anlatılacak kadar da basit değildi. Eve gidip üzerinde biraz düşünüp, anlamlandırıp, örneklendirip anlatılması gerektiğini düşündüm. Ve şimdi karşınızdayım (somut olarak olmasa da) ve bugün bu konuda konuşmak istiyorum.
Bu konuyu 2’e ayırıp incelemek istiyorum. İlk olarak çevreden ben ne anlıyorum, benim için ne anlam ifade ediyor bundan bahsetmek istiyorum.</description><content:encoded><![CDATA[<p>Bir gün muhabbet sırasında “Çevrem çok geniştir ama arkadaşlarım azdır dostlarım ise bi’kaç tanedir.” şeklinde bir cümle kurmuşum. Etrafımda şaşkınlığa yol açan bu cümle benim için alelade bir söz değildi. Fakat o anda anlatılacak kadar da basit değildi. Eve gidip üzerinde biraz düşünüp, anlamlandırıp, örneklendirip anlatılması gerektiğini düşündüm. Ve şimdi karşınızdayım (somut olarak olmasa da) ve bugün bu konuda konuşmak istiyorum.</p>
<p>Bu konuyu 2’e ayırıp incelemek istiyorum. İlk olarak çevreden ben ne anlıyorum, benim için ne anlam ifade ediyor bundan bahsetmek istiyorum. Bence insanın çevresi daha önce tanıştığı insanlar, tanışmamış olsa da hakkında ortalama bilgi sahibi olduğu insanlar veya da en azından aynı payda da yerleşebileceği insanlardır. Bunu söyle düşünebiliriz: üniversitede okuyorsunuz (en azından ben okuyorum) ve bir sürü insanla beraber günümüzün çoğunu geçiriyorsunuz. İlk adımda ortalama bir kısmı ile tanışıyorsunuz. Bu tanıştığınız kisi sayısı size ve arkadas grubunuza göre değişebilir. İkinci adımda gelip geçerken veya arkadas ortamında gördüğünüz, muhabbette adı geçen veyahut da kendiliğinden bir tanınırlığa sahip kişiler vardır. Bu zamana kadar tanımamışsınız demek ki daha da konuşmayacaksınız demektir. Üstelik bunlarla tanışmanız resmiyetten öteye geçmez. Zaten sizin ile olabilecekleri en iyi durumdadırlar. Fazlasını beklememek gerek. Üçüncü adımda ise belirli organizasyonlarda, önemli zamanlarda veya sizin için anlam ifade eden herhangi bir zamanda ortak paydada bir kesebileceğiniz insanlar vardır. Bunlar bir nebze vardır ama bir o kadar da yoklardır aslında. Her zaman göremezsiniz veya görmezlikten gelirsiniz. Ama işiniz düştüğünde veya lazım olduklarında -kısa veya uzun zamanlı- bir birlikteliğiniz olur. Sonrasında eski halinize iade.</p>
<p>Bu üç adımda anlattığım insanların hepsi sizin hareketleriniz veya sözleriniz ile olumlu/olumsuz olarak etkileyebileceğiniz veya harekete geçirebileceğiniz insanlardır. Bir piramit olarak düşündüğümüzde hepsi seviye seviyedir. Bulundukları seviye ile elde edilen etki orantılıdır. Bunu bir deprem dalgasına benzetebiliriz. Merkez üssünden uzaklaştıkça etki ve güç gittikçe azalır, kontrolü merkezden bağımsız olmaya baslar. Depremin yer altındaki merkezi birinci asamadır. En yüksek etki orada gözükür. Depremin yüzeye ilk çıktığı yer ise depremin ikinci etkili olduğu yerdir. Deprem dalgalarının son ulaştığı nokta ise üçüncü asamadır. Depremin zaman zaman etkili olduğu yerdir. Etki bazen gözükmektedir. Ben çevreden bunları anlamaktayım.</p>
<p>Kanunun 2’nci kısmına gelince arkadas ve dost ayrımını yapacağım. Ardından bu kavramların benim için ne ifade ettiğinden bahsedeceğim. Yukarıda çevremden bahsederken ilk aşamada tanıştığınız insanları söylemiştim. Bu tanıştığımız insanlar da gene kendi içinde 3’e ayrılıyor. İlk atama minimum seviyede samimiyettir. Ben buna arkadaşlık öncesi tanışıklık evresi diyorum. Tanıştığınız insanları gördüğünüzde en azından bir selam verirsiniz, yeri gelirse yan yana oturursunuz bazen de çay-kahve filan içersiniz. Çoğu zaman adını bile unutmuş olabilirsiniz. Ama bunu hiç belli etmezsiniz. İkinci aşamada ortalama bir samimiyetiniz vardır. Ben buna sizin de bildiğiniz arkadaşlık diyorum. Vaktinizin yeterli bir kısmını beraberce geçirirsiniz. Beraber ders çalışılır, yemek yer ve de belki en önemlisi okul dışında da etkileşimde bulunuyorsunuz. gezmeye çıkarsınız, telefonda konuşursunuz, dertlerinizi paylaşır, zamanla bir ritim tutturursunuz. Bu ritim tutturduktan sonra bir kısır döngü gibi kendini tekrar etmeye baslar. Ta ki biri bu döngüden sıkılıp seviyeyi daha ileriye götürmek isteyene veya artık bitirmek isteyene kadar. Benim için ikisi de benzer şeyleri ifade etmektedir. Çünkü bu istek sizi geri dönüsü olmayan bir yola götürür. Ya hep ya hiç misali bir sonuç elde edersiniz. Ya sevginizi açar birlikteliğiniz başka bir aşamaya taşırsınız, ya da arkadaşlığınızı dostluk aşamasına taşırsınız. İkisi hem aynı yeri ifade eder hem de bir o kadar farklı yerleri. Belirgin bir sekilde iki yol da tercih edilebilir. Ama aynı seviyeyi ifade etmelerine rağmen birbirinin yerini tutamayacağı kesindir. Ben şimdilik dostluktan bahsetmek istiyorum. Dostluk benim için basit bir tabirle sınırların ve engellerin bir çoğunun kaldırılmasıdır. O kadar ki artık konuşmadan da anlaşabilir, birbirinizin yerine hissedebilir, üzülebilirsiniz. Hareketlerinizi değerlendirmeden uygulayabilirsiniz. Çünkü artık kendi benliğinizden biriyle berabersiniz dir. Aranızda artık “acaba?” ve “keşkeler yoktur. geçirdiğimiz zamanları süper ve süper üstü olarak adlandırırsınız. En önemlisi de birbirinize güvenin çok yüksektir. Çünkü artık karşı karşıya değil yan yanasındır.</p>
<p>Bu kadar anlatımdan sonra asıl cevaba ulaşmak üzereyim. Neden samimiyet seviyesi arttıkça sayısal olarak azalma oluyor. Bu ters orantının sebebi nedir ? Cevabı bir ekonomi teorisinden ibaret: “Arz ile talep ters orantılıdır.” Yani az olan şey daha çok makbuldür. Bütün insanlarla iyi anlasan herkese dostum diyen bir insanın düşündüğünüz zaman aklınıza gelen ilk kelimeler büyük ihtimal “samimiyetsiz” ve “yalaka” olacaktır. Evet her ne kadar bunu fark etmesek de bir çoğumuz bu durumu kötü buluruz. Ben buna bir sebep daha ekliyorum. Samimiyet arttıkça o kişiye ayırmamız gereken ilgi, alaka, zaman artmakta. Doğal olarak bu kadar fazla karsı edimimizin olduğu bir kişiden çok fazla olmasını istemeyiz. Bunu söyle örnekleyebiliriz. Çocuk sahibi olmak isteyen bir anne düşünün. 2–3 tane çocuğu olduğu zaman optimal sekilde onlarla ilgilenebilir ve bundan mutluluk duyabilir. Ama 6–7 gibi yüksek sayılara ve belki de daha üstüne çıkıldıkça artık ne ilginin paylaştırılabilmesi mümkün olabilmekte ne de bu durumdan mutluluk alınabilmektedir.</p>
<p>Durum tamamen bundan ibarettir sevgili arkadaşlar. Bir daha ki yazıda görene kadar güzel günler sizlerle olsun efendim. İyi günler.</p>
<p>NOT: Bu yazı daha önce şahsi medium.com adresimde yayımlanmıştır. Kişisel portfolyo oluşturmak adına şahsi sitemde yeniden yayımlama ihtiyacı hissettim.</p>
]]></content:encoded></item></channel></rss>